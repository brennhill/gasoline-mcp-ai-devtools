{
  "version": 3,
  "sources": ["../src/content/tab-tracking.ts", "../src/content/script-injection.ts", "../src/content/request-tracking.ts", "../src/content/message-forwarding.ts", "../src/content/window-message-listener.ts", "../src/content/timeout-utils.ts", "../src/content/message-handlers.ts", "../src/content/runtime-message-listener.ts", "../src/content/favicon-replacer.ts", "../src/content.ts"],
  "sourcesContent": ["/**\n * @fileoverview Tab Tracking Module\n * Manages tracking status for the current tab\n */\n\nimport type { StorageChange } from '../types';\n\n// Whether this content script's tab is the currently tracked tab\nlet isTrackedTab = false;\n// The tab ID of this content script's tab\nlet currentTabId: number | null = null;\n\n/**\n * Update tracking status by checking storage and current tab ID.\n * Called on script load, storage changes, and tab activation.\n */\nexport async function updateTrackingStatus(): Promise<void> {\n  try {\n    const storage = await chrome.storage.local.get(['trackedTabId']);\n\n    // Request tab ID from background script (content scripts can't access chrome.tabs)\n    const response = await chrome.runtime.sendMessage({ type: 'GET_TAB_ID' }) as { tabId?: number } | undefined;\n    currentTabId = response?.tabId ?? null;\n\n    isTrackedTab =\n      currentTabId !== null &&\n      currentTabId !== undefined &&\n      currentTabId === storage.trackedTabId;\n  } catch {\n    // Graceful degradation: if we can't check, assume not tracked\n    isTrackedTab = false;\n  }\n}\n\n/**\n * Get the current tracking status\n */\nexport function getIsTrackedTab(): boolean {\n  return isTrackedTab;\n}\n\n/**\n * Get the current tab ID\n */\nexport function getCurrentTabId(): number | null {\n  return currentTabId;\n}\n\n/**\n * Initialize tab tracking (call once on script load)\n */\nexport function initTabTracking(): void {\n  // Initialize tracking status on script load\n  updateTrackingStatus();\n\n  // Listen for tracking changes in storage\n  chrome.storage.onChanged.addListener((changes: { [key: string]: StorageChange }) => {\n    if (changes.trackedTabId) {\n      updateTrackingStatus();\n    }\n  });\n}\n", "/**\n * @fileoverview Script Injection Module\n * Injects capture script into the page context\n */\n\n/**\n * Inject axe-core library into the page\n * Must be called from content script context (has chrome.runtime API access)\n */\nexport function injectAxeCore(): void {\n  const script = document.createElement('script');\n  script.src = chrome.runtime.getURL('lib/axe.min.js');\n  script.onload = () => script.remove();\n  (document.head || document.documentElement).appendChild(script);\n}\n\n/**\n * Inject the capture script into the page\n */\nexport function injectScript(): void {\n  const script = document.createElement('script');\n  script.src = chrome.runtime.getURL('inject.bundled.js');\n  script.type = 'module';\n  script.onload = () => script.remove();\n  (document.head || document.documentElement).appendChild(script);\n}\n\n/**\n * Initialize script injection (call when DOM is ready)\n */\nexport function initScriptInjection(): void {\n  // Inject when DOM is ready\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      injectAxeCore(); // Inject axe-core first (needed by inject script)\n      injectScript();\n    }, { once: true });\n  } else {\n    injectAxeCore(); // Inject axe-core first (needed by inject script)\n    injectScript();\n  }\n}\n", "/**\n * @fileoverview Request Tracking Module\n * Manages pending requests for AI Web Pilot features\n */\n\nimport type {\n  HighlightResponse,\n  ExecuteJsResult,\n  A11yAuditResult,\n  DomQueryResult,\n} from '../types';\nimport type { PendingRequestStats } from './types';\n\n// Pending highlight response resolvers (keyed by request ID)\nconst pendingHighlightRequests = new Map<number, (result: HighlightResponse) => void>();\nlet highlightRequestId = 0;\n\n// Pending execute requests waiting for responses from inject.js\nconst pendingExecuteRequests = new Map<number, (result: ExecuteJsResult) => void>();\nlet executeRequestId = 0;\n\n// Pending a11y audit requests waiting for responses from inject.js\nconst pendingA11yRequests = new Map<number, (result: A11yAuditResult) => void>();\nlet a11yRequestId = 0;\n\n// Pending DOM query requests waiting for responses from inject.js\nconst pendingDomRequests = new Map<number, (result: DomQueryResult) => void>();\nlet domRequestId = 0;\n\n/**\n * Clear all pending request Maps on page unload (Issue 2 fix).\n * Prevents memory leaks and stale request accumulation across navigations.\n */\nexport function clearPendingRequests(): void {\n  pendingHighlightRequests.clear();\n  pendingExecuteRequests.clear();\n  pendingA11yRequests.clear();\n  pendingDomRequests.clear();\n}\n\n/**\n * Get statistics about pending requests (for testing/debugging)\n * @returns Counts of pending requests by type\n */\nexport function getPendingRequestStats(): PendingRequestStats {\n  return {\n    highlight: pendingHighlightRequests.size,\n    execute: pendingExecuteRequests.size,\n    a11y: pendingA11yRequests.size,\n    dom: pendingDomRequests.size,\n  };\n}\n\n/**\n * Get the next highlight request ID and register a resolver\n */\nexport function registerHighlightRequest(resolve: (result: HighlightResponse) => void): number {\n  const requestId = ++highlightRequestId;\n  pendingHighlightRequests.set(requestId, resolve);\n  return requestId;\n}\n\n/**\n * Resolve a highlight request\n */\nexport function resolveHighlightRequest(requestId: number, result: HighlightResponse): void {\n  const resolve = pendingHighlightRequests.get(requestId);\n  if (resolve) {\n    pendingHighlightRequests.delete(requestId);\n    resolve(result);\n  }\n}\n\n/**\n * Check if a highlight request exists\n */\nexport function hasHighlightRequest(requestId: number): boolean {\n  return pendingHighlightRequests.has(requestId);\n}\n\n/**\n * Delete a highlight request without resolving\n */\nexport function deleteHighlightRequest(requestId: number): void {\n  pendingHighlightRequests.delete(requestId);\n}\n\n/**\n * Get the next execute request ID and register a resolver\n */\nexport function registerExecuteRequest(resolve: (result: ExecuteJsResult) => void): number {\n  const requestId = ++executeRequestId;\n  pendingExecuteRequests.set(requestId, resolve);\n  return requestId;\n}\n\n/**\n * Resolve an execute request\n */\nexport function resolveExecuteRequest(requestId: number, result: ExecuteJsResult): void {\n  const resolve = pendingExecuteRequests.get(requestId);\n  if (resolve) {\n    pendingExecuteRequests.delete(requestId);\n    resolve(result);\n  }\n}\n\n/**\n * Check if an execute request exists\n */\nexport function hasExecuteRequest(requestId: number): boolean {\n  return pendingExecuteRequests.has(requestId);\n}\n\n/**\n * Delete an execute request without resolving\n */\nexport function deleteExecuteRequest(requestId: number): void {\n  pendingExecuteRequests.delete(requestId);\n}\n\n/**\n * Get the next a11y request ID and register a resolver\n */\nexport function registerA11yRequest(resolve: (result: A11yAuditResult) => void): number {\n  const requestId = ++a11yRequestId;\n  pendingA11yRequests.set(requestId, resolve);\n  return requestId;\n}\n\n/**\n * Resolve an a11y request\n */\nexport function resolveA11yRequest(requestId: number, result: A11yAuditResult): void {\n  const resolve = pendingA11yRequests.get(requestId);\n  if (resolve) {\n    pendingA11yRequests.delete(requestId);\n    resolve(result);\n  }\n}\n\n/**\n * Check if an a11y request exists\n */\nexport function hasA11yRequest(requestId: number): boolean {\n  return pendingA11yRequests.has(requestId);\n}\n\n/**\n * Delete an a11y request without resolving\n */\nexport function deleteA11yRequest(requestId: number): void {\n  pendingA11yRequests.delete(requestId);\n}\n\n/**\n * Get the next DOM request ID and register a resolver\n */\nexport function registerDomRequest(resolve: (result: DomQueryResult) => void): number {\n  const requestId = ++domRequestId;\n  pendingDomRequests.set(requestId, resolve);\n  return requestId;\n}\n\n/**\n * Resolve a DOM request\n */\nexport function resolveDomRequest(requestId: number, result: DomQueryResult): void {\n  const resolve = pendingDomRequests.get(requestId);\n  if (resolve) {\n    pendingDomRequests.delete(requestId);\n    resolve(result);\n  }\n}\n\n/**\n * Check if a DOM request exists\n */\nexport function hasDomRequest(requestId: number): boolean {\n  return pendingDomRequests.has(requestId);\n}\n\n/**\n * Delete a DOM request without resolving\n */\nexport function deleteDomRequest(requestId: number): void {\n  pendingDomRequests.delete(requestId);\n}\n\n/**\n * Initialize request tracking (register cleanup handlers)\n */\nexport function initRequestTracking(): void {\n  // Register cleanup handlers for page unload/navigation (Issue 2 fix)\n  // Using 'pagehide' (modern, fires on both close and navigation) + 'beforeunload' (legacy fallback)\n  window.addEventListener('pagehide', clearPendingRequests);\n  window.addEventListener('beforeunload', clearPendingRequests);\n}\n", "/**\n * @fileoverview Message Forwarding Module\n * Forwards messages between page context and background script\n */\n\nimport type { BackgroundMessageFromContent } from './types';\n\n// Dispatch table: page postMessage type -> background message type\nexport const MESSAGE_MAP: Record<string, string> = {\n  GASOLINE_LOG: 'log',\n  GASOLINE_WS: 'ws_event',\n  GASOLINE_NETWORK_BODY: 'network_body',\n  GASOLINE_ENHANCED_ACTION: 'enhanced_action',\n  GASOLINE_PERFORMANCE_SNAPSHOT: 'performance_snapshot',\n} as const;\n\n// Track whether the extension context is still valid\nlet contextValid = true;\n\n/**\n * Safely send a message to the background script\n * Handles extension context invalidation gracefully\n */\nexport function safeSendMessage(msg: BackgroundMessageFromContent): void {\n  if (!contextValid) return;\n  try {\n    chrome.runtime.sendMessage(msg);\n  } catch (e) {\n    if (e instanceof Error && e.message?.includes('Extension context invalidated')) {\n      contextValid = false;\n      console.warn(\n        '[Gasoline] Please refresh this page. The Gasoline extension was reloaded ' +\n          'and this page still has the old content script. A page refresh will ' +\n          'reconnect capture automatically.'\n      );\n    }\n  }\n}\n\n/**\n * Check if the extension context is still valid\n */\nexport function isContextValid(): boolean {\n  return contextValid;\n}\n", "/**\n * @fileoverview Window Message Listener Module\n * Handles window.postMessage events from inject.js\n */\n\nimport type {\n  HighlightResponse,\n  ExecuteJsResult,\n  A11yAuditResult,\n  DomQueryResult,\n} from '../types';\nimport type { PageMessageEventData, BackgroundMessageFromContent } from './types';\nimport {\n  resolveHighlightRequest,\n  resolveExecuteRequest,\n  resolveA11yRequest,\n  resolveDomRequest,\n} from './request-tracking';\nimport { MESSAGE_MAP, safeSendMessage } from './message-forwarding';\nimport { getIsTrackedTab, getCurrentTabId } from './tab-tracking';\n\n/**\n * Initialize consolidated window message listener\n * Handles all messages from inject.js\n */\nexport function initWindowMessageListener(): void {\n  window.addEventListener('message', (event: MessageEvent<PageMessageEventData>) => {\n    // Only accept messages from this window\n    if (event.source !== window) return;\n\n    const { type: messageType, requestId, result, payload } = event.data || {};\n\n    // Handle highlight responses\n    if (messageType === 'GASOLINE_HIGHLIGHT_RESPONSE') {\n      if (requestId !== undefined) {\n        resolveHighlightRequest(requestId, result as HighlightResponse);\n      }\n      return;\n    }\n\n    // Handle execute JS results\n    if (messageType === 'GASOLINE_EXECUTE_JS_RESULT') {\n      if (requestId !== undefined) {\n        resolveExecuteRequest(requestId, result as ExecuteJsResult);\n      }\n      return;\n    }\n\n    // Handle a11y audit results from inject.js\n    if (messageType === 'GASOLINE_A11Y_QUERY_RESPONSE') {\n      if (requestId !== undefined) {\n        resolveA11yRequest(requestId, result as A11yAuditResult);\n      }\n      return;\n    }\n\n    // Handle DOM query results from inject.js\n    if (messageType === 'GASOLINE_DOM_QUERY_RESPONSE') {\n      if (requestId !== undefined) {\n        resolveDomRequest(requestId, result as DomQueryResult);\n      }\n      return;\n    }\n\n    // Tab isolation filter: only forward captured data from the tracked tab.\n    // Response messages (highlight, execute JS, a11y) are NOT filtered because\n    // they are responses to explicit commands from the background script.\n    if (!getIsTrackedTab()) {\n      return; // Drop captured data from untracked tabs\n    }\n\n    // Handle MESSAGE_MAP forwarding - attach tabId to every message\n    if (messageType && messageType in MESSAGE_MAP && payload && typeof payload === 'object') {\n      const mappedType = MESSAGE_MAP[messageType];\n      if (mappedType) {\n        safeSendMessage({\n          type: mappedType,\n          payload,\n          tabId: getCurrentTabId(),\n        } as BackgroundMessageFromContent);\n      }\n    }\n  });\n}\n", "/**\n * @fileoverview Timeout Utilities for Content Script\n * Inlined utilities for promise timeout handling\n * Content scripts cannot use ES module imports, so these utilities are duplicated\n */\n\n/** Custom error for timeout operations */\nexport class TimeoutError extends Error {\n  constructor(message: string, public fallback?: unknown) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\n/** Deferred Promise interface */\nexport interface DeferredPromise<T> {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: unknown) => void;\n}\n\n/** Create a deferred promise for external resolution */\nexport function createDeferredPromise<T>(): DeferredPromise<T> {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n/** Race a promise against a timeout with cleanup on timeout */\nexport async function promiseRaceWithCleanup<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutFallback: T | undefined,\n  cleanup?: () => void\n): Promise<T> {\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((_, reject) =>\n        setTimeout(() => {\n          cleanup?.();\n          if (timeoutFallback !== undefined) {\n            reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, timeoutFallback));\n          } else {\n            reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n          }\n        }, timeoutMs)\n      ),\n    ]);\n  } catch (err) {\n    if (err instanceof TimeoutError && err.fallback !== undefined) {\n      return err.fallback as T;\n    }\n    throw err;\n  }\n}\n", "/**\n * @fileoverview Message Handlers Module\n * Handles messages from background script\n */\n\nimport type {\n  ContentMessage,\n  ContentPingResponse,\n  WebSocketCaptureMode,\n  HighlightResponse,\n  WaterfallEntry,\n  StateAction,\n  BrowserStateSnapshot,\n} from '../types';\nimport type {\n  SettingMessage,\n  HighlightRequestMessage,\n  ExecuteJsRequestMessage,\n  A11yQueryRequestMessage,\n  DomQueryRequestMessage,\n  GetWaterfallRequestMessage,\n  StateCommandMessage,\n} from './types';\nimport {\n  registerHighlightRequest,\n  hasHighlightRequest,\n  deleteHighlightRequest,\n  registerExecuteRequest,\n  registerA11yRequest,\n  registerDomRequest,\n} from './request-tracking';\nimport {\n  createDeferredPromise,\n  promiseRaceWithCleanup,\n} from './timeout-utils';\n\n// Feature toggle message types forwarded from background to inject.js\nexport const TOGGLE_MESSAGES = new Set([\n  'setNetworkWaterfallEnabled',\n  'setPerformanceMarksEnabled',\n  'setActionReplayEnabled',\n  'setWebSocketCaptureEnabled',\n  'setWebSocketCaptureMode',\n  'setPerformanceSnapshotEnabled',\n  'setDeferralEnabled',\n  'setNetworkBodyCaptureEnabled',\n  'setServerUrl',\n]);\n\n/**\n * Security: Validate sender is from the extension background script\n * Prevents content script from trusting messages from compromised page context\n */\nexport function isValidBackgroundSender(sender: chrome.runtime.MessageSender): boolean {\n  // Messages from background should NOT have a tab (or have tab with chrome-extension:// url)\n  // Messages from content scripts have tab.id\n  // We only want messages from the background service worker\n  return typeof sender.id === 'string' && sender.id === (chrome.runtime as any).id;\n}\n\n/**\n * Create a timeout handler that cleans up a pending request from a Map\n */\nfunction createRequestTimeoutCleanup<T extends { error: string }>(\n  requestId: number,\n  pendingMap: Map<number, (result: T) => void>,\n  errorResponse: T\n): () => void {\n  return () => {\n    if (pendingMap.has(requestId)) {\n      const cb = pendingMap.get(requestId);\n      pendingMap.delete(requestId);\n      if (cb) {\n        cb(errorResponse);\n      }\n    }\n  };\n}\n\n/**\n * Forward a highlight message from background to inject.js\n */\nexport function forwardHighlightMessage(message: { params: { selector: string; duration_ms?: number } }): Promise<HighlightResponse> {\n  const requestId = registerHighlightRequest((result) => deferred.resolve(result));\n  const deferred = createDeferredPromise<HighlightResponse>();\n\n  // Post message to page context (inject.js)\n  window.postMessage(\n    {\n      type: 'GASOLINE_HIGHLIGHT_REQUEST',\n      requestId,\n      params: message.params,\n    } satisfies HighlightRequestMessage,\n    window.location.origin\n  );\n\n  // Timeout fallback + cleanup stale entries after 30 seconds\n  return promiseRaceWithCleanup(\n    deferred.promise,\n    30000,\n    { success: false, error: 'timeout' },\n    () => {\n      if (hasHighlightRequest(requestId)) {\n        deleteHighlightRequest(requestId);\n      }\n    }\n  );\n}\n\n/**\n * Handle state capture/restore commands\n */\nexport async function handleStateCommand(params: {\n  action?: StateAction;\n  name?: string;\n  state?: BrowserStateSnapshot;\n  include_url?: boolean;\n} | undefined): Promise<{ error?: string; [key: string]: unknown }> {\n  const { action, name, state, include_url } = params || {};\n\n  // Create a promise to receive response from inject.js\n  const messageId = `state_${Date.now()}_${Math.random().toString(36).slice(2)}`;\n  const deferred = createDeferredPromise<{ error?: string; [key: string]: unknown }>();\n\n  // Set up listener for response from inject.js\n  const responseHandler = (event: MessageEvent<{ type?: string; messageId?: string; result?: { error?: string; [key: string]: unknown } }>) => {\n    if (event.source !== window) return;\n    if (event.data?.type === 'GASOLINE_STATE_RESPONSE' && event.data?.messageId === messageId) {\n      window.removeEventListener('message', responseHandler);\n      deferred.resolve(event.data.result || { error: 'No result from state command' });\n    }\n  };\n  window.addEventListener('message', responseHandler);\n\n  // Send command to inject.js (include state for restore action)\n  window.postMessage(\n    {\n      type: 'GASOLINE_STATE_COMMAND',\n      messageId,\n      action,\n      name,\n      state,\n      include_url,\n    } satisfies StateCommandMessage,\n    window.location.origin\n  );\n\n  // Timeout after 5 seconds with cleanup\n  return promiseRaceWithCleanup(\n    deferred.promise,\n    5000,\n    { error: 'State command timeout' },\n    () => window.removeEventListener('message', responseHandler)\n  );\n}\n\n/**\n * Handle GASOLINE_PING message\n */\nexport function handlePing(sendResponse: (response: ContentPingResponse) => void): boolean {\n  sendResponse({ status: 'alive', timestamp: Date.now() });\n  return true;\n}\n\n/**\n * Handle toggle messages\n */\nexport function handleToggleMessage(\n  message: ContentMessage & { enabled?: boolean; mode?: WebSocketCaptureMode; url?: string }\n): void {\n  if (!TOGGLE_MESSAGES.has(message.type)) return;\n\n  const payload: SettingMessage = { type: 'GASOLINE_SETTING', setting: message.type };\n  if (message.type === 'setWebSocketCaptureMode') {\n    payload.mode = message.mode;\n  } else if (message.type === 'setServerUrl') {\n    payload.url = message.url;\n  } else {\n    payload.enabled = message.enabled;\n  }\n  // SECURITY: Use explicit targetOrigin (window.location.origin) not \"*\"\n  window.postMessage(payload, window.location.origin);\n}\n\n/**\n * Handle GASOLINE_EXECUTE_JS message\n */\nexport function handleExecuteJs(\n  params: { script?: string; timeout_ms?: number },\n  sendResponse: (result: any) => void\n): boolean {\n  const requestId = registerExecuteRequest(sendResponse);\n\n  // Timeout fallback: respond with error and cleanup after 30 seconds\n  setTimeout(\n    createRequestTimeoutCleanup(\n      requestId,\n      new Map([[requestId, sendResponse]]),\n      { success: false, error: 'timeout', message: 'Execute request timed out after 30s' }\n    ),\n    30000\n  );\n\n  // Forward to inject.js via postMessage\n  window.postMessage(\n    {\n      type: 'GASOLINE_EXECUTE_JS',\n      requestId,\n      script: params.script || '',\n      timeoutMs: params.timeout_ms || 5000,\n    } satisfies ExecuteJsRequestMessage,\n    window.location.origin\n  );\n\n  return true;\n}\n\n/**\n * Handle GASOLINE_EXECUTE_QUERY message\n */\nexport function handleExecuteQuery(\n  params: string | Record<string, unknown>,\n  sendResponse: (result: any) => void\n): boolean {\n  // Parse params if it's a string (from JSON)\n  let parsedParams: { script?: string; timeout_ms?: number } = {};\n  if (typeof params === 'string') {\n    try {\n      parsedParams = JSON.parse(params);\n    } catch {\n      parsedParams = {};\n    }\n  } else if (typeof params === 'object') {\n    parsedParams = params as { script?: string; timeout_ms?: number };\n  }\n\n  return handleExecuteJs(parsedParams, sendResponse);\n}\n\n/**\n * Handle A11Y_QUERY message\n */\nexport function handleA11yQuery(\n  params: string | Record<string, unknown>,\n  sendResponse: (result: any) => void\n): boolean {\n  // Parse params if it's a string (from JSON)\n  let parsedParams: Record<string, unknown> = {};\n  if (typeof params === 'string') {\n    try {\n      parsedParams = JSON.parse(params);\n    } catch {\n      parsedParams = {};\n    }\n  } else if (typeof params === 'object') {\n    parsedParams = params;\n  }\n\n  const requestId = registerA11yRequest(sendResponse);\n\n  // Timeout fallback: respond with error and cleanup after 30 seconds\n  setTimeout(\n    createRequestTimeoutCleanup(\n      requestId,\n      new Map([[requestId, sendResponse]]),\n      { error: 'Accessibility audit timeout' }\n    ),\n    30000\n  );\n\n  // Forward to inject.js via postMessage\n  window.postMessage(\n    {\n      type: 'GASOLINE_A11Y_QUERY',\n      requestId,\n      params: parsedParams,\n    } satisfies A11yQueryRequestMessage,\n    window.location.origin\n  );\n\n  return true;\n}\n\n/**\n * Handle DOM_QUERY message\n */\nexport function handleDomQuery(\n  params: string | Record<string, unknown>,\n  sendResponse: (result: any) => void\n): boolean {\n  // Parse params if it's a string (from JSON)\n  let parsedParams: Record<string, unknown> = {};\n  if (typeof params === 'string') {\n    try {\n      parsedParams = JSON.parse(params);\n    } catch {\n      parsedParams = {};\n    }\n  } else if (typeof params === 'object') {\n    parsedParams = params;\n  }\n\n  const requestId = registerDomRequest(sendResponse);\n\n  // Timeout fallback: respond with error and cleanup after 30 seconds\n  setTimeout(\n    createRequestTimeoutCleanup(\n      requestId,\n      new Map([[requestId, sendResponse]]),\n      { error: 'DOM query timeout' }\n    ),\n    30000\n  );\n\n  // Forward to inject.js via postMessage\n  window.postMessage(\n    {\n      type: 'GASOLINE_DOM_QUERY',\n      requestId,\n      params: parsedParams,\n    } satisfies DomQueryRequestMessage,\n    window.location.origin\n  );\n\n  return true;\n}\n\n/**\n * Handle GET_NETWORK_WATERFALL message\n */\nexport function handleGetNetworkWaterfall(sendResponse: (result: { entries: WaterfallEntry[] }) => void): boolean {\n  const requestId = Date.now();\n  const deferred = createDeferredPromise<{ entries: WaterfallEntry[] }>();\n\n  // Set up a one-time listener for the response\n  const responseHandler = (event: MessageEvent<{ type?: string; entries?: WaterfallEntry[] }>) => {\n    if (event.source !== window) return;\n    if (event.data?.type === 'GASOLINE_WATERFALL_RESPONSE') {\n      window.removeEventListener('message', responseHandler);\n      deferred.resolve({ entries: event.data.entries || [] });\n    }\n  };\n\n  window.addEventListener('message', responseHandler);\n\n  // Post message to page context\n  window.postMessage(\n    {\n      type: 'GASOLINE_GET_WATERFALL',\n      requestId,\n    } satisfies GetWaterfallRequestMessage,\n    window.location.origin\n  );\n\n  // Timeout fallback: respond with empty array after 5 seconds\n  promiseRaceWithCleanup(deferred.promise, 5000, { entries: [] }, () => {\n    window.removeEventListener('message', responseHandler);\n  }).then((result) => {\n    sendResponse(result);\n  });\n\n  return true;\n}\n", "/**\n * @fileoverview Runtime Message Listener Module\n * Handles chrome.runtime messages from background script\n */\n\nimport type { ContentMessage, WebSocketCaptureMode } from '../types';\nimport {\n  isValidBackgroundSender,\n  handlePing,\n  handleToggleMessage,\n  forwardHighlightMessage,\n  handleStateCommand,\n  handleExecuteJs,\n  handleExecuteQuery,\n  handleA11yQuery,\n  handleDomQuery,\n  handleGetNetworkWaterfall,\n} from './message-handlers';\n\n/**\n * Initialize runtime message listener\n * Listens for messages from background (feature toggles and pilot commands)\n */\nexport function initRuntimeMessageListener(): void {\n  chrome.runtime.onMessage.addListener(\n    (\n      message: ContentMessage & { enabled?: boolean; mode?: WebSocketCaptureMode; url?: string; params?: unknown },\n      sender: chrome.runtime.MessageSender,\n      sendResponse: (response?: unknown) => void\n    ): boolean | undefined => {\n      // SECURITY: Validate sender is from the extension background, not from page context\n      if (!isValidBackgroundSender(sender)) {\n        console.warn('[Gasoline] Rejected message from untrusted sender:', sender.id);\n        return false;\n      }\n\n      // Handle ping to check if content script is loaded\n      if (message.type === 'GASOLINE_PING') {\n        return handlePing(sendResponse);\n      }\n\n      // Handle toggle messages\n      handleToggleMessage(message);\n\n      // Handle GASOLINE_HIGHLIGHT from background\n      if (message.type === 'GASOLINE_HIGHLIGHT') {\n        forwardHighlightMessage(message)\n          .then((result) => {\n            sendResponse(result);\n          })\n          .catch((err: Error) => {\n            sendResponse({ success: false, error: err.message });\n          });\n        return true; // Will respond asynchronously\n      }\n\n      // Handle state management commands from background\n      if (message.type === 'GASOLINE_MANAGE_STATE') {\n        handleStateCommand(message.params as any)\n          .then((result) => sendResponse(result))\n          .catch((err: Error) => sendResponse({ error: err.message }));\n        return true; // Keep channel open for async response\n      }\n\n      // Handle GASOLINE_EXECUTE_JS from background (direct pilot command)\n      if (message.type === 'GASOLINE_EXECUTE_JS') {\n        const params = (message.params as { script?: string; timeout_ms?: number }) || {};\n        return handleExecuteJs(params, sendResponse);\n      }\n\n      // Handle GASOLINE_EXECUTE_QUERY from background (polling system)\n      if (message.type === 'GASOLINE_EXECUTE_QUERY') {\n        return handleExecuteQuery(message.params || {}, sendResponse);\n      }\n\n      // Handle A11Y_QUERY from background (run accessibility audit in page context)\n      if (message.type === 'A11Y_QUERY') {\n        return handleA11yQuery(message.params || {}, sendResponse);\n      }\n\n      // Handle DOM_QUERY from background (execute CSS selector query in page context)\n      if (message.type === 'DOM_QUERY') {\n        return handleDomQuery(message.params || {}, sendResponse);\n      }\n\n      // Handle GET_NETWORK_WATERFALL from background (collect PerformanceResourceTiming data)\n      if (message.type === 'GET_NETWORK_WATERFALL') {\n        return handleGetNetworkWaterfall(sendResponse);\n      }\n\n      return undefined;\n    }\n  );\n}\n", "/**\n * @fileoverview Favicon Replacer - Visual indicator for tracked tabs\n * Replaces the page's favicon with the Gasoline flame icon when tab tracking is enabled.\n * Adds flickering animation when AI Pilot is active.\n */\n\nimport type { TrackingState } from '../types';\n\n/**\n * Current tracking state for this tab\n */\nlet currentState: TrackingState = {\n  isTracked: false,\n  aiPilotEnabled: false,\n};\n\n/**\n * Original favicon href (to restore when tracking stops)\n */\nlet originalFaviconHref: string | null = null;\n\n/**\n * Interval ID for flicker effect (uses setInterval, not requestAnimationFrame)\n * This ensures animation continues even when tab is hidden (visible in tab bar)\n */\nlet flickerInterval: number | null = null;\n\n/**\n * Initialize favicon replacement.\n * Listens for tracking state changes and updates favicon accordingly.\n */\nexport function initFaviconReplacer(): void {\n  // Listen for tracking state updates from background\n  chrome.runtime.onMessage.addListener((message, _sender, _sendResponse) => {\n    if (message.type === 'trackingStateChanged') {\n      const newState: TrackingState = message.state;\n      updateFavicon(newState);\n    }\n  });\n\n  // Request initial tracking state\n  chrome.runtime.sendMessage({ type: 'getTrackingState' }, (response: { state?: TrackingState }) => {\n    if (response && response.state) {\n      updateFavicon(response.state);\n    }\n  });\n}\n\n/**\n * Update favicon based on tracking state.\n * - Not tracked: Shows original favicon\n * - Tracked (AI Pilot off): Shows static glowing flame\n * - Tracked (AI Pilot on): Shows flickering flame\n */\nfunction updateFavicon(state: TrackingState): void {\n  currentState = state;\n\n  if (!state.isTracked) {\n    // Restore original favicon\n    restoreOriginalFavicon();\n    stopFlicker();\n  } else if (state.aiPilotEnabled) {\n    // Tracked + AI Pilot on = flickering flame\n    replaceFaviconWithFlame(true);\n    startFlicker();\n  } else {\n    // Tracked only = static glowing flame\n    replaceFaviconWithFlame(false);\n    stopFlicker();\n  }\n}\n\n/**\n * Save original favicon and replace with Gasoline flame.\n */\nfunction replaceFaviconWithFlame(withGlow: boolean): void {\n  // Save original favicon (only once)\n  if (!originalFaviconHref) {\n    const existingLink = document.querySelector('link[rel*=\"icon\"]') as HTMLLinkElement | null;\n    originalFaviconHref = existingLink?.href || '';\n  }\n\n  // Remove existing favicons\n  const existingIcons = document.querySelectorAll('link[rel*=\"icon\"]');\n  existingIcons.forEach((icon) => icon.remove());\n\n  // Add Gasoline flame favicon\n  const link = document.createElement('link');\n  link.rel = 'icon';\n  link.type = 'image/svg+xml';\n  link.id = 'gasoline-favicon';\n\n  // Use glow icon if tracking, regular icon if not\n  const iconPath = withGlow ? 'icons/icon-glow.svg' : 'icons/icon.svg';\n  link.href = chrome.runtime.getURL(iconPath);\n\n  document.head.appendChild(link);\n}\n\n/**\n * Restore the original page favicon.\n */\nfunction restoreOriginalFavicon(): void {\n  // Remove Gasoline favicon\n  const gasolineIcon = document.getElementById('gasoline-favicon');\n  if (gasolineIcon) {\n    gasolineIcon.remove();\n  }\n\n  // Restore original\n  if (originalFaviconHref) {\n    const link = document.createElement('link');\n    link.rel = 'icon';\n    link.href = originalFaviconHref;\n    document.head.appendChild(link);\n  }\n}\n\n/**\n * Start flicker animation (for AI Pilot active state).\n * Realistic 8-frame flame animation:\n * - Bottom stays anchored (flames grow UPWARD, not scaled from center)\n * - Smaller flames = more orange/red (cooler, 85-92% height) + smaller darker ring\n * - Normal flame = orange-yellow gradient (100% height) + medium orange ring\n * - Larger flames = more yellow/white (hotter, 105-112% height) + larger brighter ring\n * - 150ms per frame = 1.2s full cycle (fast, visible flicker)\n * - Uses setInterval (not requestAnimationFrame) so it's visible in tab bar when tab is hidden\n */\nfunction startFlicker(): void {\n  if (flickerInterval !== null) {\n    return; // Already flickering\n  }\n\n  // 8-frame sequence for smooth breathing effect with color temperature shift\n  const flameFrames = [\n    'icon-flicker-1-tiny.svg',     // 85% - dark red/orange (coolest) + small dark ring\n    'icon-flicker-2-small.svg',    // 92% - orange + small orange ring\n    'icon-flicker-3-normal.svg',   // 100% - orange-yellow (base) + medium orange ring\n    'icon-flicker-4-medium.svg',   // 105% - yellow + medium yellow ring\n    'icon-flicker-5-large.svg',    // 112% - yellow/white (PEAK - hottest) + large bright ring\n    'icon-flicker-6-medium.svg',   // 105% - yellow + medium yellow ring (shrinking)\n    'icon-flicker-7-smallmed.svg', // 96% - orange-yellow + medium ring\n    'icon-flicker-8-small.svg',    // 92% - orange + small orange ring (back to small)\n  ] as const;\n\n  let currentFrameIndex = 0;\n\n  // Use setInterval instead of requestAnimationFrame so animation continues\n  // even when tab is hidden (user can see flicker in browser tab bar)\n  flickerInterval = window.setInterval(() => {\n    currentFrameIndex = (currentFrameIndex + 1) % flameFrames.length;\n\n    // Update favicon\n    const gasolineIcon = document.getElementById('gasoline-favicon') as HTMLLinkElement | null;\n    if (gasolineIcon) {\n      const iconPath = `icons/${flameFrames[currentFrameIndex]}`;\n      gasolineIcon.href = chrome.runtime.getURL(iconPath);\n    }\n  }, 150); // 150ms per frame = 1.2s full cycle (browser-limited, but visible)\n}\n\n/**\n * Stop flicker animation.\n */\nfunction stopFlicker(): void {\n  if (flickerInterval !== null) {\n    clearInterval(flickerInterval);\n    flickerInterval = null;\n  }\n}\n", "/**\n * @fileoverview content.ts - Message bridge between page and extension contexts.\n * Injects inject.js into the page as a module script, then listens for\n * window.postMessage events (GASOLINE_LOG, GASOLINE_WS, GASOLINE_NETWORK_BODY,\n * GASOLINE_ENHANCED_ACTION, GASOLINE_PERF_SNAPSHOT) and forwards them to the\n * background service worker via chrome.runtime.sendMessage.\n * Also handles chrome.runtime messages for on-demand queries (DOM, a11y, perf).\n * Design: Tab-scoped filtering - only forwards messages from the explicitly\n * tracked tab. Validates message origin (event.source === window) to prevent\n * cross-frame injection. Attaches tabId to all forwarded messages.\n */\n\nimport { initTabTracking, getIsTrackedTab } from './content/tab-tracking';\nimport { initScriptInjection } from './content/script-injection';\nimport { initRequestTracking, getPendingRequestStats, clearPendingRequests } from './content/request-tracking';\nimport { initWindowMessageListener } from './content/window-message-listener';\nimport { initRuntimeMessageListener } from './content/runtime-message-listener';\nimport { initFaviconReplacer } from './content/favicon-replacer';\n\n// Export for testing\nexport { getPendingRequestStats, clearPendingRequests };\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\n\n// Track whether scripts have been injected\nlet scriptsInjected = false;\n\n// Initialize tab tracking first\ninitTabTracking();\n\n// Initialize request tracking (cleanup handlers)\ninitRequestTracking();\n\n// Initialize window message listener\ninitWindowMessageListener();\n\n// Initialize runtime message listener\ninitRuntimeMessageListener();\n\n// Initialize favicon replacer (visual indicator for tracked tabs)\ninitFaviconReplacer();\n\n// Listen for tracking status changes and inject scripts only when tracked\nchrome.storage.onChanged.addListener((changes) => {\n  if (changes.trackedTabId) {\n    // Check if this tab is now tracked\n    if (getIsTrackedTab() && !scriptsInjected) {\n      // Tab just became tracked - inject scripts\n      initScriptInjection();\n      scriptsInjected = true;\n    }\n    // Note: We don't remove scripts when tab becomes untracked\n    // because that could break the page. Just stop injecting on new tracked tabs.\n  }\n});\n\n// Check initial tracking status and inject if already tracked\n// Use setTimeout to ensure initTabTracking() has completed its async work\nsetTimeout(() => {\n  if (getIsTrackedTab() && !scriptsInjected) {\n    initScriptInjection();\n    scriptsInjected = true;\n  }\n}, 100);\n"],
  "mappings": "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",
  "names": []
}
