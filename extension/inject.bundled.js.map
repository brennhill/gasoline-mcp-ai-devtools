{
  "version": 3,
  "sources": ["../src/lib/timeouts.ts", "../src/lib/constants.ts", "../src/lib/serialize.ts", "../src/lib/context.ts", "../src/lib/reproduction.ts", "../src/lib/actions.ts", "../src/lib/network.ts", "../src/lib/perf-snapshot.ts", "../src/lib/performance.ts", "../src/lib/bridge.ts", "../src/lib/console.ts", "../src/lib/ai-context.ts", "../src/lib/exceptions.ts", "../src/lib/websocket.ts", "../src/lib/dom-queries.ts", "../src/inject/api.ts", "../src/inject/observers.ts", "../src/lib/timeout-utils.ts", "../src/lib/link-health.ts", "../src/inject/message-handlers.ts", "../src/inject/state.ts", "../src/inject/index.ts"],
  "sourcesContent": ["/**\n * @fileoverview Timeout scaling helpers for fast tests.\n */\n\ndeclare const process: { env: Record<string, string | undefined> } | undefined\nfunction readTestScale(): number {\n  const globalScale =\n    typeof globalThis !== 'undefined' && typeof (globalThis as { GASOLINE_TEST_TIMEOUT_SCALE?: number }).GASOLINE_TEST_TIMEOUT_SCALE === 'number'\n      ? (globalThis as unknown as { GASOLINE_TEST_TIMEOUT_SCALE: number }).GASOLINE_TEST_TIMEOUT_SCALE\n      : null\n  if (globalScale !== null) return globalScale\n  if (typeof process !== 'undefined' && process.env) {\n    const raw = process.env.GASOLINE_TEST_TIMEOUT_SCALE || process.env.GASOLINE_TEST_TIME_SCALE\n    if (raw) {\n      const parsed = Number(raw)\n      if (Number.isFinite(parsed)) return parsed\n    }\n  }\n  return 1\n}\n\nexport function scaleTimeout(ms: number): number {\n  const scale = readTestScale()\n  if (!Number.isFinite(scale) || scale <= 0 || scale === 1) {\n    return ms\n  }\n  return Math.max(5, Math.round(ms * scale))\n}\n", "/**\n * @fileoverview Shared constants for the Gasoline extension capture modules.\n */\nimport { scaleTimeout } from './timeouts'\n\n// Serialization limits\nexport const MAX_STRING_LENGTH = 10240 // 10KB\nexport const MAX_RESPONSE_LENGTH = 5120 // 5KB\nexport const MAX_DEPTH = 10\nexport const MAX_CONTEXT_SIZE = 50 // Max number of context keys\nexport const MAX_CONTEXT_VALUE_SIZE = 4096 // Max size of serialized context value\nexport const SENSITIVE_HEADERS: readonly string[] = [\n  'authorization',\n  'cookie',\n  'set-cookie',\n  'x-auth-token',\n  'x-api-key',\n  'x-csrf-token',\n  'proxy-authorization'\n]\n\n// User action replay settings\nexport const MAX_ACTION_BUFFER_SIZE = 20 // Max number of recent actions to keep\nexport const SCROLL_THROTTLE_MS = 250 // Throttle scroll events\nexport const SENSITIVE_INPUT_TYPES: readonly string[] = ['password', 'credit-card', 'cc-number', 'cc-exp', 'cc-csc']\n\n// Network Waterfall settings\nexport const MAX_WATERFALL_ENTRIES = 50 // Max network entries to capture\nexport const WATERFALL_TIME_WINDOW_MS = 30000 // Only capture last 30 seconds\n\n// Performance Marks settings\nexport const MAX_PERFORMANCE_ENTRIES = 50 // Max performance entries to capture\nexport const PERFORMANCE_TIME_WINDOW_MS = 60000 // Only capture last 60 seconds\n\n// WebSocket capture settings\nexport const WS_MAX_BODY_SIZE = 4096 // 4KB truncation limit\nexport const WS_PREVIEW_LIMIT = 200 // Preview character limit\n\n// Network body capture settings\nexport const REQUEST_BODY_MAX = 8192 // 8KB\nexport const RESPONSE_BODY_MAX = 16384 // 16KB\n// Intentionally aggressive (5ms) to avoid blocking the main thread during fetch body reads.\n// Network body capture uses this as a race timeout - if the body isn't available nearly\n// instantly, we skip it rather than degrade page performance.\nexport const BODY_READ_TIMEOUT_MS = 5\nexport const SENSITIVE_HEADER_PATTERNS =\n  /^(authorization|cookie|set-cookie|x-api-key|x-auth-token|x-secret|x-password|.*token.*|.*secret.*|.*key.*|.*password.*)$/i\nexport const BINARY_CONTENT_TYPES = /^(image|video|audio|font)\\/|^application\\/(wasm|octet-stream|zip|gzip|pdf)/\n\n// DOM query settings\nexport const DOM_QUERY_MAX_ELEMENTS = 50\nexport const DOM_QUERY_MAX_TEXT = 500\nexport const DOM_QUERY_MAX_DEPTH = 5\nexport const DOM_QUERY_MAX_HTML = 200\nexport const A11Y_MAX_NODES_PER_VIOLATION = 10\nexport const ASYNC_COMMAND_TIMEOUT_MS = scaleTimeout(60000)\nexport const A11Y_AUDIT_TIMEOUT_MS = ASYNC_COMMAND_TIMEOUT_MS\n\n// Memory pressure settings\nexport const MEMORY_SOFT_LIMIT_MB = 20\nexport const MEMORY_HARD_LIMIT_MB = 50\n\n// AI Context settings\nexport const AI_CONTEXT_SNIPPET_LINES = 5 // Lines before and after error\nexport const AI_CONTEXT_MAX_LINE_LENGTH = 200 // Truncate lines\nexport const AI_CONTEXT_MAX_SNIPPETS_SIZE = 10240 // 10KB total snippets\nexport const AI_CONTEXT_MAX_ANCESTRY_DEPTH = 10\nexport const AI_CONTEXT_MAX_PROP_KEYS = 20\nexport const AI_CONTEXT_MAX_STATE_KEYS = 10\nexport const AI_CONTEXT_MAX_RELEVANT_SLICE = 10\nexport const AI_CONTEXT_MAX_VALUE_LENGTH = 200\nexport const AI_CONTEXT_SOURCE_MAP_CACHE_SIZE = 20\nexport const AI_CONTEXT_PIPELINE_TIMEOUT_MS = scaleTimeout(3000)\n\n// Reproduction script settings\nexport const ENHANCED_ACTION_BUFFER_SIZE = 50\nexport const CSS_PATH_MAX_DEPTH = 5\nexport const SELECTOR_TEXT_MAX_LENGTH = 50\nexport const SCRIPT_MAX_SIZE = 51200 // 50KB\nexport const CLICKABLE_TAGS: ReadonlySet<string> = new Set(['BUTTON', 'A', 'SUMMARY'])\n\n// Actionable keys for recording\nexport const ACTIONABLE_KEYS: ReadonlySet<string> = new Set([\n  'Enter',\n  'Escape',\n  'Tab',\n  'ArrowUp',\n  'ArrowDown',\n  'ArrowLeft',\n  'ArrowRight',\n  'Backspace',\n  'Delete'\n])\n\n// Performance snapshot settings\nexport const MAX_LONG_TASKS = 50\nexport const MAX_SLOWEST_REQUESTS = 3\nexport const MAX_URL_LENGTH = 80\n", "/**\n * @fileoverview Serialization utilities for safe value handling.\n * Provides safe serialization with circular reference detection, DOM element\n * selector generation, and sensitive input detection.\n *\n * NOTE: This module has NO mutable state. All functions are pure and stateless.\n * No resetForTesting() function is needed.\n */\n\nimport { MAX_STRING_LENGTH, MAX_DEPTH, SENSITIVE_INPUT_TYPES } from './constants.js'\nimport type { JsonValue } from '../types/index'\n\n// Extended input element interface for type checking\ninterface InputLikeElement extends Element {\n  type?: string\n  autocomplete?: string\n  name?: string\n  value?: string\n}\n\n// DOM element with extended properties\ninterface DOMElementLike {\n  nodeType?: number\n  tagName?: string\n  id?: string\n  className?: string | SVGAnimatedString\n  getAttribute?(name: string): string | null\n  textContent?: string | null\n}\n\nfunction serializePrimitive(value: unknown, type: string): JsonValue | undefined {\n  if (type === 'string') {\n    const s = value as string\n    return s.length > MAX_STRING_LENGTH ? s.slice(0, MAX_STRING_LENGTH) + '... [truncated]' : s\n  }\n  if (type === 'number') return value as number\n  if (type === 'boolean') return value as boolean\n  if (type === 'function') return `[Function: ${(value as { name?: string }).name || 'anonymous'}]` // nosemgrep: missing-template-string-indicator\n  return undefined\n}\n\nfunction serializeDOMNode(value: DOMElementLike): string {\n  const tag = value.tagName ? value.tagName.toLowerCase() : 'node'\n  const id = value.id ? `#${value.id}` : ''\n  const cn = value.className\n  const className = typeof cn === 'string' && cn ? `.${cn.split(' ').join('.')}` : ''\n  return `[${tag}${id}${className}]`\n}\n\nfunction serializeObject(value: object, depth: number, seen: WeakSet<object>): JsonValue {\n  if (seen.has(value)) return '[Circular]'\n  seen.add(value)\n\n  if ((value as DOMElementLike).nodeType) return serializeDOMNode(value as DOMElementLike)\n  if (Array.isArray(value)) return value.slice(0, 100).map((item) => safeSerialize(item, depth + 1, seen))\n\n  const result: Record<string, JsonValue> = {}\n  for (const key of Object.keys(value).slice(0, 50)) {\n    try {\n      result[key] = safeSerialize((value as Record<string, unknown>)[key], depth + 1, seen)\n    } catch {\n      result[key] = '[Unserializable]'\n    }\n  }\n  return result\n}\n\n/**\n * Safely serialize a value, handling circular references and special types\n */\nexport function safeSerialize(value: unknown, depth = 0, seen = new WeakSet<object>()): JsonValue {\n  if (value === null || value === undefined) return null\n\n  const type = typeof value\n  const primitive = serializePrimitive(value, type)\n  if (primitive !== undefined) return primitive\n\n  if (value instanceof Error) {\n    return { name: value.name, message: value.message, stack: value.stack || null }\n  }\n  if (depth >= MAX_DEPTH) return '[Max depth exceeded]'\n  if (type === 'object') return serializeObject(value as object, depth, seen)\n\n  return String(value)\n}\n\n/**\n * Get element selector for identification\n */\nexport function getElementSelector(element: Element | null): string {\n  if (!element || !element.tagName) return ''\n\n  const tag = element.tagName.toLowerCase()\n  const id = element.id ? `#${element.id}` : ''\n\n  let classes = ''\n  const classNameValue = element.className\n  if (classNameValue && typeof classNameValue === 'string') {\n    classes = '.' + classNameValue.trim().split(/\\s+/).slice(0, 2).join('.')\n  }\n\n  // Add data-testid if present\n  const testId = element.getAttribute('data-testid')\n  const testIdStr = testId ? `[data-testid=\"${testId}\"]` : ''\n\n  return `${tag}${id}${classes}${testIdStr}`.slice(0, 100)\n}\n\n/**\n * Check if an input contains sensitive data\n */\nconst SENSITIVE_AUTOCOMPLETE_PATTERNS = ['password', 'cc-', 'credit-card']\nconst SENSITIVE_NAME_PATTERNS = ['password', 'passwd', 'secret', 'token', 'credit', 'card', 'cvv', 'cvc', 'ssn']\n\nfunction matchesAny(value: string, patterns: string[]): boolean {\n  return patterns.some((p) => value.includes(p))\n}\n\nexport function isSensitiveInput(element: Element | null): boolean {\n  if (!element) return false\n\n  const inputElement = element as InputLikeElement\n  const type = (inputElement.type || '').toLowerCase()\n  const autocomplete = (inputElement.autocomplete || '').toLowerCase()\n  const name = (inputElement.name || '').toLowerCase()\n\n  return (\n    SENSITIVE_INPUT_TYPES.includes(type) ||\n    matchesAny(autocomplete, SENSITIVE_AUTOCOMPLETE_PATTERNS) ||\n    matchesAny(name, SENSITIVE_NAME_PATTERNS)\n  )\n}\n", "/**\n * @fileoverview Context annotations storage and management.\n * Provides key-value annotations that attach to captured events for\n * richer debugging context (e.g., user flow, feature flag, session info).\n */\n\nimport { MAX_CONTEXT_SIZE, MAX_CONTEXT_VALUE_SIZE } from './constants.js'\nimport { safeSerialize } from './serialize.js'\nimport type { JsonValue } from '../types/index'\n\n// Context annotations storage\nconst contextAnnotations: Map<string, JsonValue> = new Map()\n\n/**\n * Get current context annotations as an object\n */\nexport function getContextAnnotations(): Record<string, JsonValue> | null {\n  if (contextAnnotations.size === 0) return null\n\n  const result: Record<string, JsonValue> = {}\n  for (const [key, value] of contextAnnotations) {\n    result[key] = value\n  }\n  return result\n}\n\n/**\n * Set a context annotation\n */\nexport function setContextAnnotation(key: string, value: unknown): boolean {\n  if (typeof key !== 'string' || key.length === 0) {\n    console.warn('[Gasoline] annotate() requires a non-empty string key')\n    return false\n  }\n\n  if (key.length > 100) {\n    console.warn('[Gasoline] annotate() key must be 100 characters or less')\n    return false\n  }\n\n  // Enforce max context keys\n  if (!contextAnnotations.has(key) && contextAnnotations.size >= MAX_CONTEXT_SIZE) {\n    console.warn(`[Gasoline] Maximum context annotations (${MAX_CONTEXT_SIZE}) reached`)\n    return false\n  }\n\n  // Serialize and check size\n  const serialized = safeSerialize(value)\n  const serializedStr = JSON.stringify(serialized)\n\n  if (serializedStr.length > MAX_CONTEXT_VALUE_SIZE) {\n    console.warn(`[Gasoline] Context value for \"${key}\" exceeds max size, truncating`)\n    contextAnnotations.set(key, '[Value too large]')\n    return false\n  }\n\n  contextAnnotations.set(key, serialized)\n  return true\n}\n\n/**\n * Remove a context annotation\n */\nexport function removeContextAnnotation(key: string): boolean {\n  return contextAnnotations.delete(key)\n}\n\n/**\n * Clear all context annotations\n */\nexport function clearContextAnnotations(): void {\n  contextAnnotations.clear()\n}\n", "/**\n * @fileoverview Reproduction script generation and enhanced action recording.\n * Captures user interactions with multi-strategy selectors (testId, role, aria,\n * text, CSS path) and generates Playwright test scripts for reproducing issues.\n */\n\nimport {\n  ENHANCED_ACTION_BUFFER_SIZE,\n  CSS_PATH_MAX_DEPTH,\n  SELECTOR_TEXT_MAX_LENGTH,\n  SCRIPT_MAX_SIZE,\n  CLICKABLE_TAGS\n} from './constants.js'\nimport { isSensitiveInput } from './serialize.js'\n\n// Action types\ntype EnhancedActionType = 'click' | 'input' | 'keypress' | 'navigate' | 'select' | 'scroll'\n\n// Role selector info\ninterface RoleSelector {\n  role: string\n  name?: string\n}\n\n// Selector strategies\ninterface SelectorStrategies {\n  testId?: string\n  ariaLabel?: string\n  role?: RoleSelector\n  id?: string\n  text?: string\n  cssPath: string\n}\n\n// Enhanced action record\ninterface EnhancedActionRecord {\n  type: EnhancedActionType\n  timestamp: number\n  url: string\n  selectors?: SelectorStrategies\n  input_type?: string\n  value?: string\n  key?: string\n  from_url?: string\n  to_url?: string\n  selected_value?: string\n  selected_text?: string\n  scroll_y?: number\n}\n\n// Script generation options\ninterface ScriptOptions {\n  errorMessage?: string\n  baseUrl?: string\n  lastNActions?: number\n}\n\n// Element with extended properties for type checking\ntype ElementWithProperties = Element & {\n  innerText?: string\n  type?: string\n}\n\n// Enhanced action buffer (separate from v3 action buffer)\nlet enhancedActionBuffer: EnhancedActionRecord[] = []\n\n/**\n * Get the implicit ARIA role for an element\n */\nconst TAG_TO_ROLE: Record<string, string> = {\n  button: 'button',\n  textarea: 'textbox',\n  select: 'combobox',\n  nav: 'navigation',\n  main: 'main',\n  header: 'banner',\n  footer: 'contentinfo'\n}\n\nconst INPUT_TYPE_TO_ROLE: Record<string, string> = {\n  text: 'textbox',\n  email: 'textbox',\n  password: 'textbox',\n  tel: 'textbox',\n  url: 'textbox',\n  checkbox: 'checkbox',\n  radio: 'radio',\n  search: 'searchbox',\n  number: 'spinbutton',\n  range: 'slider'\n}\n\nexport function getImplicitRole(element: Element | null): string | null {\n  if (!element || !element.tagName) return null\n\n  const tag = element.tagName.toLowerCase()\n  const el = element as ElementWithProperties\n\n  if (tag === 'a') {\n    return el.getAttribute && el.getAttribute('href') !== null ? 'link' : null\n  }\n\n  if (tag === 'input') {\n    const type = el.getAttribute ? el.getAttribute('type') : null\n    return INPUT_TYPE_TO_ROLE[type || 'text'] ?? 'textbox'\n  }\n\n  return TAG_TO_ROLE[tag] ?? null\n}\n\n/**\n * Detect if a CSS class name is dynamically generated (CSS-in-JS)\n */\nexport function isDynamicClass(className: string | null): boolean {\n  if (!className) return false\n  // Known CSS-in-JS prefixes\n  if (/^(css|sc|emotion|styled|chakra)-/.test(className)) return true\n  // Random hash classes: 5-8 lowercase-only chars\n  if (/^[a-z]{5,8}$/.test(className)) return true\n  return false\n}\n\n/**\n * Compute a CSS path for an element\n */\nexport function computeCssPath(element: Element | null): string {\n  if (!element) return ''\n\n  const parts: string[] = []\n  let current: Element | null = element\n\n  while (current && parts.length < CSS_PATH_MAX_DEPTH) {\n    let selector = current.tagName ? current.tagName.toLowerCase() : ''\n\n    // Stop at element with ID\n    if (current.id) {\n      selector = `#${current.id}`\n      parts.unshift(selector)\n      break\n    }\n\n    // Add non-dynamic classes (max 2)\n    const classNameValue = current.className\n    const classList: string[] =\n      classNameValue && typeof classNameValue === 'string'\n        ? classNameValue\n            .trim()\n            .split(/\\s+/)\n            .filter((c) => c && !isDynamicClass(c))\n        : []\n    if (classList.length > 0) {\n      selector += '.' + classList.slice(0, 2).join('.')\n    }\n\n    parts.unshift(selector)\n    current = current.parentElement\n  }\n\n  return parts.join(' > ')\n}\n\n/**\n * Compute multi-strategy selectors for an element\n */\n// #lizard forgives\nexport function computeSelectors(element: Element | null): SelectorStrategies {\n  if (!element) return { cssPath: '' }\n\n  const selectors: Partial<SelectorStrategies> = {}\n  const el = element as ElementWithProperties\n\n  // MULTI-STRATEGY SELECTOR FALLBACK ORDER & RATIONALE:\n  //\n  // Playwright test generation requires reliable selectors to reproduce user interactions.\n  // This function implements a priority-based fallback strategy to handle diverse DOM\n  // patterns. Each selector type has different reliability characteristics:\n  //\n  // PRIORITY 1: TEST ID (data-testid, data-test-id, data-cy)\n  //   Why first: Explicitly designed for testing, guaranteed unique, stable across refactors.\n  //   Reliability: Highest. Used by developers as test hooks. Never changes in production.\n  //   Fallback trigger: Element has no test attribute.\n  //\n  // PRIORITY 2: ARIA LABEL (aria-label)\n  //   Why second: Accessibility-first, explicitly describes element, human-readable.\n  //   Reliability: High. Well-maintained in modern apps. Semantic meaning stable.\n  //   Fallback trigger: Element has no aria-label or it's empty.\n  //   Edge case: Ignored if empty or whitespace-only.\n  //\n  // PRIORITY 3: ROLE + ACCESSIBLE NAME (role + implicit/explicit name)\n  //   Why third: Combines semantic role (button, link, textbox) with accessible name\n  //   (either aria-label or text content). Playwright's getByRole() is powerful for\n  //   interactive elements but requires a name to disambiguate siblings.\n  //   Reliability: Medium-high. Role is stable; text content can change in i18n apps.\n  //   Edge cases:\n  //     - Elements without roles (divs, spans) fall through\n  //     - Multiple elements with same role+name require additional strategies\n  //   Optimization: Only considers implicit roles from HTML semantics or explicit @role\n  //\n  // PRIORITY 4: ID (element.id)\n  //   Why fourth: Simple, unique within page, but often dynamically generated or missing.\n  //   Reliability: Medium. Some frameworks auto-generate IDs; some don't use IDs at all.\n  //   Risk: If ID is dynamic (e.g., \"mui-123\"), test becomes fragile.\n  //   Advantage: Playwright's locator('#id') is efficient (native DOM API).\n  //\n  // PRIORITY 5: TEXT CONTENT (innerText/textContent for clickables)\n  //   Why fifth: Accessible fallback for buttons, links, list items. Users click text.\n  //   Reliability: Low-medium. Changes with UX copy; vulnerable to localization.\n  //   Constraint: Only used for elements in CLICKABLE_TAGS (button, a, li, etc.)\n  //   or elements with explicit role=\"button\". Prevents false matches on labels, headers.\n  //   Truncation: Limited to SELECTOR_TEXT_MAX_LENGTH (128 chars) to avoid long predicates.\n  //\n  // PRIORITY 6: CSS PATH (always computed as fallback)\n  //   Why last: Brittle but guaranteed to exist. DOM tree structure often changes during\n  //   refactoring or with dynamic content. Used only when all else fails.\n  //   Computation: Via computeCssPath() which builds CSS selectors up the tree, filtering\n  //   dynamic classes and stopping at elements with IDs.\n  //   Risk: Highly sensitive to DOM changes. Test breaks if any parent node is removed.\n  //\n  // EDGE CASES HANDLED:\n  //   - No attributes: Falls through to CSS path (always safe).\n  //   - Dynamic classes (css-*, sc-*, emotion-*): Filtered by isDynamicClass().\n  //   - iframes: CSS path may not work cross-frame; role/text often more reliable.\n  //   - Shadow DOM: Element attributes visible but CSS path doesn't cross boundaries.\n  //   - Hidden elements: All strategies still apply (Playwright can interact with hidden).\n  //   - Dynamically created elements: All text/ID strategies remain valid; CSS path may shift.\n\n  // Priority 1: Test ID\n  const testId =\n    (el.getAttribute &&\n      (el.getAttribute('data-testid') || el.getAttribute('data-test-id') || el.getAttribute('data-cy'))) ||\n    undefined\n  if (testId) selectors.testId = testId\n\n  // Priority 2: ARIA label\n  const ariaLabel = el.getAttribute && el.getAttribute('aria-label')\n  if (ariaLabel) selectors.ariaLabel = ariaLabel\n\n  // Priority 3: Role + accessible name\n  const explicitRole = el.getAttribute && el.getAttribute('role')\n  const role = explicitRole || getImplicitRole(element)\n  const name = ariaLabel || (el.textContent && el.textContent.trim().slice(0, SELECTOR_TEXT_MAX_LENGTH))\n  if (role && name) {\n    selectors.role = { role, name: ariaLabel || name }\n  }\n\n  // Priority 4: ID\n  if (element.id) selectors.id = element.id\n\n  // Priority 5: Text content (for clickable elements or role=\"button\")\n  const isClickable =\n    (element.tagName && CLICKABLE_TAGS.has(element.tagName.toUpperCase())) ||\n    (el.getAttribute && el.getAttribute('role') === 'button')\n  if (isClickable) {\n    const text = (el.textContent || el.innerText || '').trim()\n    if (text) selectors.text = text.slice(0, SELECTOR_TEXT_MAX_LENGTH)\n  }\n\n  // Priority 6: CSS path (always computed as fallback)\n  selectors.cssPath = computeCssPath(element)\n\n  return selectors as SelectorStrategies\n}\n\n// Options for recording enhanced actions\ninterface RecordActionOptions {\n  value?: string\n  key?: string\n  from_url?: string\n  to_url?: string\n  selected_value?: string\n  selected_text?: string\n  scroll_y?: number\n}\n\n// PostMessage payload type\ninterface GasolineEnhancedActionMessage {\n  type: 'GASOLINE_ENHANCED_ACTION'\n  payload: EnhancedActionRecord\n}\n\ntype ActionDataEnricher = (action: EnhancedActionRecord, element: Element | null, opts: RecordActionOptions) => void\n\nconst ACTION_DATA_ENRICHERS: Record<string, ActionDataEnricher> = {\n  input: (a, el, o) => {\n    const typedEl = el as ElementWithProperties | null\n    const inputType = typedEl && typedEl.getAttribute ? typedEl.getAttribute('type') : 'text'\n    a.input_type = inputType || 'text'\n    a.value = inputType === 'password' || (el && isSensitiveInput(el)) ? '[redacted]' : o.value || ''\n  },\n  keypress: (a, _el, o) => {\n    a.key = o.key || ''\n  },\n  navigate: (a, _el, o) => {\n    a.from_url = o.from_url || ''\n    a.to_url = o.to_url || ''\n  },\n  select: (a, _el, o) => {\n    a.selected_value = o.selected_value || ''\n    a.selected_text = o.selected_text || ''\n  },\n  scroll: (a, _el, o) => {\n    a.scroll_y = o.scroll_y || 0\n  }\n}\n\n/**\n * Record an enhanced action with multi-strategy selectors\n */\nexport function recordEnhancedAction(\n  type: EnhancedActionType,\n  element: Element | null,\n  opts: RecordActionOptions = {}\n): EnhancedActionRecord {\n  const action: EnhancedActionRecord = {\n    type,\n    timestamp: Date.now(),\n    url: typeof window !== 'undefined' && window.location ? window.location.href : ''\n  }\n\n  if (element) {\n    action.selectors = computeSelectors(element)\n  }\n\n  const enricher = ACTION_DATA_ENRICHERS[type]\n  if (enricher) enricher(action, element, opts)\n\n  // Add to buffer\n  enhancedActionBuffer.push(action)\n  if (enhancedActionBuffer.length > ENHANCED_ACTION_BUFFER_SIZE) {\n    enhancedActionBuffer.shift()\n  }\n\n  // Emit to content script for server relay\n  if (typeof window !== 'undefined' && window.postMessage) {\n    window.postMessage(\n      { type: 'GASOLINE_ENHANCED_ACTION', payload: action } as GasolineEnhancedActionMessage,\n      window.location.origin\n    )\n  }\n\n  return action\n}\n\n/**\n * Get the enhanced action buffer\n */\nexport function getEnhancedActionBuffer(): EnhancedActionRecord[] {\n  return [...enhancedActionBuffer]\n}\n\n/**\n * Clear the enhanced action buffer\n */\nexport function clearEnhancedActionBuffer(): void {\n  enhancedActionBuffer = []\n}\n\nfunction rebaseUrl(url: string, baseUrl: string | undefined): string {\n  if (!baseUrl || !url) return url\n  try {\n    return baseUrl + new URL(url).pathname\n  } catch {\n    return url\n  }\n}\n\ntype StepGenerator = (\n  action: EnhancedActionRecord,\n  locator: string | null,\n  baseUrl: string | undefined\n) => string | null\n\nconst ACTION_STEP_GENERATORS: Record<string, StepGenerator> = {\n  click: (_action, locator) =>\n    locator ? `  await page.${locator}.click();` : `  // click action - no selector available`,\n  input: (action, locator) => {\n    if (!locator) return null\n    const value = action.value === '[redacted]' ? '[user-provided]' : action.value || ''\n    return `  await page.${locator}.fill('${escapeString(value)}');`\n  },\n  keypress: (action) => `  await page.keyboard.press('${escapeString(action.key || '')}');`,\n  navigate: (action, _locator, baseUrl) =>\n    `  await page.waitForURL('${escapeString(rebaseUrl(action.to_url || '', baseUrl))}');`,\n  select: (action, locator) =>\n    locator ? `  await page.${locator}.selectOption('${escapeString(action.selected_value || '')}');` : null,\n  scroll: (action) => `  // User scrolled to y=${action.scroll_y || 0}`\n}\n\n// #lizard forgives\nfunction actionToPlaywrightStep(action: EnhancedActionRecord, baseUrl: string | undefined): string | null {\n  const locator = getPlaywrightLocator(action.selectors || { cssPath: '' })\n  const generator = ACTION_STEP_GENERATORS[action.type]\n  return generator ? generator(action, locator, baseUrl) : null\n}\n\n/**\n * Generate a Playwright test script from captured actions\n */\nexport function generatePlaywrightScript(actions: EnhancedActionRecord[], opts: ScriptOptions = {}): string {\n  const { errorMessage, baseUrl, lastNActions } = opts\n\n  // Apply lastNActions filter\n  let filteredActions = actions\n  if (lastNActions && lastNActions > 0 && actions.length > lastNActions) {\n    filteredActions = actions.slice(-lastNActions)\n  }\n\n  // Determine start URL\n  let startUrl = ''\n  if (filteredActions.length > 0) {\n    const firstAction = filteredActions[0]\n    if (firstAction) {\n      startUrl = firstAction.url || ''\n    }\n  }\n  if (baseUrl && startUrl) {\n    try {\n      const parsed = new URL(startUrl)\n      startUrl = baseUrl + parsed.pathname\n    } catch {\n      startUrl = baseUrl\n    }\n  }\n\n  // Build test name\n  const testName = errorMessage ? `reproduction: ${errorMessage.slice(0, 80)}` : 'reproduction: captured user actions'\n\n  // Generate step code\n  const steps: string[] = []\n  let prevTimestamp: number | null = null\n\n  for (const action of filteredActions) {\n    if (prevTimestamp && action.timestamp - prevTimestamp > 2000) {\n      const gap = Math.round((action.timestamp - prevTimestamp) / 1000)\n      steps.push(`  // [${gap}s pause]`)\n    }\n    prevTimestamp = action.timestamp\n\n    const step = actionToPlaywrightStep(action, baseUrl)\n    if (step) steps.push(step)\n  }\n\n  // Assemble script\n  let script = `import { test, expect } from '@playwright/test';\\n\\n` // nosemgrep: missing-template-string-indicator\n  script += `test('${escapeString(testName)}', async ({ page }) => {\\n` // nosemgrep: missing-template-string-indicator\n  if (startUrl) {\n    script += `  await page.goto('${escapeString(startUrl)}');\\n\\n`\n  }\n  script += steps.join('\\n')\n  if (steps.length > 0) script += '\\n'\n  if (errorMessage) {\n    script += `\\n  // Error occurred here: ${errorMessage}\\n`\n  }\n  script += `});\\n`\n\n  // Cap output size\n  if (script.length > SCRIPT_MAX_SIZE) {\n    script = script.slice(0, SCRIPT_MAX_SIZE)\n  }\n\n  return script\n}\n\n/**\n * Get the best Playwright locator for a set of selectors\n * Priority: testId > role > ariaLabel > text > id > cssPath\n */\nfunction getPlaywrightLocator(selectors: SelectorStrategies): string | null {\n  if (selectors.testId) return `getByTestId('${escapeString(selectors.testId)}')`\n\n  if (selectors.role && selectors.role.role) {\n    const escaped = escapeString(selectors.role.role)\n    return selectors.role.name\n      ? `getByRole('${escaped}', { name: '${escapeString(selectors.role.name)}' })`\n      : `getByRole('${escaped}')`\n  }\n\n  if (selectors.ariaLabel) return `getByLabel('${escapeString(selectors.ariaLabel)}')`\n  if (selectors.text) return `getByText('${escapeString(selectors.text)}')`\n  if (selectors.id) return `locator('#${escapeString(selectors.id)}')`\n  if (selectors.cssPath) return `locator('${escapeString(selectors.cssPath)}')`\n  return null\n}\n\n/**\n * Escape a string for use in JavaScript string literals\n */\nfunction escapeString(str: string | undefined): string {\n  if (!str) return ''\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\t/g, '\\\\t')\n    .replace(/`/g, '\\\\`')\n}\n", "/**\n * @fileoverview User action capture and replay buffer.\n * Records click, input, scroll, keydown, and change events with throttling\n * and sensitive data redaction. Also captures navigation events (pushState,\n * replaceState, popstate) for enhanced reproduction scripts.\n */\n\nimport { MAX_ACTION_BUFFER_SIZE, SCROLL_THROTTLE_MS, ACTIONABLE_KEYS } from './constants.js'\nimport { getElementSelector, isSensitiveInput } from './serialize.js'\nimport { recordEnhancedAction } from './reproduction.js'\n\n// Action record type\ninterface ActionRecord {\n  ts: string\n  type: string\n  target?: string\n  x?: number\n  y?: number\n  text?: string\n  inputType?: string\n  value?: string\n  length?: number\n  scrollX?: number\n  scrollY?: number\n}\n\n// Extended event target types\ninterface InputElement extends HTMLElement {\n  type?: string\n  value?: string\n}\n\ninterface SelectElement extends HTMLSelectElement {\n  options: HTMLOptionsCollection\n  selectedIndex: number\n  value: string\n}\n\n// User action replay buffer\nlet actionBuffer: ActionRecord[] = []\nlet lastScrollTime = 0\nlet actionCaptureEnabled = true\nlet clickHandler: ((event: MouseEvent) => void) | null = null\nlet inputHandler: ((event: Event) => void) | null = null\nlet scrollHandler: ((event: Event) => void) | null = null\nlet keydownHandler: ((event: KeyboardEvent) => void) | null = null\nlet changeHandler: ((event: Event) => void) | null = null\n\n/**\n * Record a user action to the buffer\n */\nexport function recordAction(action: Omit<ActionRecord, 'ts'>): void {\n  if (!actionCaptureEnabled) return\n\n  actionBuffer.push({\n    ts: new Date().toISOString(),\n    ...action\n  })\n\n  // Keep buffer size limited\n  if (actionBuffer.length > MAX_ACTION_BUFFER_SIZE) {\n    actionBuffer.shift()\n  }\n}\n\n/**\n * Get the current action buffer\n */\nexport function getActionBuffer(): ActionRecord[] {\n  return [...actionBuffer]\n}\n\n/**\n * Clear the action buffer\n */\nexport function clearActionBuffer(): void {\n  actionBuffer = []\n}\n\n/**\n * Handle click events\n */\nexport function handleClick(event: MouseEvent): void {\n  const target = event.target as Element | null\n  if (!target) return\n\n  const action: Omit<ActionRecord, 'ts'> = {\n    type: 'click',\n    target: getElementSelector(target),\n    x: event.clientX,\n    y: event.clientY\n  }\n\n  // Include button text if available (truncated)\n  const text = (target as HTMLElement).textContent || (target as HTMLElement).innerText || ''\n  if (text && text.length > 0) {\n    action.text = text.trim().slice(0, 50)\n  }\n\n  recordAction(action)\n  recordEnhancedAction('click', target)\n}\n\n/**\n * Handle input events\n */\nexport function handleInput(event: Event): void {\n  const target = event.target as InputElement | null\n  if (!target) return\n\n  const action: Omit<ActionRecord, 'ts'> = {\n    type: 'input',\n    target: getElementSelector(target),\n    inputType: target.type || 'text'\n  }\n\n  // Only include value for non-sensitive fields\n  if (!isSensitiveInput(target)) {\n    const value = target.value || ''\n    action.value = value.slice(0, 100)\n    action.length = value.length\n  } else {\n    action.value = '[redacted]'\n    action.length = (target.value || '').length\n  }\n\n  recordAction(action)\n  recordEnhancedAction('input', target, { value: action.value })\n}\n\n/**\n * Handle scroll events (throttled)\n */\nexport function handleScroll(event: Event): void {\n  const now = Date.now()\n  if (now - lastScrollTime < SCROLL_THROTTLE_MS) return\n  lastScrollTime = now\n\n  const target = event.target\n  recordAction({\n    type: 'scroll',\n    scrollX: Math.round(window.scrollX),\n    scrollY: Math.round(window.scrollY),\n    target: target === document ? 'document' : getElementSelector(target as Element)\n  })\n  recordEnhancedAction('scroll', null, { scroll_y: Math.round(window.scrollY) })\n}\n\n/**\n * Handle keydown events - only records actionable keys\n */\nexport function handleKeydown(event: KeyboardEvent): void {\n  if (!ACTIONABLE_KEYS.has(event.key)) return\n  const target = event.target as Element | null\n  recordEnhancedAction('keypress', target, { key: event.key })\n}\n\n/**\n * Handle change events on select elements\n */\nexport function handleChange(event: Event): void {\n  const target = event.target as SelectElement | null\n  if (!target || !target.tagName || target.tagName.toUpperCase() !== 'SELECT') return\n\n  const selectedOption = target.options && target.options[target.selectedIndex]\n  const selectedValue = target.value || ''\n  const selectedText = selectedOption ? selectedOption.text || '' : ''\n\n  recordEnhancedAction('select', target, { selected_value: selectedValue, selected_text: selectedText })\n}\n\n/**\n * Install user action capture\n */\nexport function installActionCapture(): void {\n  if (typeof window === 'undefined' || typeof document === 'undefined') return\n  if (typeof document.addEventListener !== 'function') return\n\n  clickHandler = handleClick\n  inputHandler = handleInput\n  scrollHandler = handleScroll\n  keydownHandler = handleKeydown\n  changeHandler = handleChange\n\n  document.addEventListener('click', clickHandler, { capture: true, passive: true })\n  document.addEventListener('input', inputHandler, { capture: true, passive: true })\n  document.addEventListener('keydown', keydownHandler, { capture: true, passive: true })\n  document.addEventListener('change', changeHandler, { capture: true, passive: true })\n  window.addEventListener('scroll', scrollHandler, { capture: true, passive: true })\n}\n\n/**\n * Uninstall user action capture\n */\nexport function uninstallActionCapture(): void {\n  if (clickHandler) {\n    document.removeEventListener('click', clickHandler, { capture: true })\n    clickHandler = null\n  }\n  if (inputHandler) {\n    document.removeEventListener('input', inputHandler, { capture: true })\n    inputHandler = null\n  }\n  if (keydownHandler) {\n    document.removeEventListener('keydown', keydownHandler, { capture: true })\n    keydownHandler = null\n  }\n  if (changeHandler) {\n    document.removeEventListener('change', changeHandler, { capture: true })\n    changeHandler = null\n  }\n  if (scrollHandler) {\n    window.removeEventListener('scroll', scrollHandler, { capture: true })\n    scrollHandler = null\n  }\n  clearActionBuffer()\n}\n\n/**\n * Set whether action capture is enabled\n */\nexport function setActionCaptureEnabled(enabled: boolean): void {\n  actionCaptureEnabled = enabled\n  if (!enabled) {\n    clearActionBuffer()\n  }\n}\n\n// =============================================================================\n// NAVIGATION CAPTURE\n// =============================================================================\n\nlet navigationPopstateHandler: (() => void) | null = null\nlet originalPushState: typeof history.pushState | null = null\nlet originalReplaceState: typeof history.replaceState | null = null\n\n/**\n * Install navigation capture to record enhanced actions on navigation events\n */\nexport function installNavigationCapture(): void {\n  if (typeof window === 'undefined') return\n\n  // Track current URL for from_url\n  let lastUrl = window.location.href\n\n  // Popstate handler (back/forward)\n  navigationPopstateHandler = function (): void {\n    const toUrl = window.location.href\n    recordEnhancedAction('navigate', null, { from_url: lastUrl, to_url: toUrl })\n    lastUrl = toUrl\n  }\n  window.addEventListener('popstate', navigationPopstateHandler)\n\n  // Patch pushState\n  if (window.history && window.history.pushState) {\n    originalPushState = window.history.pushState\n    window.history.pushState = function (\n      this: History,\n      state: unknown,\n      title: string,\n      url?: string | URL | null\n    ): void {\n      const fromUrl = lastUrl\n      originalPushState!.call(this, state, title, url)\n      const toUrl = url || window.location.href\n      recordEnhancedAction('navigate', null, { from_url: fromUrl, to_url: String(toUrl) })\n      lastUrl = window.location.href\n    }\n  }\n\n  // Patch replaceState\n  if (window.history && window.history.replaceState) {\n    originalReplaceState = window.history.replaceState\n    window.history.replaceState = function (\n      this: History,\n      state: unknown,\n      title: string,\n      url?: string | URL | null\n    ): void {\n      const fromUrl = lastUrl\n      originalReplaceState!.call(this, state, title, url)\n      const toUrl = url || window.location.href\n      recordEnhancedAction('navigate', null, { from_url: fromUrl, to_url: String(toUrl) })\n      lastUrl = window.location.href\n    }\n  }\n}\n\n/**\n * Uninstall navigation capture\n */\nexport function uninstallNavigationCapture(): void {\n  if (navigationPopstateHandler) {\n    window.removeEventListener('popstate', navigationPopstateHandler)\n    navigationPopstateHandler = null\n  }\n  if (originalPushState && window.history) {\n    window.history.pushState = originalPushState\n    originalPushState = null\n  }\n  if (originalReplaceState && window.history) {\n    window.history.replaceState = originalReplaceState\n    originalReplaceState = null\n  }\n}\n", "/**\n * @fileoverview Network waterfall and body capture.\n * Provides PerformanceResourceTiming parsing, pending request tracking,\n * fetch body capture with size limits, and sensitive header sanitization.\n */\n\nimport type { WaterfallEntry, WaterfallPhases, PendingRequest } from '../types/index'\n\nimport {\n  MAX_WATERFALL_ENTRIES,\n  WATERFALL_TIME_WINDOW_MS,\n  REQUEST_BODY_MAX,\n  RESPONSE_BODY_MAX,\n  BODY_READ_TIMEOUT_MS,\n  SENSITIVE_HEADER_PATTERNS,\n  BINARY_CONTENT_TYPES\n} from './constants.js'\n\n// =============================================================================\n// TYPE DEFINITIONS\n// =============================================================================\n\n/**\n * Options for filtering network waterfall entries\n */\ninterface WaterfallFilterOptions {\n  since?: number\n  initiatorTypes?: string[]\n}\n\n/**\n * Truncation result for request/response bodies\n */\ninterface TruncationResult {\n  body: string | null\n  truncated: boolean\n}\n\n/**\n * Internal pending request tracking with mutable id\n */\ninterface InternalPendingRequest {\n  id: string\n  url: string\n  method: string\n  startTime: number\n}\n\n/**\n * Request info for tracking\n */\ninterface RequestInfo {\n  url: string\n  method: string\n  startTime: number\n}\n\n/**\n * Network body payload posted to content script\n */\ninterface NetworkBodyPostMessage {\n  type: 'GASOLINE_NETWORK_BODY'\n  payload: {\n    url: string\n    method: string\n    status: number\n    contentType: string\n    requestBody?: string\n    responseBody?: string\n    responseTruncated?: boolean\n    duration: number\n  }\n}\n\n// =============================================================================\n// MODULE STATE\n// =============================================================================\n\n// Configured server URL for filtering (updated via setServerUrl)\nlet configuredServerUrl = ''\n\n// Network Waterfall state\nlet networkWaterfallEnabled = false\nconst pendingRequests = new Map<string, InternalPendingRequest>() // requestId -> { url, method, startTime }\nlet requestIdCounter = 0\n\n// Network body capture state\nlet networkBodyCaptureEnabled = true // Default: capture request/response bodies\n\n/** URL patterns for auth endpoints whose response bodies should be redacted */\nconst SENSITIVE_URL_PATTERNS = /\\/(auth|login|signin|signup|token|oauth|session|api[_-]?key|password|register)\\b/i\n\n// =============================================================================\n// NETWORK WATERFALL\n// =============================================================================\n\n/**\n * Parse a PerformanceResourceTiming entry into waterfall phases\n * @param timing - The timing entry\n * @returns Parsed waterfall entry\n */\nexport function parseResourceTiming(timing: PerformanceResourceTiming): WaterfallEntry {\n  const phases: WaterfallPhases = {\n    dns: Math.max(0, timing.domainLookupEnd - timing.domainLookupStart),\n    connect: Math.max(0, timing.connectEnd - timing.connectStart),\n    tls: timing.secureConnectionStart > 0 ? Math.max(0, timing.connectEnd - timing.secureConnectionStart) : 0,\n    ttfb: Math.max(0, timing.responseStart - timing.requestStart),\n    download: Math.max(0, timing.responseEnd - timing.responseStart)\n  }\n\n  const result: WaterfallEntry = {\n    url: timing.name,\n    initiatorType: timing.initiatorType,\n    startTime: timing.startTime,\n    duration: timing.duration,\n    phases,\n    transferSize: timing.transferSize || 0,\n    encodedBodySize: timing.encodedBodySize || 0,\n    decodedBodySize: timing.decodedBodySize || 0\n  }\n\n  // Detect cache hit\n  if (timing.transferSize === 0 && timing.encodedBodySize > 0) {\n    ;(result as { cached?: boolean }).cached = true\n  }\n\n  return result\n}\n\n/**\n * Get network waterfall entries\n * @param options - Options for filtering\n * @returns Array of waterfall entries\n */\nexport function getNetworkWaterfall(options: WaterfallFilterOptions = {}): WaterfallEntry[] {\n  if (typeof performance === 'undefined' || !performance) return []\n\n  try {\n    let entries = (performance.getEntriesByType('resource') as PerformanceResourceTiming[]) || []\n\n    // Filter by time range\n    if (options.since) {\n      entries = entries.filter((e) => e.startTime >= options.since!)\n    }\n\n    // Filter by initiator type\n    if (options.initiatorTypes) {\n      entries = entries.filter((e) => options.initiatorTypes!.includes(e.initiatorType))\n    }\n\n    // Exclude data URLs\n    entries = entries.filter((e) => !e.name.startsWith('data:'))\n\n    // Sort by start time\n    entries.sort((a, b) => a.startTime - b.startTime)\n\n    // Limit entries\n    if (entries.length > MAX_WATERFALL_ENTRIES) {\n      entries = entries.slice(-MAX_WATERFALL_ENTRIES)\n    }\n\n    return entries.map(parseResourceTiming)\n  } catch {\n    return []\n  }\n}\n\n/**\n * Track a pending request\n * @param request - Request info { url, method, startTime }\n * @returns Request ID\n */\nexport function trackPendingRequest(request: RequestInfo): string {\n  const id = `req_${++requestIdCounter}`\n  pendingRequests.set(id, {\n    ...request,\n    id\n  })\n  return id\n}\n\n/**\n * Complete a pending request\n * @param requestId - The request ID to complete\n */\nexport function completePendingRequest(requestId: string): void {\n  pendingRequests.delete(requestId)\n}\n\n/**\n * Get all pending requests\n * @returns Array of pending requests\n */\nexport function getPendingRequests(): PendingRequest[] {\n  return Array.from(pendingRequests.values())\n}\n\n/**\n * Clear all pending requests\n */\nexport function clearPendingRequests(): void {\n  pendingRequests.clear()\n}\n\n/**\n * Network waterfall snapshot for an error\n */\ninterface NetworkWaterfallSnapshot {\n  type: 'network_waterfall'\n  ts: string\n  _errorTs: string\n  entries: WaterfallEntry[]\n  pending: PendingRequest[]\n}\n\n/**\n * Error entry with timestamp\n */\ninterface ErrorEntry {\n  ts: string\n}\n\n/**\n * Get network waterfall snapshot for an error\n * @param errorEntry - The error entry\n * @returns The waterfall snapshot\n */\nexport async function getNetworkWaterfallForError(errorEntry: ErrorEntry): Promise<NetworkWaterfallSnapshot | null> {\n  if (!networkWaterfallEnabled) return null\n\n  const now = typeof performance !== 'undefined' && performance?.now ? performance.now() : 0\n  const since = Math.max(0, now - WATERFALL_TIME_WINDOW_MS)\n\n  const entries = getNetworkWaterfall({ since })\n  const pending = getPendingRequests()\n\n  return {\n    type: 'network_waterfall',\n    ts: new Date().toISOString(),\n    _errorTs: errorEntry.ts,\n    entries,\n    pending\n  }\n}\n\n/**\n * Set whether network waterfall is enabled\n * @param enabled - Whether to enable network waterfall\n */\nexport function setNetworkWaterfallEnabled(enabled: boolean): void {\n  networkWaterfallEnabled = enabled\n}\n\n/**\n * Check if network waterfall is enabled\n * @returns Whether network waterfall is enabled\n */\nexport function isNetworkWaterfallEnabled(): boolean {\n  return networkWaterfallEnabled\n}\n\n// =============================================================================\n// NETWORK BODY CAPTURE\n// =============================================================================\n\n/**\n * Set whether network body capture is enabled\n * @param enabled - Whether to enable body capture\n */\nexport function setNetworkBodyCaptureEnabled(enabled: boolean): void {\n  networkBodyCaptureEnabled = enabled\n}\n\n/**\n * Check if network body capture is enabled\n * @returns Whether body capture is enabled\n */\nexport function isNetworkBodyCaptureEnabled(): boolean {\n  return networkBodyCaptureEnabled\n}\n\n/**\n * Set the configured server URL for capture filtering.\n * Called when the server URL is loaded from settings.\n * @param url - The server URL (e.g., 'http://localhost:7890')\n */\nexport function setServerUrl(url: string): void {\n  configuredServerUrl = url || ''\n}\n\n/**\n * Check if a URL should be captured (not gasoline server or extension)\n * @param url - The URL to check\n * @returns True if the URL should be captured\n */\nexport function shouldCaptureUrl(url: string): boolean {\n  if (!url) return true\n  // Filter against the configured server URL if set\n  if (configuredServerUrl) {\n    try {\n      const serverParsed = new URL(configuredServerUrl)\n      const hostPort = serverParsed.host // e.g., 'localhost:7890'\n      if (url.includes(hostPort)) return false\n    } catch {\n      // Fall through to hardcoded defaults\n    }\n  }\n  // Hardcoded fallback for default server URL\n  if (url.includes('localhost:7890') || url.includes('127.0.0.1:7890')) return false\n  if (url.startsWith('chrome-extension://')) return false\n  return true\n}\n\n/**\n * Sanitize headers by removing sensitive ones\n * @param headers - Headers to sanitize\n * @returns Sanitized headers object\n */\n// #lizard forgives\nexport function sanitizeHeaders(\n  headers: HeadersInit | Headers | Record<string, string> | null\n): Record<string, string> {\n  if (!headers) return {}\n\n  const result: Record<string, string> = {}\n\n  if (headers instanceof Headers || typeof (headers as unknown as Headers).forEach === 'function') {\n    // Headers object or Map\n    ;(headers as unknown as Headers).forEach((value: string, key: string) => {\n      if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n        result[key] = value\n      }\n    })\n  } else if (typeof (headers as { entries?: () => Iterable<[string, string]> }).entries === 'function') {\n    for (const [key, value] of (headers as { entries: () => Iterable<[string, string]> }).entries()) {\n      if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n        result[key] = value\n      }\n    }\n  } else if (typeof headers === 'object') {\n    for (const [key, value] of Object.entries(headers as Record<string, string>)) {\n      if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n        result[key] = value\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Truncate request body at 8KB limit\n * @param body - The request body\n * @returns Truncation result\n */\nexport function truncateRequestBody(body: string | null | undefined): TruncationResult {\n  if (body === null || body === undefined) return { body: null, truncated: false }\n  if (body.length <= REQUEST_BODY_MAX) return { body, truncated: false }\n  return { body: body.slice(0, REQUEST_BODY_MAX), truncated: true }\n}\n\n/**\n * Truncate response body at 16KB limit\n * @param body - The response body\n * @returns Truncation result\n */\nexport function truncateResponseBody(body: string | null | undefined): TruncationResult {\n  if (body === null || body === undefined) return { body: null, truncated: false }\n  if (body.length <= RESPONSE_BODY_MAX) return { body, truncated: false }\n  return { body: body.slice(0, RESPONSE_BODY_MAX), truncated: true }\n}\n\n/**\n * Read a response body, returning text for text types and size info for binary\n * @param response - The cloned response object\n * @returns The body content or binary size placeholder\n */\nexport async function readResponseBody(response: Response): Promise<string> {\n  const contentType = response.headers?.get?.('content-type') || ''\n\n  if (BINARY_CONTENT_TYPES.test(contentType)) {\n    const blob = await response.blob()\n    return `[Binary: ${blob.size} bytes, ${contentType}]`\n  }\n\n  // Text-like or unknown content type: try reading as text\n  return await response.text()\n}\n\n/**\n * Read response body with a timeout\n * @param response - The cloned response object\n * @param timeoutMs - Timeout in milliseconds\n * @returns The body or timeout message\n */\nexport async function readResponseBodyWithTimeout(\n  response: Response,\n  timeoutMs: number = BODY_READ_TIMEOUT_MS\n): Promise<string> {\n  return Promise.race([\n    readResponseBody(response),\n    new Promise<string>((resolve) => {\n      setTimeout(() => resolve('[Skipped: body read timeout]'), timeoutMs)\n    })\n  ])\n}\n\n/**\n * Reset all module state for testing purposes\n * Clears pending requests, resets counters, and restores default settings.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting(): void {\n  configuredServerUrl = ''\n  networkWaterfallEnabled = false\n  pendingRequests.clear()\n  requestIdCounter = 0\n  networkBodyCaptureEnabled = true\n}\n\n/**\n * Type alias for fetch-like functions (avoids overload complexity)\n */\ntype FetchLike = (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>\n\n/**\n * Wrap a fetch function to capture request/response bodies\n * @param fetchFn - The original fetch function\n * @returns Wrapped fetch that captures bodies\n */\nfunction extractFetchInfo(\n  input: RequestInfo | URL,\n  init?: RequestInit\n): { url: string; method: string; requestBody: BodyInit | null | undefined } {\n  let url = ''\n  let method = 'GET'\n  if (typeof input === 'string') {\n    url = input\n  } else if (input && (input as unknown as Request).url) {\n    url = (input as unknown as Request).url\n    method = (input as unknown as Request).method || 'GET'\n  }\n  if (init) {\n    method = init.method || method\n  }\n  return { url, method, requestBody: init?.body || null }\n}\n\nasync function readCapturedBody(url: string, cloned: Response | null, contentType: string): Promise<string> {\n  if (SENSITIVE_URL_PATTERNS.test(url)) return '[REDACTED: auth endpoint]'\n  if (!cloned) return ''\n  if (BINARY_CONTENT_TYPES.test(contentType)) {\n    const blob = await cloned.blob()\n    return `[Binary: ${blob.size} bytes, ${contentType}]`\n  }\n  return readResponseBodyWithTimeout(cloned)\n}\n\nfunction postNetworkBody(\n  win: Window,\n  url: string,\n  method: string,\n  response: Response,\n  contentType: string,\n  requestBody: BodyInit | null | undefined,\n  duration: number,\n  truncResp: string,\n  truncReq: string | null,\n  responseTruncated: boolean\n): void {\n  const message: NetworkBodyPostMessage = {\n    type: 'GASOLINE_NETWORK_BODY',\n    payload: {\n      url,\n      method,\n      status: response.status,\n      contentType,\n      requestBody: truncReq || (typeof requestBody === 'string' ? requestBody : undefined),\n      responseBody: truncResp,\n      ...(responseTruncated ? { responseTruncated: true } : {}),\n      duration\n    }\n  }\n  win.postMessage(message, window.location.origin)\n}\n\nexport function wrapFetchWithBodies(fetchFn: FetchLike): FetchLike {\n  return async function (input: RequestInfo | URL, init?: RequestInit): Promise<Response> {\n    const { url, method, requestBody } = extractFetchInfo(input, init)\n    if (!shouldCaptureUrl(url)) return fetchFn(input, init)\n\n    const startTime = Date.now()\n    const response = await fetchFn(input, init)\n    const duration = Date.now() - startTime\n    const contentType = response.headers?.get?.('content-type') || ''\n    const cloned = response.clone ? response.clone() : null\n    const win = typeof window !== 'undefined' ? window : null\n\n    Promise.resolve()\n      .then(async () => {\n        try {\n          const responseBody = await readCapturedBody(url, cloned, contentType)\n          const { body: truncResp, truncated: respTruncated } = truncateResponseBody(responseBody)\n          const rawReq = SENSITIVE_URL_PATTERNS.test(url)\n            ? '[REDACTED: auth endpoint]'\n            : typeof requestBody === 'string'\n              ? requestBody\n              : null\n          const { body: truncReq } = truncateRequestBody(rawReq)\n          if (win && networkBodyCaptureEnabled) {\n            postNetworkBody(\n              win,\n              url,\n              method,\n              response,\n              contentType,\n              requestBody,\n              duration,\n              truncResp || responseBody,\n              truncReq,\n              respTruncated\n            )\n          }\n        } catch {\n          /* Body capture failure should not affect user code */\n        }\n      })\n      .catch((err: Error) => {\n        console.debug('[Gasoline] Network body capture error:', err)\n      })\n\n    return response\n  }\n}\n", "/**\n * @fileoverview Performance snapshot capture.\n * Observes web vitals (FCP, LCP, CLS, INP), long tasks, and resource timing\n * to build comprehensive performance snapshots.\n */\n\nimport { MAX_LONG_TASKS, MAX_SLOWEST_REQUESTS, MAX_URL_LENGTH } from './constants'\n\ninterface ResourceByType {\n  count: number\n  size: number\n}\n\ninterface SlowRequest {\n  url: string\n  duration: number\n  size: number\n}\n\ninterface ResourceTimingSummary {\n  request_count: number\n  transfer_size: number\n  decoded_size: number\n  by_type: Record<string, ResourceByType>\n  slowest_requests: SlowRequest[]\n}\n\ninterface LongTaskMetrics {\n  count: number\n  total_blocking_time: number\n  longest: number\n}\n\ninterface NetworkTiming {\n  dom_content_loaded: number\n  load: number\n  first_contentful_paint: number | null\n  largest_contentful_paint: number | null\n  interaction_to_next_paint: number | null\n  time_to_first_byte: number\n  dom_interactive: number\n}\n\ninterface UserTimingEntry {\n  name: string\n  start_time: number\n  duration?: number\n}\n\ninterface PerformanceSnapshotData {\n  url: string\n  timestamp: string\n  timing: NetworkTiming\n  network: ResourceTimingSummary\n  long_tasks: LongTaskMetrics\n  cumulative_layout_shift: number\n  user_timing?: {\n    marks: UserTimingEntry[]\n    measures: UserTimingEntry[]\n  }\n}\n\n// Performance snapshot state\nlet perfSnapshotEnabled = true\nlet longTaskEntries: PerformanceEntry[] = []\nlet longTaskObserver: PerformanceObserver | null = null\nlet paintObserver: PerformanceObserver | null = null\nlet lcpObserver: PerformanceObserver | null = null\nlet clsObserver: PerformanceObserver | null = null\nlet inpObserver: PerformanceObserver | null = null\nlet fcpValue: number | null = null\nlet lcpValue: number | null = null\nlet clsValue = 0\nlet inpValue: number | null = null\n\n/**\n * Map resource initiator types to standard categories\n */\nexport function mapInitiatorType(type: string): string {\n  switch (type) {\n    case 'script':\n      return 'script'\n    case 'link':\n    case 'css':\n      return 'style'\n    case 'img':\n      return 'image'\n    case 'fetch':\n    case 'xmlhttprequest':\n      return 'fetch'\n    case 'font':\n      return 'font'\n    default:\n      return 'other'\n  }\n}\n\n/**\n * Aggregate resource timing entries into a network summary\n */\nexport function aggregateResourceTiming(): ResourceTimingSummary {\n  const resources = (performance.getEntriesByType('resource') as PerformanceResourceTiming[]) || []\n  const byType: Record<string, ResourceByType> = {}\n  let transferSize = 0\n  let decodedSize = 0\n\n  for (const entry of resources) {\n    const category = mapInitiatorType(entry.initiatorType)\n    // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n    if (!byType[category]) {\n      // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n      byType[category] = { count: 0, size: 0 }\n    }\n    // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n    byType[category].count++\n    // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n    byType[category].size += entry.transferSize || 0\n    transferSize += entry.transferSize || 0\n    decodedSize += entry.decodedBodySize || 0\n  }\n\n  // Top N slowest requests\n  const sorted = [...resources].sort((a, b) => b.duration - a.duration)\n  const slowestRequests: SlowRequest[] = sorted.slice(0, MAX_SLOWEST_REQUESTS).map((r) => ({\n    url: r.name.length > MAX_URL_LENGTH ? r.name.slice(0, MAX_URL_LENGTH) : r.name,\n    duration: r.duration,\n    size: r.transferSize || 0\n  }))\n\n  return {\n    request_count: resources.length,\n    transfer_size: transferSize,\n    decoded_size: decodedSize,\n    by_type: byType,\n    slowest_requests: slowestRequests\n  }\n}\n\n/**\n * Capture a performance snapshot with navigation timing and network summary\n */\nexport function capturePerformanceSnapshot(): PerformanceSnapshotData | null {\n  const navEntries = (performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]) || []\n  if (!navEntries || navEntries.length === 0) return null\n\n  const nav = navEntries[0]\n  if (!nav) return null\n\n  const timing: NetworkTiming = {\n    dom_content_loaded: nav.domContentLoadedEventEnd,\n    load: nav.loadEventEnd,\n    first_contentful_paint: getFCP(),\n    largest_contentful_paint: getLCP(),\n    interaction_to_next_paint: getINP(),\n    time_to_first_byte: nav.responseStart - nav.requestStart,\n    dom_interactive: nav.domInteractive\n  }\n\n  const network = aggregateResourceTiming()\n  const longTasks = getLongTaskMetrics()\n\n  // Capture user timing marks and measures\n  const marks = (performance.getEntriesByType('mark') as PerformanceEntry[]) || []\n  const measures = (performance.getEntriesByType('measure') as PerformanceEntry[]) || []\n  const userTiming =\n    marks.length > 0 || measures.length > 0\n      ? {\n          marks: marks.slice(-50).map((m) => ({ name: m.name, start_time: m.startTime })),\n          measures: measures.slice(-50).map((m) => ({ name: m.name, start_time: m.startTime, duration: m.duration }))\n        }\n      : undefined\n\n  return {\n    url: window.location.pathname,\n    timestamp: new Date().toISOString(),\n    timing,\n    network,\n    long_tasks: longTasks,\n    cumulative_layout_shift: getCLS(),\n    user_timing: userTiming\n  }\n}\n\n/**\n * Install performance observers for long tasks, paint, LCP, and CLS\n */\nexport function installPerfObservers(): void {\n  longTaskEntries = []\n  fcpValue = null\n  lcpValue = null\n  clsValue = 0\n  inpValue = null\n\n  // Long task observer\n  // #lizard forgives\n  longTaskObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    const entries = list.getEntries()\n    for (const entry of entries) {\n      if (longTaskEntries.length < MAX_LONG_TASKS) {\n        longTaskEntries.push(entry)\n      }\n    }\n  })\n  longTaskObserver.observe({ type: 'longtask' })\n\n  // Paint observer (FCP)\n  paintObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    for (const entry of list.getEntries()) {\n      if (entry.name === 'first-contentful-paint') {\n        fcpValue = entry.startTime\n      }\n    }\n  })\n  paintObserver.observe({ type: 'paint', buffered: true })\n\n  // LCP observer\n  lcpObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    const entries = list.getEntries()\n    if (entries.length > 0) {\n      const lastEntry = entries[entries.length - 1]\n      if (lastEntry) {\n        lcpValue = lastEntry.startTime\n      }\n    }\n  })\n  lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true })\n\n  // CLS observer\n  // LayoutShift interface extends PerformanceEntry with hadRecentInput and value\n  clsObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    for (const entry of list.getEntries()) {\n      const clsEntry = entry as PerformanceEntry & { hadRecentInput?: boolean; value?: number }\n      if (!clsEntry.hadRecentInput) {\n        clsValue += clsEntry.value || 0\n      }\n    }\n  })\n  clsObserver.observe({ type: 'layout-shift', buffered: true })\n\n  // INP observer (Interaction to Next Paint)\n  // Event timing entries have interactionId and duration properties\n  inpObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    for (const entry of list.getEntries()) {\n      const inpEntry = entry as PerformanceEntry & { interactionId?: number }\n      if (inpEntry.interactionId) {\n        if (inpValue === null || inpEntry.duration > inpValue) {\n          inpValue = inpEntry.duration\n        }\n      }\n    }\n  })\n  inpObserver.observe({ type: 'event', durationThreshold: 40, buffered: true } as PerformanceObserverInit)\n}\n\n/**\n * Disconnect all performance observers\n */\nexport function uninstallPerfObservers(): void {\n  if (longTaskObserver) {\n    longTaskObserver.disconnect()\n    longTaskObserver = null\n  }\n  if (paintObserver) {\n    paintObserver.disconnect()\n    paintObserver = null\n  }\n  if (lcpObserver) {\n    lcpObserver.disconnect()\n    lcpObserver = null\n  }\n  if (clsObserver) {\n    clsObserver.disconnect()\n    clsObserver = null\n  }\n  if (inpObserver) {\n    inpObserver.disconnect()\n    inpObserver = null\n  }\n  longTaskEntries = []\n}\n\n/**\n * Get accumulated long task metrics\n */\nexport function getLongTaskMetrics(): LongTaskMetrics {\n  let totalBlockingTime = 0\n  let longest = 0\n\n  for (const entry of longTaskEntries) {\n    const blocking = entry.duration - 50\n    if (blocking > 0) totalBlockingTime += blocking\n    if (entry.duration > longest) longest = entry.duration\n  }\n\n  return {\n    count: longTaskEntries.length,\n    total_blocking_time: totalBlockingTime,\n    longest\n  }\n}\n\n/**\n * Get First Contentful Paint value\n */\nexport function getFCP(): number | null {\n  return fcpValue\n}\n\n/**\n * Get Largest Contentful Paint value\n */\nexport function getLCP(): number | null {\n  return lcpValue\n}\n\n/**\n * Get Cumulative Layout Shift value\n */\nexport function getCLS(): number {\n  return clsValue\n}\n\n/**\n * Get Interaction to Next Paint value\n */\nexport function getINP(): number | null {\n  return inpValue\n}\n\n/**\n * Send performance snapshot via postMessage to content script\n */\nexport function sendPerformanceSnapshot(): void {\n  if (!perfSnapshotEnabled) return\n\n  const snapshot = capturePerformanceSnapshot()\n  if (!snapshot) return\n\n  window.postMessage({ type: 'GASOLINE_PERFORMANCE_SNAPSHOT', payload: snapshot }, window.location.origin)\n}\n\n// Debounce timer for snapshot re-sends triggered by user timing changes\nlet snapshotResendTimer: ReturnType<typeof setTimeout> | null = null\n\n/**\n * Schedule a debounced re-send of the performance snapshot.\n * Called when user timing marks/measures are created to keep server data fresh.\n */\nexport function scheduleSnapshotResend(): void {\n  if (!perfSnapshotEnabled) return\n  if (snapshotResendTimer) clearTimeout(snapshotResendTimer)\n  snapshotResendTimer = setTimeout(() => {\n    snapshotResendTimer = null\n    sendPerformanceSnapshot()\n  }, 500)\n}\n\n/**\n * Check if performance snapshot capture is enabled\n */\nexport function isPerformanceSnapshotEnabled(): boolean {\n  return perfSnapshotEnabled\n}\n\n/**\n * Enable or disable performance snapshot capture\n */\nexport function setPerformanceSnapshotEnabled(enabled: boolean): void {\n  perfSnapshotEnabled = enabled\n}\n", "/**\n * @fileoverview Performance marks and measures capture.\n * Wraps performance.mark/measure to capture calls, uses PerformanceObserver\n * for additional entries, and provides error-time performance snapshots.\n */\n\nimport { MAX_PERFORMANCE_ENTRIES, PERFORMANCE_TIME_WINDOW_MS } from './constants'\nimport type { PerformanceMark, PerformanceMeasure } from '../types/index'\nimport { scheduleSnapshotResend } from './perf-snapshot'\n\n// Performance Marks state\nlet performanceMarksEnabled = false\nlet capturedMarks: Array<PerformanceMark & { detail?: unknown; capturedAt: string }> = []\nlet capturedMeasures: Array<PerformanceMeasure & { capturedAt: string }> = []\nlet originalPerformanceMark: ((name: string, options?: PerformanceMarkOptions) => PerformanceMark) | null = null\nlet originalPerformanceMeasure: ((name: string, startMark?: string, endMark?: string) => PerformanceMeasure) | null =\n  null\nlet performanceObserver: PerformanceObserver | null = null\nlet performanceCaptureActive = false\n\n/**\n * Get performance marks\n */\nexport function getPerformanceMarks(\n  options: { since?: number } = {}\n): Array<Omit<PerformanceMark, 'entryType'> & { detail?: unknown | null }> {\n  if (typeof performance === 'undefined' || !performance) return []\n\n  try {\n    let marks = (performance.getEntriesByType('mark') as PerformanceEntry[]) || []\n\n    // Filter by time range\n    if (options.since) {\n      marks = marks.filter((m) => m.startTime >= options.since!)\n    }\n\n    // Sort by start time\n    marks.sort((a, b) => a.startTime - b.startTime)\n\n    // Limit entries\n    if (marks.length > MAX_PERFORMANCE_ENTRIES) {\n      marks = marks.slice(-MAX_PERFORMANCE_ENTRIES)\n    }\n\n    return marks.map((m) => ({\n      name: m.name,\n      startTime: m.startTime,\n      detail: (m as PerformanceEntry & { detail?: unknown }).detail || null\n    }))\n  } catch {\n    return []\n  }\n}\n\n/**\n * Get performance measures\n */\nexport function getPerformanceMeasures(options: { since?: number } = {}): Array<Omit<PerformanceMeasure, 'entryType'>> {\n  if (typeof performance === 'undefined' || !performance) return []\n\n  try {\n    let measures = (performance.getEntriesByType('measure') as PerformanceEntry[]) || []\n\n    // Filter by time range\n    if (options.since) {\n      measures = measures.filter((m) => m.startTime >= options.since!)\n    }\n\n    // Sort by start time\n    measures.sort((a, b) => a.startTime - b.startTime)\n\n    // Limit entries\n    if (measures.length > MAX_PERFORMANCE_ENTRIES) {\n      measures = measures.slice(-MAX_PERFORMANCE_ENTRIES)\n    }\n\n    return measures.map((m) => ({\n      name: m.name,\n      startTime: m.startTime,\n      duration: m.duration,\n      ...((m as PerformanceEntry & { detail?: unknown }).detail !== undefined\n        ? { detail: (m as PerformanceEntry & { detail?: unknown }).detail }\n        : {})\n    }))\n  } catch {\n    return []\n  }\n}\n\n/**\n * Get captured marks from wrapper\n */\nexport function getCapturedMarks(): Array<PerformanceMark & { detail?: unknown; capturedAt: string }> {\n  return [...capturedMarks]\n}\n\n/**\n * Get captured measures from wrapper\n */\nexport function getCapturedMeasures(): Array<PerformanceMeasure & { capturedAt: string }> {\n  return [...capturedMeasures]\n}\n\n/**\n * Install performance capture wrapper\n */\nexport function installPerformanceCapture(): void {\n  if (typeof performance === 'undefined' || !performance) return\n\n  // Guard against double installation (prevents infinite recursion)\n  if (performanceCaptureActive) {\n    console.warn('[Gasoline] Performance capture already installed, skipping')\n    return\n  }\n\n  // Clear previous captured data\n  capturedMarks = []\n  capturedMeasures = []\n\n  // Store originals\n  originalPerformanceMark = performance.mark.bind(performance) as (\n    name: string,\n    options?: PerformanceMarkOptions\n  ) => PerformanceMark\n  originalPerformanceMeasure = performance.measure.bind(performance) as (\n    name: string,\n    startMark?: string,\n    endMark?: string\n  ) => PerformanceMeasure\n\n  // Wrap performance.mark\n  // Note: Monkey-patching requires bypassing TypeScript's strict Performance API types.\n  // This is a standard pattern for browser API instrumentation.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const wrappedMark = function (name: string, options?: PerformanceMarkOptions): PerformanceMark {\n    const result = originalPerformanceMark!.call(performance, name, options)\n\n    capturedMarks.push({\n      name,\n      startTime: result.startTime || performance.now(),\n      entryType: 'mark',\n      detail: options?.detail || undefined,\n      capturedAt: new Date().toISOString()\n    })\n\n    // Limit captured marks\n    if (capturedMarks.length > MAX_PERFORMANCE_ENTRIES) {\n      capturedMarks.shift()\n    }\n\n    scheduleSnapshotResend()\n    return result\n  }\n  // Assign the wrapper, bypassing strict type checking for the overloaded method\n  Object.defineProperty(performance, 'mark', { value: wrappedMark, writable: true, configurable: true })\n\n  // Wrap performance.measure\n  // Note: Monkey-patching requires bypassing TypeScript's strict Performance API types.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const wrappedMeasure = function (name: string, startMark?: string, endMark?: string): PerformanceMeasure {\n    const result = originalPerformanceMeasure!.call(performance, name, startMark, endMark)\n\n    capturedMeasures.push({\n      name,\n      startTime: result.startTime || 0,\n      duration: result.duration || 0,\n      entryType: 'measure',\n      capturedAt: new Date().toISOString()\n    })\n\n    // Limit captured measures\n    if (capturedMeasures.length > MAX_PERFORMANCE_ENTRIES) {\n      capturedMeasures.shift()\n    }\n\n    scheduleSnapshotResend()\n    return result\n  }\n  // Assign the wrapper, bypassing strict type checking for the overloaded method\n  Object.defineProperty(performance, 'measure', { value: wrappedMeasure, writable: true, configurable: true })\n\n  performanceCaptureActive = true\n\n  // Try to use PerformanceObserver for additional entries\n  if (typeof window !== 'undefined' && typeof PerformanceObserver !== 'undefined') {\n    try {\n      performanceObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'mark') {\n            // Avoid duplicates from our wrapper\n            if (!capturedMarks.some((m) => m.name === entry.name && m.startTime === entry.startTime)) {\n              capturedMarks.push({\n                name: entry.name,\n                startTime: entry.startTime,\n                entryType: 'mark',\n                detail: (entry as PerformanceEntry & { detail?: unknown }).detail || undefined,\n                capturedAt: new Date().toISOString()\n              })\n            }\n          } else if (entry.entryType === 'measure') {\n            if (!capturedMeasures.some((m) => m.name === entry.name && m.startTime === entry.startTime)) {\n              capturedMeasures.push({\n                name: entry.name,\n                startTime: entry.startTime,\n                duration: entry.duration,\n                entryType: 'measure',\n                capturedAt: new Date().toISOString()\n              })\n            }\n          }\n        }\n      })\n      if (performanceObserver) {\n        performanceObserver.observe({ entryTypes: ['mark', 'measure'] })\n      }\n    } catch {\n      // PerformanceObserver not supported, continue without it\n    }\n  }\n}\n\n/**\n * Uninstall performance capture wrapper\n */\nexport function uninstallPerformanceCapture(): void {\n  if (typeof performance === 'undefined' || !performance) return\n\n  if (originalPerformanceMark) {\n    // Restore original performance.mark using Object.defineProperty for clean restoration\n    Object.defineProperty(performance, 'mark', { value: originalPerformanceMark, writable: true, configurable: true })\n    originalPerformanceMark = null\n  }\n\n  if (originalPerformanceMeasure) {\n    // Restore original performance.measure using Object.defineProperty for clean restoration\n    Object.defineProperty(performance, 'measure', {\n      value: originalPerformanceMeasure,\n      writable: true,\n      configurable: true\n    })\n    originalPerformanceMeasure = null\n  }\n\n  if (performanceObserver) {\n    performanceObserver.disconnect()\n    performanceObserver = null\n  }\n\n  capturedMarks = []\n  capturedMeasures = []\n  performanceCaptureActive = false\n}\n\n/**\n * Check if performance capture is active\n */\nexport function isPerformanceCaptureActive(): boolean {\n  return performanceCaptureActive\n}\n\ninterface PerformanceSnapshot {\n  type: 'performance'\n  ts: string\n  _enrichments: readonly string[]\n  _errorTs?: string\n  marks: Array<Omit<PerformanceMark, 'entryType'> & { detail?: unknown | null }>\n  measures: Array<Omit<PerformanceMeasure, 'entryType'>>\n  navigation: {\n    type?: string\n    startTime: number\n    domContentLoadedEventEnd: number\n    loadEventEnd: number\n  } | null\n}\n\n/**\n * Get performance snapshot for an error\n */\nexport async function getPerformanceSnapshotForError(errorEntry: { ts?: string }): Promise<PerformanceSnapshot | null> {\n  if (!performanceMarksEnabled) return null\n\n  const now = typeof performance !== 'undefined' && performance?.now ? performance.now() : 0\n  const since = Math.max(0, now - PERFORMANCE_TIME_WINDOW_MS)\n\n  const marks = getPerformanceMarks({ since })\n  const measures = getPerformanceMeasures({ since })\n\n  // Include navigation timing if available\n  let navigation: PerformanceSnapshot['navigation'] = null\n  if (typeof performance !== 'undefined' && performance) {\n    try {\n      const navEntries = (performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]) || []\n      if (navEntries && navEntries.length > 0) {\n        const nav = navEntries[0]\n        if (nav) {\n          navigation = {\n            type: nav.type,\n            startTime: nav.startTime,\n            domContentLoadedEventEnd: nav.domContentLoadedEventEnd,\n            loadEventEnd: nav.loadEventEnd\n          }\n        }\n      }\n    } catch {\n      // Navigation timing not available\n    }\n  }\n\n  return {\n    type: 'performance',\n    ts: new Date().toISOString(),\n    _enrichments: ['performanceMarks'],\n    _errorTs: errorEntry.ts,\n    marks,\n    measures,\n    navigation\n  }\n}\n\n/**\n * Set whether performance marks are enabled\n */\nexport function setPerformanceMarksEnabled(enabled: boolean): void {\n  performanceMarksEnabled = enabled\n}\n\n/**\n * Check if performance marks are enabled\n */\nexport function isPerformanceMarksEnabled(): boolean {\n  return performanceMarksEnabled\n}\n", "/**\n * @fileoverview Message bridge for posting log events to the content script.\n * Enriches error-level messages with context annotations and user action replay.\n */\n\nimport { getContextAnnotations } from './context'\nimport { getActionBuffer } from './actions'\n\nexport interface BridgePayload {\n  level?: string\n  message?: string\n  error?: string\n  args?: unknown[]\n  filename?: string\n  lineno?: number\n  [key: string]: unknown\n}\n\n/**\n * Post a log message to the content script\n */\n// #lizard forgives\nexport function postLog(payload: BridgePayload): void {\n  // Include context annotations and action replay for errors\n  const context = getContextAnnotations()\n  const actions = payload.level === 'error' ? getActionBuffer() : null\n\n  // Build enrichments list to help AI understand what data is attached\n  const enrichments: string[] = []\n  if (context && payload.level === 'error') enrichments.push('context')\n  if (actions && actions.length > 0) enrichments.push('userActions')\n\n  // Extract fields we want from payload (exclude ts, message, source, url to avoid overwriting enrichments)\n  const { level, type, args, error, stack, ...otherFields } = payload\n\n  window.postMessage(\n    {\n      type: 'GASOLINE_LOG',\n      payload: {\n        // Enriched fields (these are the source of truth)\n        ts: new Date().toISOString(),\n        url: window.location.href,\n        message:\n          payload.message ||\n          payload.error ||\n          (payload.args?.[0] !== null && payload.args?.[0] !== undefined ? String(payload.args[0]) : ''),\n        source: payload.filename ? `${payload.filename}:${payload.lineno || 0}` : '',\n        // Core fields from payload\n        level,\n        ...(type ? { type } : {}),\n        ...(args ? { args } : {}),\n        ...(error ? { error } : {}),\n        ...(stack ? { stack } : {}),\n        // Optional enrichments\n        ...(enrichments.length > 0 ? { _enrichments: enrichments } : {}),\n        ...(context && payload.level === 'error' ? { _context: context } : {}),\n        ...(actions && actions.length > 0 ? { _actions: actions } : {}),\n        // Any other fields from payload (excluding the ones we destructured)\n        ...otherFields\n      }\n    },\n    window.location.origin\n  )\n}\n", "/**\n * @fileoverview Console method capture.\n * Monkey-patches console.log/warn/error/info/debug to capture messages\n * and forward them via postLog, while preserving original behavior.\n */\n\nimport { safeSerialize } from './serialize'\nimport { postLog } from './bridge'\n\ntype ConsoleMethods = 'log' | 'warn' | 'error' | 'info' | 'debug'\n\n// Store original methods\nlet originalConsole: Partial<Record<ConsoleMethods, (...args: unknown[]) => void>> = {}\n\n/**\n * Install console capture hooks\n */\nexport function installConsoleCapture(): void {\n  const methods: ConsoleMethods[] = ['log', 'warn', 'error', 'info', 'debug']\n\n  methods.forEach((method) => {\n    // eslint-disable-next-line security/detect-object-injection -- method from known-safe local array of console methods\n    originalConsole[method] = console[method]\n\n    // eslint-disable-next-line security/detect-object-injection -- method from known-safe local array of console methods\n    console[method] = function (...args: unknown[]): void {\n      // Post to extension\n      postLog({\n        level: method,\n        type: 'console',\n        args: args.map((arg) => safeSerialize(arg))\n      })\n\n      // Call original\n      // eslint-disable-next-line security/detect-object-injection -- method from known-safe local array of console methods\n      originalConsole[method]!.apply(console, args)\n    }\n  })\n}\n\n/**\n * Uninstall console capture hooks\n */\nexport function uninstallConsoleCapture(): void {\n  Object.keys(originalConsole).forEach((method) => {\n    // eslint-disable-next-line security/detect-object-injection -- method from Object.keys of our own originalConsole storage\n    console[method as ConsoleMethods] = originalConsole[method as ConsoleMethods]!\n  })\n  originalConsole = {}\n}\n", "/**\n * @fileoverview AI-preprocessed error enrichment pipeline.\n * Parses stack traces, resolves source maps, extracts code snippets,\n * detects UI frameworks (React/Vue/Svelte), captures state snapshots,\n * and generates AI-friendly error summaries. All within a timeout guard.\n */\n\nimport type { LogEntry, StackFrame, SourceSnippet, AiContextData, ParsedSourceMap } from '../types/index'\n\nimport {\n  AI_CONTEXT_SNIPPET_LINES,\n  AI_CONTEXT_MAX_LINE_LENGTH,\n  AI_CONTEXT_MAX_SNIPPETS_SIZE,\n  AI_CONTEXT_MAX_ANCESTRY_DEPTH,\n  AI_CONTEXT_MAX_PROP_KEYS,\n  AI_CONTEXT_MAX_STATE_KEYS,\n  AI_CONTEXT_MAX_RELEVANT_SLICE,\n  AI_CONTEXT_MAX_VALUE_LENGTH,\n  AI_CONTEXT_SOURCE_MAP_CACHE_SIZE,\n  AI_CONTEXT_PIPELINE_TIMEOUT_MS\n} from './constants.js'\n\n// =============================================================================\n// TYPE DEFINITIONS\n// =============================================================================\n\n/**\n * Parsed stack frame (internal representation with nullable functionName)\n */\ninterface InternalStackFrame {\n  functionName: string | null\n  filename: string\n  lineno: number\n  colno: number\n}\n\n/**\n * Code snippet line entry\n */\ninterface SnippetLine {\n  line: number\n  text: string\n  isError?: boolean\n}\n\n/**\n * Source snippet with file and line info\n */\ninterface InternalSourceSnippet {\n  file: string\n  line: number\n  snippet: SnippetLine[]\n}\n\n/**\n * Framework detection result\n */\ninterface FrameworkDetection {\n  framework: 'react' | 'vue' | 'svelte'\n  key?: string\n}\n\n/**\n * React component ancestry entry\n */\ninterface ReactComponentEntry {\n  name: string\n  propKeys?: string[]\n  hasState?: boolean\n  stateKeys?: string[]\n}\n\n/**\n * React fiber node (partial typing for what we access)\n */\ninterface ReactFiber {\n  type?:\n    | {\n        displayName?: string\n        name?: string\n      }\n    | string\n  memoizedProps?: Record<string, unknown>\n  memoizedState?: Record<string, unknown> | unknown[] | null\n  return?: ReactFiber | null\n}\n\n/**\n * Component ancestry result\n */\ninterface ComponentAncestryResult {\n  framework: 'react'\n  components: ReactComponentEntry[]\n}\n\n/**\n * Redux store interface\n */\ninterface ReduxStore {\n  getState: () => Record<string, unknown>\n}\n\n/**\n * State snapshot result\n */\ninterface StateSnapshotResult {\n  source: 'redux'\n  keys: Record<string, { type: string }>\n  relevantSlice: Record<string, unknown>\n}\n\n/**\n * AI summary generation data\n */\ninterface AiSummaryData {\n  errorType: string\n  message: string\n  file: string | null\n  line: number | null\n  componentAncestry: ComponentAncestryResult | null\n  stateSnapshot: StateSnapshotResult | null\n}\n\n/**\n * Enriched error entry with AI context\n */\ntype EnrichedErrorEntry = LogEntry & {\n  _aiContext?: AiContextData\n  _enrichments?: string[]\n}\n\n/**\n * Internal AI context result\n */\ninterface InternalAiContext {\n  sourceSnippets?: InternalSourceSnippet[]\n  componentAncestry?: ComponentAncestryResult\n  stateSnapshot?: StateSnapshotResult\n  summary: string\n}\n\n/**\n * Element with framework markers\n */\ninterface FrameworkElement {\n  __vueParentComponent?: unknown\n  __vue_app__?: unknown\n  __svelte_meta?: unknown\n  [key: string]: unknown\n}\n\n// Extend Window interface for Redux store\ndeclare global {\n  interface Window {\n    __REDUX_STORE__?: ReduxStore\n  }\n}\n\n// =============================================================================\n// MODULE STATE\n// =============================================================================\n\n// AI Context state\nlet aiContextEnabled = true\nlet aiContextStateSnapshotEnabled = false\nconst aiSourceMapCache = new Map<string, ParsedSourceMap>()\n\n// =============================================================================\n// STACK FRAME PARSING\n// =============================================================================\n\n/**\n * Parse stack trace into structured frames\n * Supports Chrome and Firefox formats\n * @param stack - The stack trace string\n * @returns Array of frame objects { functionName, filename, lineno, colno }\n */\ntype FrameParser = (line: string) => InternalStackFrame | null\n\nconst CHROME_FRAME_RE = /^at\\s+(?:(.+?)\\s+\\()?(.+?):(\\d+):(\\d+)\\)?$/\nconst FIREFOX_FRAME_RE = /^(.+?)@(.+?):(\\d+):(\\d+)$/\n\nfunction parseChromeFrame(line: string): InternalStackFrame | null {\n  const m = line.match(CHROME_FRAME_RE)\n  if (!m) return null\n  const filename = m[2]\n  if (!filename || filename.includes('<anonymous>')) return null\n  if (!m[3] || !m[4]) return null\n  return { functionName: m[1] || null, filename, lineno: parseInt(m[3], 10), colno: parseInt(m[4], 10) }\n}\n\nfunction parseFirefoxFrame(line: string): InternalStackFrame | null {\n  const m = line.match(FIREFOX_FRAME_RE)\n  if (!m) return null\n  const filename = m[2]\n  if (!filename || filename.includes('<anonymous>')) return null\n  if (!m[3] || !m[4]) return null\n  return { functionName: m[1] || null, filename, lineno: parseInt(m[3], 10), colno: parseInt(m[4], 10) }\n}\n\nconst FRAME_PARSERS: FrameParser[] = [parseChromeFrame, parseFirefoxFrame]\n\nexport function parseStackFrames(stack: string | undefined): InternalStackFrame[] {\n  if (!stack) return []\n\n  const frames: InternalStackFrame[] = []\n  for (const line of stack.split('\\n')) {\n    const trimmed = line.trim()\n    for (const parser of FRAME_PARSERS) {\n      const frame = parser(trimmed)\n      if (frame) {\n        frames.push(frame)\n        break\n      }\n    }\n  }\n  return frames\n}\n\n// =============================================================================\n// SOURCE MAP PARSING\n// =============================================================================\n\n/**\n * Parse an inline base64 source map data URL\n * @param dataUrl - The data: URL containing the source map\n * @returns Parsed source map or null\n */\nexport function parseSourceMap(dataUrl: string | undefined | null): ParsedSourceMap | null {\n  if (!dataUrl || typeof dataUrl !== 'string') return null\n  if (!dataUrl.startsWith('data:')) return null\n\n  try {\n    // Extract base64 content after the last comma\n    const base64Match = dataUrl.match(/;base64,(.+)$/)\n    if (!base64Match || !base64Match[1]) return null\n\n    const decoded = atob(base64Match[1])\n    const parsed = JSON.parse(decoded) as ParsedSourceMap\n\n    // Only useful if it has sourcesContent\n    if (!parsed.sourcesContent || parsed.sourcesContent.length === 0) return null\n\n    return parsed\n  } catch {\n    return null\n  }\n}\n\n// =============================================================================\n// CODE SNIPPET EXTRACTION\n// =============================================================================\n\n/**\n * Extract a code snippet around a given line number\n * @param sourceContent - The full source file content\n * @param line - The 1-based line number of the error\n * @returns Array of { line, text, isError? } or null\n */\nexport function extractSnippet(sourceContent: string | undefined | null, line: number): SnippetLine[] | null {\n  if (!sourceContent || typeof sourceContent !== 'string') return null\n  if (!line || line < 1) return null\n\n  const lines = sourceContent.split('\\n')\n  if (line > lines.length) return null\n\n  const start = Math.max(0, line - 1 - AI_CONTEXT_SNIPPET_LINES)\n  const end = Math.min(lines.length, line + AI_CONTEXT_SNIPPET_LINES)\n\n  const snippet: SnippetLine[] = []\n  for (let i = start; i < end; i++) {\n    let text = lines[i]\n    if (!text) continue\n    if (text.length > AI_CONTEXT_MAX_LINE_LENGTH) {\n      text = text.slice(0, AI_CONTEXT_MAX_LINE_LENGTH)\n    }\n    const entry: SnippetLine = { line: i + 1, text }\n    if (i + 1 === line) entry.isError = true\n    snippet.push(entry)\n  }\n\n  return snippet\n}\n\n/**\n * Source map lookup for extractSourceSnippets\n */\ntype SourceMapLookup = Record<string, ParsedSourceMap>\n\n/**\n * Extract source snippets for multiple stack frames\n * @param frames - Parsed stack frames\n * @param mockSourceMaps - Map of filename to parsed source map\n * @returns Array of snippet objects\n */\nexport async function extractSourceSnippets(\n  frames: InternalStackFrame[],\n  mockSourceMaps: SourceMapLookup\n): Promise<InternalSourceSnippet[]> {\n  // SOURCE MAP CACHING STRATEGY:\n  // This function works with a mockSourceMaps lookup that is pre-populated by\n  // resolveSourceMap(). The caching layer is managed separately via the module-level\n  // aiSourceMapCache Map, which stores up to AI_CONTEXT_SOURCE_MAP_CACHE_SIZE entries\n  // using LRU eviction. When a source map is needed here, it should already be cached\n  // by the MCP observe handler that parsed the HTTP response headers.\n  //\n  // OPTIMIZATION: We only process the top 3 stack frames to limit computation and avoid\n  // redundant snippets. Most stack traces have the root cause in the first 1-3 frames.\n  //\n  // PARSE ERROR HANDLING: If sourcesContent is missing, we skip the frame entirely\n  // rather than erroring. This gracefully handles source maps generated without embedded\n  // sources (which only contain mappings, not code). We never throw here.\n  //\n  // SIZE ENFORCEMENT: Total snippets are capped at AI_CONTEXT_MAX_SNIPPETS_SIZE to prevent\n  // bloating the error entry. Each snippet's JSON serialized size is checked before adding.\n  // This ensures the enriched error entry stays lightweight for AI processing.\n\n  const snippets: InternalSourceSnippet[] = []\n  let totalSize = 0\n\n  for (const frame of frames.slice(0, 3)) {\n    if (totalSize >= AI_CONTEXT_MAX_SNIPPETS_SIZE) break\n\n    const sourceMap = mockSourceMaps[frame.filename]\n    if (!sourceMap || !sourceMap.sourcesContent || !sourceMap.sourcesContent[0]) continue\n\n    const snippet = extractSnippet(sourceMap.sourcesContent[0], frame.lineno)\n    if (!snippet) continue\n\n    const snippetObj: InternalSourceSnippet = { file: frame.filename, line: frame.lineno, snippet }\n    const snippetSize = JSON.stringify(snippetObj).length\n\n    if (totalSize + snippetSize > AI_CONTEXT_MAX_SNIPPETS_SIZE) break\n\n    totalSize += snippetSize\n    snippets.push(snippetObj)\n  }\n\n  return snippets\n}\n\n// =============================================================================\n// FRAMEWORK DETECTION\n// =============================================================================\n\n/**\n * Detect which UI framework an element belongs to\n * @param element - The DOM element (or element-like object)\n * @returns { framework, key? } or null\n */\nexport function detectFramework(element: FrameworkElement | null | undefined): FrameworkDetection | null {\n  if (!element || typeof element !== 'object') return null\n\n  // React: __reactFiber$ or __reactInternalInstance$\n  const keys = Object.keys(element)\n  const reactKey = keys.find((k) => k.startsWith('__reactFiber$') || k.startsWith('__reactInternalInstance$'))\n  if (reactKey) return { framework: 'react', key: reactKey }\n\n  // Vue 3: __vueParentComponent or __vue_app__\n  if (element.__vueParentComponent || element.__vue_app__) {\n    return { framework: 'vue' }\n  }\n\n  // Svelte: __svelte_meta\n  if (element.__svelte_meta) {\n    return { framework: 'svelte' }\n  }\n\n  return null\n}\n\n// =============================================================================\n// REACT COMPONENT ANCESTRY\n// =============================================================================\n\n/**\n * Walk a React fiber tree to extract component ancestry\n * @param fiber - The React fiber node\n * @returns Array of { name, propKeys?, hasState?, stateKeys? } in root-first order\n */\n// #lizard forgives\nexport function getReactComponentAncestry(fiber: ReactFiber | null | undefined): ReactComponentEntry[] | null {\n  if (!fiber) return null\n\n  const ancestry: ReactComponentEntry[] = []\n  let current: ReactFiber | null | undefined = fiber\n  let depth = 0\n\n  while (current && depth < AI_CONTEXT_MAX_ANCESTRY_DEPTH) {\n    depth++\n\n    // Only include component fibers (type is function/object), skip host elements (type is string)\n    if (current.type && typeof current.type !== 'string') {\n      const typeObj = current.type as { displayName?: string; name?: string }\n      const name = typeObj.displayName || typeObj.name || 'Anonymous'\n      const entry: ReactComponentEntry = { name }\n\n      // Extract prop keys (excluding children)\n      if (current.memoizedProps && typeof current.memoizedProps === 'object') {\n        entry.propKeys = Object.keys(current.memoizedProps)\n          .filter((k) => k !== 'children')\n          .slice(0, AI_CONTEXT_MAX_PROP_KEYS)\n      }\n\n      // Extract state keys\n      if (current.memoizedState && typeof current.memoizedState === 'object' && !Array.isArray(current.memoizedState)) {\n        entry.hasState = true\n        entry.stateKeys = Object.keys(current.memoizedState as Record<string, unknown>).slice(\n          0,\n          AI_CONTEXT_MAX_STATE_KEYS\n        )\n      }\n\n      ancestry.push(entry)\n    }\n\n    current = current.return\n  }\n\n  return ancestry.reverse() // Root-first order\n}\n\n// =============================================================================\n// STATE SNAPSHOT\n// =============================================================================\n\n/**\n * Capture application state snapshot from known store patterns\n * @param errorMessage - The error message for keyword matching\n * @returns State snapshot or null\n */\nfunction classifyValueType(value: unknown): string {\n  if (Array.isArray(value)) return 'array'\n  if (value === null) return 'null'\n  return typeof value\n}\n\nconst RELEVANT_STATE_KEYS = ['error', 'loading', 'status', 'failed']\n\n// #lizard forgives\nfunction buildRelevantSlice(state: Record<string, unknown>, errorWords: string[]): Record<string, unknown> {\n  const relevantSlice: Record<string, unknown> = {}\n  let sliceCount = 0\n\n  for (const [key, value] of Object.entries(state)) {\n    if (sliceCount >= AI_CONTEXT_MAX_RELEVANT_SLICE) break\n    if (typeof value !== 'object' || value === null || Array.isArray(value)) continue\n\n    for (const [subKey, subValue] of Object.entries(value as Record<string, unknown>)) {\n      if (sliceCount >= AI_CONTEXT_MAX_RELEVANT_SLICE) break\n      const isRelevantKey = RELEVANT_STATE_KEYS.some((k) => subKey.toLowerCase().includes(k))\n      const isKeywordMatch = errorWords.some((w) => key.toLowerCase().includes(w))\n      if (!isRelevantKey && !isKeywordMatch) continue\n\n      let val: unknown = subValue\n      if (typeof val === 'string' && val.length > AI_CONTEXT_MAX_VALUE_LENGTH) {\n        val = val.slice(0, AI_CONTEXT_MAX_VALUE_LENGTH)\n      }\n      relevantSlice[`${key}.${subKey}`] = val\n      sliceCount++\n    }\n  }\n\n  return relevantSlice\n}\n\n/**\n * Capture application state snapshot from known store patterns.\n *\n * STATE RELEVANCE MATCHING STRATEGY:\n * 1. Extract error keywords from the error message (words > 2 chars).\n * 2. Build a \"relevant slice\" by matching nested state keys against common error state\n *    keys ('error', 'loading', 'status', 'failed') and error message keywords.\n * 3. Caps at AI_CONTEXT_MAX_RELEVANT_SLICE entries; values truncated at MAX_VALUE_LENGTH.\n *\n * NOTE: Only supports Redux. Other state management would need additional window.__* patterns.\n */\nexport function captureStateSnapshot(errorMessage: string): StateSnapshotResult | null {\n  if (typeof window === 'undefined') return null\n\n  try {\n    const store = window.__REDUX_STORE__\n    if (!store || typeof store.getState !== 'function') return null\n\n    const state = store.getState()\n    if (!state || typeof state !== 'object') return null\n\n    const keys: Record<string, { type: string }> = {}\n    for (const [key, value] of Object.entries(state)) {\n      keys[key] = { type: classifyValueType(value) }\n    }\n\n    const errorWords = (errorMessage || '')\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter((w) => w.length > 2)\n    const relevantSlice = buildRelevantSlice(state, errorWords)\n\n    return { source: 'redux', keys, relevantSlice }\n  } catch {\n    return null\n  }\n}\n\n// =============================================================================\n// AI SUMMARY GENERATION\n// =============================================================================\n\n/**\n * Generate a template-based AI summary from enrichment data\n * @param data - { errorType, message, file, line, componentAncestry, stateSnapshot }\n * @returns Summary string\n */\nexport function generateAiSummary(data: AiSummaryData): string {\n  const parts: string[] = []\n\n  // Error type and location\n  if (data.file && data.line) {\n    parts.push(`${data.errorType} in ${data.file}:${data.line} \u2014 ${data.message}`)\n  } else {\n    parts.push(`${data.errorType}: ${data.message}`)\n  }\n\n  // Component context\n  if (data.componentAncestry && data.componentAncestry.components) {\n    const path = data.componentAncestry.components.map((c) => c.name).join(' > ')\n    parts.push(`Component tree: ${path}.`)\n  }\n\n  // State context\n  if (data.stateSnapshot && data.stateSnapshot.relevantSlice) {\n    const sliceKeys = Object.keys(data.stateSnapshot.relevantSlice)\n    if (sliceKeys.length > 0) {\n      const stateInfo = sliceKeys.map((k) => `${k}=${JSON.stringify(data.stateSnapshot!.relevantSlice[k])}`).join(', ') // nosemgrep: no-stringify-keys\n      parts.push(`State: ${stateInfo}.`)\n    }\n  }\n\n  return parts.join(' ')\n}\n\n// =============================================================================\n// ERROR ENRICHMENT PIPELINE\n// =============================================================================\n\n/**\n * Error entry for enrichment (partial typing for what we access)\n */\ninterface ErrorEntryForEnrichment {\n  stack?: string\n  message?: string\n}\n\n/**\n * Full error enrichment pipeline\n * @param error - The error entry to enrich\n * @returns The enriched error entry\n */\n// #lizard forgives\nasync function buildAiContext(error: ErrorEntryForEnrichment): Promise<InternalAiContext> {\n  const result: Partial<InternalAiContext> = {}\n  const frames = parseStackFrames(error.stack)\n\n  if (frames.length === 0) return { summary: error.message || 'Unknown error' }\n  const topFrame = frames[0]\n\n  // Source snippets (from cache)\n  if (topFrame) {\n    const cached = getSourceMapCache(topFrame.filename)\n    if (cached) {\n      const snippets = await extractSourceSnippets(frames, { [topFrame.filename]: cached })\n      if (snippets.length > 0) result.sourceSnippets = snippets\n    }\n  }\n\n  // Component ancestry from activeElement\n  result.componentAncestry = extractComponentAncestry() || undefined\n\n  // State snapshot (if enabled)\n  if (aiContextStateSnapshotEnabled) {\n    const snapshot = captureStateSnapshot(error.message || '')\n    if (snapshot) result.stateSnapshot = snapshot\n  }\n\n  result.summary = generateAiSummary({\n    errorType: error.message?.split(':')[0] || 'Error',\n    message: error.message || '',\n    file: topFrame?.filename || null,\n    line: topFrame?.lineno || null,\n    componentAncestry: result.componentAncestry || null,\n    stateSnapshot: result.stateSnapshot || null\n  })\n\n  return result as InternalAiContext\n}\n\nfunction extractComponentAncestry(): { framework: 'react'; components: ReactComponentEntry[] } | null {\n  if (typeof document === 'undefined' || !document.activeElement) return null\n  const framework = detectFramework(document.activeElement as unknown as FrameworkElement)\n  if (!framework || framework.framework !== 'react' || !framework.key) return null\n  const fiber = (document.activeElement as unknown as Record<string, ReactFiber>)[framework.key]\n  const components = getReactComponentAncestry(fiber)\n  if (!components || components.length === 0) return null\n  return { framework: 'react', components }\n}\n\nfunction applyAiContext(enriched: EnrichedErrorEntry, context: InternalAiContext): void {\n  enriched._aiContext = context as AiContextData\n  if (!enriched._enrichments) enriched._enrichments = []\n  enriched._enrichments.push('aiContext')\n}\n\nexport async function enrichErrorWithAiContext(error: ErrorEntryForEnrichment): Promise<EnrichedErrorEntry> {\n  if (!aiContextEnabled) return error as EnrichedErrorEntry\n\n  const enriched: EnrichedErrorEntry = { ...error } as EnrichedErrorEntry\n\n  try {\n    const context = await Promise.race<InternalAiContext>([\n      buildAiContext(error),\n      new Promise<InternalAiContext>((resolve) => {\n        setTimeout(() => resolve({ summary: `${error.message || 'Error'}` }), AI_CONTEXT_PIPELINE_TIMEOUT_MS)\n      })\n    ])\n    applyAiContext(enriched, context)\n  } catch {\n    applyAiContext(enriched, { summary: error.message || 'Unknown error' })\n  }\n\n  return enriched\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\n/**\n * Enable or disable AI context enrichment\n * @param enabled\n */\nexport function setAiContextEnabled(enabled: boolean): void {\n  aiContextEnabled = enabled\n}\n\n/**\n * Enable or disable state snapshot in AI context\n * @param enabled\n */\nexport function setAiContextStateSnapshot(enabled: boolean): void {\n  aiContextStateSnapshotEnabled = enabled\n}\n\n// =============================================================================\n// SOURCE MAP CACHE\n// =============================================================================\n\n/**\n * Cache a parsed source map for a URL\n * @param url - The script URL\n * @param map - The parsed source map\n */\nexport function setSourceMapCache(url: string, map: ParsedSourceMap): void {\n  // Evict oldest if adding new entry and at capacity\n  if (!aiSourceMapCache.has(url) && aiSourceMapCache.size >= AI_CONTEXT_SOURCE_MAP_CACHE_SIZE) {\n    const firstKey = aiSourceMapCache.keys().next().value\n    if (firstKey) {\n      aiSourceMapCache.delete(firstKey)\n    }\n  }\n  // Move to end (LRU): delete first if exists, then add\n  // This ensures recently accessed/updated entries are kept longest\n  aiSourceMapCache.delete(url)\n  aiSourceMapCache.set(url, map)\n}\n\n/**\n * Get a cached source map\n * @param url - The script URL\n * @returns The cached source map or null\n */\nexport function getSourceMapCache(url: string): ParsedSourceMap | null {\n  return aiSourceMapCache.get(url) || null\n}\n\n/**\n * Get the number of cached source maps\n * @returns\n */\nexport function getSourceMapCacheSize(): number {\n  return aiSourceMapCache.size\n}\n\n/**\n * Reset all module state for testing purposes\n * Clears source map cache and restores default settings.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting(): void {\n  aiContextEnabled = true\n  aiContextStateSnapshotEnabled = false\n  aiSourceMapCache.clear()\n}\n", "/**\n * @fileoverview Exception and unhandled rejection capture.\n * Monkey-patches window.onerror and listens for unhandledrejection events,\n * enriching errors with AI context before posting via bridge.\n */\n\nimport { postLog, type BridgePayload } from './bridge'\nimport { enrichErrorWithAiContext } from './ai-context'\n\ninterface ExceptionEntry extends Record<string, unknown> {\n  level: 'error'\n  type: 'exception'\n  message: string\n  source?: string\n  filename?: string\n  lineno?: number\n  colno?: number\n  stack?: string\n}\n\n// Exception capture state\nlet originalOnerror: OnErrorEventHandler | null = null\nlet unhandledrejectionHandler: ((event: PromiseRejectionEvent) => void) | null = null\n\n/**\n * Install exception capture\n */\nfunction enrichAndPost(entry: ExceptionEntry): void {\n  void (async (): Promise<void> => {\n    try {\n      const enriched = await enrichErrorWithAiContext(entry)\n      postLog(enriched as unknown as BridgePayload)\n    } catch {\n      postLog(entry as unknown as BridgePayload)\n    }\n  })().catch((err: Error) => {\n    console.error('[Gasoline] Exception enrichment error:', err)\n    try {\n      postLog(entry as unknown as BridgePayload)\n    } catch (postErr) {\n      console.error('[Gasoline] Failed to log entry:', postErr)\n    }\n  })\n}\n\nfunction extractRejectionInfo(reason: unknown): { message: string; stack: string } {\n  if (reason instanceof Error) return { message: reason.message, stack: reason.stack || '' }\n  if (typeof reason === 'string') return { message: reason, stack: '' }\n  return { message: String(reason), stack: '' }\n}\n\nexport function installExceptionCapture(): void {\n  originalOnerror = window.onerror\n\n  window.onerror = function (\n    message: string | Event,\n    filename?: string,\n    lineno?: number,\n    colno?: number,\n    error?: Error\n  ): boolean | void {\n    const messageStr = typeof message === 'string' ? message : (message as Event).type || 'Error'\n    const entry: ExceptionEntry = {\n      level: 'error',\n      type: 'exception',\n      message: messageStr,\n      source: filename ? `${filename}:${lineno || 0}` : '',\n      filename: filename || '',\n      lineno: lineno || 0,\n      colno: colno || 0,\n      stack: error?.stack || ''\n    }\n    enrichAndPost(entry)\n    if (originalOnerror) return originalOnerror(message, filename, lineno, colno, error)\n    return false\n  }\n\n  unhandledrejectionHandler = function (event: PromiseRejectionEvent): void {\n    const { message, stack } = extractRejectionInfo(event.reason)\n    enrichAndPost({\n      level: 'error',\n      type: 'exception',\n      message: `Unhandled Promise Rejection: ${message}`,\n      stack\n    })\n  }\n\n  window.addEventListener('unhandledrejection', unhandledrejectionHandler)\n}\n\n/**\n * Uninstall exception capture\n */\nexport function uninstallExceptionCapture(): void {\n  if (originalOnerror !== null) {\n    window.onerror = originalOnerror\n    originalOnerror = null\n  }\n\n  if (unhandledrejectionHandler) {\n    window.removeEventListener('unhandledrejection', unhandledrejectionHandler)\n    unhandledrejectionHandler = null\n  }\n}\n", "/**\n * @fileoverview WebSocket capture.\n * Wraps the WebSocket constructor to intercept lifecycle events and messages,\n * with adaptive sampling, schema detection, and truncation.\n */\n\nimport { WS_MAX_BODY_SIZE, WS_PREVIEW_LIMIT } from './constants.js'\nimport type { WebSocketCaptureMode } from '../types/index'\n\n// Type definitions for WebSocket message data\ntype WebSocketMessageData = string | ArrayBuffer | Blob\n\n// Type for objects with a size property (like Blob)\ninterface SizedObject {\n  size: number\n}\n\n// Connection statistics\ninterface ConnectionStats {\n  incoming: {\n    count: number\n    bytes: number\n    lastPreview: string | null\n    lastAt: number | null\n  }\n  outgoing: {\n    count: number\n    bytes: number\n    lastPreview: string | null\n    lastAt: number | null\n  }\n}\n\n// Direction type\ntype MessageDirection = 'incoming' | 'outgoing'\n\n// Truncation result\ninterface TruncationResult {\n  data: string\n  truncated: boolean\n}\n\n// Sampling info\ninterface SamplingInfo {\n  rate: string\n  logged: string\n  window: string\n}\n\n// Schema info\ninterface SchemaInfo {\n  detectedKeys: string[] | null\n  consistent: boolean\n  variants?: string[]\n}\n\n// Connection tracker interface\nexport interface ConnectionTracker {\n  id: string\n  url: string\n  messageCount: number\n  _sampleCounter: number\n  _messageRate: number\n  _messageTimestamps: number[]\n  _schemaKeys: string[]\n  _schemaVariants: Map<string, number>\n  _schemaConsistent: boolean\n  _schemaDetected: boolean\n  stats: ConnectionStats\n  recordMessage(direction: MessageDirection, data: WebSocketMessageData | null): void\n  shouldSample(direction: MessageDirection): boolean\n  shouldLogLifecycle(): boolean\n  getSamplingInfo(): SamplingInfo\n  getMessageRate(): number\n  setMessageRate(rate: number): void\n  getSchema(): SchemaInfo\n  isSchemaChange(data: string | null): boolean\n}\n\n// Cached TextEncoder instance to avoid per-call allocation in getSize() hot path\nconst _textEncoder: TextEncoder | null = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null\n\n// WebSocket capture state\nlet originalWebSocket: typeof WebSocket | null = null\nlet webSocketCaptureEnabled = true\nlet webSocketCaptureMode: WebSocketCaptureMode = 'medium'\n\n/**\n * Get the byte size of a WebSocket message\n */\n// #lizard forgives\nexport function getSize(data: WebSocketMessageData | SizedObject | null): number {\n  if (typeof data === 'string') {\n    return _textEncoder ? _textEncoder.encode(data).length : data.length\n  }\n  if (data instanceof ArrayBuffer) return data.byteLength\n  if (data && typeof data === 'object' && 'size' in data) return (data as SizedObject).size\n  return 0\n}\n\n/**\n * Format a WebSocket payload for logging\n */\nexport function formatPayload(data: WebSocketMessageData | null): string {\n  if (typeof data === 'string') return data\n\n  if (data instanceof ArrayBuffer) {\n    const bytes = new Uint8Array(data)\n    if (data.byteLength < 256) {\n      // Small binary: hex preview\n      let hex = ''\n      for (let i = 0; i < bytes.length; i++) {\n        const byte = bytes[i]\n        if (byte !== undefined) {\n          hex += byte.toString(16).padStart(2, '0')\n        }\n      }\n      return `[Binary: ${data.byteLength}B] ${hex}`\n    } else {\n      // Large binary: size + magic bytes (first 4 bytes)\n      let magic = ''\n      for (let i = 0; i < Math.min(4, bytes.length); i++) {\n        const byte = bytes[i]\n        if (byte !== undefined) {\n          magic += byte.toString(16).padStart(2, '0')\n        }\n      }\n      return `[Binary: ${data.byteLength}B, magic:${magic}]`\n    }\n  }\n\n  // Blob or Blob-like\n  if (data && typeof data === 'object' && 'size' in data) {\n    return `[Binary: ${(data as SizedObject).size}B]`\n  }\n\n  return String(data)\n}\n\n/**\n * Truncate a WebSocket message to the size limit\n */\n// #lizard forgives\nexport function truncateWsMessage(message: string): TruncationResult {\n  if (typeof message === 'string' && message.length > WS_MAX_BODY_SIZE) {\n    return { data: message.slice(0, WS_MAX_BODY_SIZE), truncated: true }\n  }\n  return { data: message, truncated: false }\n}\n\n/**\n * Create a connection tracker for adaptive sampling and schema detection\n */\n// #lizard forgives\nexport function createConnectionTracker(id: string, url: string): ConnectionTracker {\n  const tracker: ConnectionTracker = {\n    id,\n    url,\n    messageCount: 0,\n    _sampleCounter: 0,\n    _messageRate: 0,\n    _messageTimestamps: [],\n    _schemaKeys: [],\n    _schemaVariants: new Map(),\n    _schemaConsistent: true,\n    _schemaDetected: false,\n\n    stats: {\n      incoming: { count: 0, bytes: 0, lastPreview: null, lastAt: null },\n      outgoing: { count: 0, bytes: 0, lastPreview: null, lastAt: null }\n    },\n\n    /**\n     * Record a message for stats and schema detection\n     *\n     * WEBSOCKET PAYLOAD SCHEMA INFERENCE LOGIC:\n     *\n     * This method implements a three-phase schema detection strategy to identify the\n     * shape of JSON messages flowing over a WebSocket connection. Understanding the\n     * schema is crucial for debugging: it reveals whether messages are uniform (good\n     * for testing) or polymorphic (suggests different message types or errors).\n     *\n     * PHASE 1: BOOTSTRAP DETECTION (messages 1-5)\n     *   Purpose: Quickly infer the \"canonical\" schema from the first JSON messages.\n     *   Strategy:\n     *     - Extract sorted object keys from each incoming JSON message\n     *     - Stop after 5 messages (samples are enough to detect schema; balance between\n     *       coverage and memory/CPU cost)\n     *     - Compute consistency: if all 5 messages have identical key sets, mark as\n     *       consistent=true\n     *     - Store key strings as comma-separated sorted lists (e.g., \"id,status,timestamp\")\n     *   Why 5: Statistically sufficient for most API patterns. First message might be\n     *     special (connection ACK). By message 5, the pattern is clear.\n     *   Early exit: If not JSON or message is array, skip (only track object schemas).\n     *\n     * PHASE 2: CONSISTENCY CHECKING (after first 2 messages)\n     *   Trigger: Once _schemaKeys.length >= 2, begin checking if all keys match the first.\n     *   Result: Sets _schemaConsistent = boolean indicating if messages have uniform schema.\n     *   Why check early: Detect schema changes immediately without waiting for all 5 messages.\n     *   Performance: O(n) single pass over _schemaKeys array; no redundant comparisons.\n     *\n     * PHASE 3: VARIANT TRACKING (messages 6+)\n     *   Purpose: After bootstrap, track schema variants without resetting detection.\n     *   Strategy:\n     *     - Continue parsing incoming JSON messages after _schemaDetected = true\n     *     - Build variants Map: key -> count (e.g., \"id,status\" -> 5 occurrences)\n     *     - Memory bound: Cap Map at 50 entries. Only add new variants if under cap;\n     *       always increment existing keys (ensures frequent patterns stay tracked).\n     *     - This bounds memory to ~50KB even on long-lived connections.\n     *   Why variants matter: Detects polymorphic message types (e.g., \"id,status,data\"\n     *     vs \"id,error,code\"). Useful for debugging API versioning issues.\n     *   Why cap variants: Long-running connections might emit hundreds of unique schemas.\n     *     Capping prevents unbounded growth while keeping the 50 most frequent variants.\n     *\n     * SAMPLING RATE DECISION:\n     *   The schema info (keys, consistency, variants) flows to getSchema() which returns:\n     *     - detectedKeys: union of all seen keys (for understanding message structure)\n     *     - consistent: boolean (true if all bootstrap messages matched)\n     *     - variants: array of key strings (top variants seen after bootstrap)\n     *   MCP observe handler uses this to emit SchemaInfo in WebSocket capture events,\n     *   helping users understand payload patterns without logging every message.\n     *\n     * MESSAGE RATE TRACKING:\n     *   Maintains _messageTimestamps for the last 5 seconds (sliding window). This powers\n     *   shouldSample() which implements adaptive sampling: high-frequency connections\n     *   (>200 msg/s) sample at 1-in-100; low-frequency (<2 msg/s) capture all messages.\n     *   This ensures detailed visibility on slow links without bloating on high-volume.\n     */\n    recordMessage(direction: MessageDirection, data: WebSocketMessageData | null): void {\n      this.messageCount++\n      const size = data ? (typeof data === 'string' ? data.length : getSize(data)) : 0\n      const now = Date.now()\n\n      this.stats[direction].count++\n      this.stats[direction].bytes += size\n      this.stats[direction].lastAt = now\n\n      if (data && typeof data === 'string') {\n        this.stats[direction].lastPreview = data.length > WS_PREVIEW_LIMIT ? data.slice(0, WS_PREVIEW_LIMIT) : data\n      }\n\n      // Track timestamps for rate calculation\n      this._messageTimestamps.push(now)\n      // Keep only last 5 seconds\n      const cutoff = now - 5000\n      this._messageTimestamps = this._messageTimestamps.filter((t) => t >= cutoff)\n\n      // Schema detection from first 5 incoming JSON messages\n      if (direction === 'incoming' && data && typeof data === 'string' && this._schemaKeys.length < 5) {\n        try {\n          const parsed: unknown = JSON.parse(data)\n          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n            const keys = Object.keys(parsed as object).sort()\n            const keyStr = keys.join(',')\n            this._schemaKeys.push(keyStr)\n\n            // Track variants\n            this._schemaVariants.set(keyStr, (this._schemaVariants.get(keyStr) || 0) + 1)\n\n            // Check consistency after 2+ messages\n            if (this._schemaKeys.length >= 2) {\n              const first = this._schemaKeys[0]\n              this._schemaConsistent = this._schemaKeys.every((k) => k === first)\n            }\n\n            if (this._schemaKeys.length >= 5) {\n              this._schemaDetected = true\n            }\n          }\n        } catch {\n          // Not JSON, no schema\n        }\n      }\n\n      // Track variants for messages beyond the first 5 (cap at 50 to bound memory)\n      if (direction === 'incoming' && data && typeof data === 'string' && this._schemaDetected) {\n        try {\n          const parsed: unknown = JSON.parse(data)\n          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n            const keys = Object.keys(parsed as object).sort()\n            const keyStr = keys.join(',')\n            // Only add new variants if under cap; always increment existing\n            if (this._schemaVariants.has(keyStr) || this._schemaVariants.size < 50) {\n              this._schemaVariants.set(keyStr, (this._schemaVariants.get(keyStr) || 0) + 1)\n            }\n          }\n        } catch {\n          // Not JSON\n        }\n      }\n    },\n\n    /**\n     * Determine if a message should be sampled (logged)\n     */\n    shouldSample(_direction: MessageDirection): boolean {\n      this._sampleCounter++\n\n      // 'all' mode: no sampling\n      if (webSocketCaptureMode === 'all') return true\n\n      // Always log first 5 messages on a connection\n      if (this.messageCount > 0 && this.messageCount <= 5) return true\n\n      const rate = this._messageRate || this.getMessageRate()\n\n      // Mode-based target caps:\n      // 'high': ~10 msg/s, 'medium': ~5 msg/s, 'low': ~2 msg/s\n      const targetRate = webSocketCaptureMode === 'high' ? 10 : webSocketCaptureMode === 'medium' ? 5 : 2\n\n      if (rate <= targetRate) return true\n\n      const n = Math.max(1, Math.round(rate / targetRate))\n      return this._sampleCounter % n === 0\n    },\n\n    /**\n     * Lifecycle events should always be logged\n     */\n    shouldLogLifecycle(): boolean {\n      return true\n    },\n\n    /**\n     * Get sampling info\n     */\n    getSamplingInfo(): SamplingInfo {\n      const rate = this._messageRate || this.getMessageRate()\n      let targetRate = rate\n      if (rate >= 10 && rate < 50) targetRate = 10\n      else if (rate >= 50 && rate < 200) targetRate = 5\n      else if (rate >= 200) targetRate = 2\n\n      return {\n        rate: `${rate}/s`,\n        logged: `${targetRate}/${Math.round(rate)}`,\n        window: '5s'\n      }\n    },\n\n    /**\n     * Get the current message rate (messages per second)\n     */\n    getMessageRate(): number {\n      if (this._messageTimestamps.length < 2) return this._messageTimestamps.length\n      const lastTime = this._messageTimestamps[this._messageTimestamps.length - 1]\n      const firstTime = this._messageTimestamps[0]\n      if (lastTime === undefined || firstTime === undefined) return this._messageTimestamps.length\n      const window = (lastTime - firstTime) / 1000\n      return window > 0 ? this._messageTimestamps.length / window : this._messageTimestamps.length\n    },\n\n    /**\n     * Set the message rate manually (for testing)\n     */\n    setMessageRate(rate: number): void {\n      this._messageRate = rate\n    },\n\n    /**\n     * Get the detected schema info\n     */\n    getSchema(): SchemaInfo {\n      if (this._schemaKeys.length === 0) {\n        return { detectedKeys: null, consistent: true }\n      }\n\n      // Get union of all detected keys\n      const allKeys = new Set<string>()\n      for (const keyStr of this._schemaKeys) {\n        for (const k of keyStr.split(',')) {\n          if (k) allKeys.add(k)\n        }\n      }\n\n      // Build variants list\n      const variants: string[] = []\n      for (const [keyStr, count] of this._schemaVariants) {\n        if (count > 0) variants.push(keyStr)\n      }\n\n      return {\n        detectedKeys: allKeys.size > 0 ? Array.from(allKeys).sort() : null,\n        consistent: this._schemaConsistent,\n        variants: variants.length > 1 ? variants : undefined\n      }\n    },\n\n    /**\n     * Check if a message represents a schema change\n     */\n    isSchemaChange(data: string | null): boolean {\n      if (!this._schemaDetected || !data || typeof data !== 'string') return false\n      try {\n        const parsed: unknown = JSON.parse(data)\n        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) return false\n        const keys = Object.keys(parsed as object)\n          .sort()\n          .join(',')\n        // It's a change if none of the first 5 schemas match\n        return !this._schemaKeys.includes(keys)\n      } catch {\n        return false\n      }\n    }\n  }\n\n  return tracker\n}\n\n// WebSocket event payload type\ninterface WsEventPayload {\n  type: 'websocket'\n  event: string\n  id: string\n  url: string\n  ts: string\n  code?: number\n  reason?: string\n  direction?: 'incoming' | 'outgoing'\n  data?: string\n  size?: number\n  truncated?: boolean\n}\n\n// PostMessage payload type\ninterface GasolineWsMessage {\n  type: 'GASOLINE_WS'\n  payload: WsEventPayload\n}\n\n/**\n * Install WebSocket capture by wrapping the WebSocket constructor.\n * If the early-patch script ran first (world: \"MAIN\", document_start),\n * uses the saved original constructor and adopts buffered connections.\n */\nexport function installWebSocketCapture(): void {\n  if (typeof window === 'undefined') return\n  if (!window.WebSocket) return // No WebSocket support\n  if (originalWebSocket) return // Already installed\n  webSocketCaptureEnabled = true // Ensure capture is enabled when installing\n\n  // Check for early-patch: use the saved original, not the early-patch wrapper\n  const earlyOriginal = window.__GASOLINE_ORIGINAL_WS__\n  originalWebSocket = earlyOriginal || window.WebSocket\n\n  const OriginalWS = originalWebSocket\n\n  function GasolineWebSocket(this: WebSocket, url: string | URL, protocols?: string | string[]): WebSocket {\n    const ws = new OriginalWS(url, protocols)\n    const connectionId = crypto.randomUUID()\n    const urlString = url.toString()\n    const tracker = createConnectionTracker(connectionId, urlString)\n\n    ws.addEventListener('open', () => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: { type: 'websocket', event: 'open', id: connectionId, url: urlString, ts: new Date().toISOString() }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    ws.addEventListener('close', (event: CloseEvent) => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'close',\n            id: connectionId,\n            url: urlString,\n            code: event.code,\n            reason: event.reason,\n            ts: new Date().toISOString()\n          }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    ws.addEventListener('error', () => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'error',\n            id: connectionId,\n            url: urlString,\n            ts: new Date().toISOString()\n          }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    ws.addEventListener('message', (event: MessageEvent<WebSocketMessageData>) => {\n      if (!webSocketCaptureEnabled) return\n      tracker.recordMessage('incoming', event.data)\n      if (!tracker.shouldSample('incoming')) return\n\n      const data = event.data\n      const size = getSize(data)\n      const formatted = formatPayload(data)\n      const { data: truncatedData, truncated } = truncateWsMessage(formatted)\n\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'message',\n            id: connectionId,\n            url: urlString,\n            direction: 'incoming',\n            data: truncatedData,\n            size,\n            truncated: truncated || undefined,\n            ts: new Date().toISOString()\n          }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    // Wrap send() to capture outgoing messages\n    const originalSend = ws.send.bind(ws)\n    ws.send = function (data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n      if (webSocketCaptureEnabled) {\n        tracker.recordMessage('outgoing', data as WebSocketMessageData)\n      }\n      if (webSocketCaptureEnabled && tracker.shouldSample('outgoing')) {\n        const size = getSize(data as WebSocketMessageData)\n        const formatted = formatPayload(data as WebSocketMessageData)\n        const { data: truncatedData, truncated } = truncateWsMessage(formatted)\n\n        window.postMessage(\n          {\n            type: 'GASOLINE_WS',\n            payload: {\n              type: 'websocket',\n              event: 'message',\n              id: connectionId,\n              url: urlString,\n              direction: 'outgoing',\n              data: truncatedData,\n              size,\n              truncated: truncated || undefined,\n              ts: new Date().toISOString()\n            }\n          } as GasolineWsMessage,\n          window.location.origin\n        )\n      }\n\n      return originalSend(data)\n    }\n\n    return ws\n  }\n\n  // Set up prototype chain and static properties\n  GasolineWebSocket.prototype = OriginalWS.prototype\n  Object.defineProperty(GasolineWebSocket, 'CONNECTING', { value: OriginalWS.CONNECTING, writable: false })\n  Object.defineProperty(GasolineWebSocket, 'OPEN', { value: OriginalWS.OPEN, writable: false })\n  Object.defineProperty(GasolineWebSocket, 'CLOSING', { value: OriginalWS.CLOSING, writable: false })\n  Object.defineProperty(GasolineWebSocket, 'CLOSED', { value: OriginalWS.CLOSED, writable: false })\n\n  window.WebSocket = GasolineWebSocket as unknown as typeof WebSocket\n\n  // Adopt connections buffered by the early-patch script\n  adoptEarlyConnections()\n}\n\n/**\n * Adopt WebSocket connections buffered by the early-patch script.\n * For each still-active connection, creates a tracker and attaches event listeners\n * so ongoing messages are captured. Posts synthetic \"open\" events for connections\n * that opened before the inject script loaded.\n */\nfunction adoptEarlyConnections(): void {\n  const earlyConnections = window.__GASOLINE_EARLY_WS__\n  if (!earlyConnections || earlyConnections.length === 0) {\n    // Clean up globals even if no connections\n    delete window.__GASOLINE_ORIGINAL_WS__\n    delete window.__GASOLINE_EARLY_WS__\n    return\n  }\n\n  let adopted = 0\n\n  for (const conn of earlyConnections) {\n    const ws = conn.ws\n\n    // Skip fully closed connections\n    if (ws.readyState === WebSocket.CLOSED) continue\n\n    adopted++\n    const connectionId = crypto.randomUUID()\n    const urlString = conn.url\n    const tracker = createConnectionTracker(connectionId, urlString)\n\n    // Post synthetic \"open\" event for connections that already opened\n    const hasOpened = conn.events.some((e) => e.type === 'open')\n    if (hasOpened && webSocketCaptureEnabled) {\n      const openEvent = conn.events.find((e) => e.type === 'open')\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'open',\n            id: connectionId,\n            url: urlString,\n            ts: openEvent ? new Date(openEvent.ts).toISOString() : new Date().toISOString()\n          }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    }\n\n    // Attach ongoing capture: close\n    ws.addEventListener('close', (event: CloseEvent) => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'close',\n            id: connectionId,\n            url: urlString,\n            code: event.code,\n            reason: event.reason,\n            ts: new Date().toISOString()\n          }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    // Attach ongoing capture: error\n    ws.addEventListener('error', () => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: { type: 'websocket', event: 'error', id: connectionId, url: urlString, ts: new Date().toISOString() }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    // Attach ongoing capture: incoming messages\n    ws.addEventListener('message', (event: MessageEvent<WebSocketMessageData>) => {\n      if (!webSocketCaptureEnabled) return\n      tracker.recordMessage('incoming', event.data)\n      if (!tracker.shouldSample('incoming')) return\n\n      const data = event.data\n      const size = getSize(data)\n      const formatted = formatPayload(data)\n      const { data: truncatedData, truncated } = truncateWsMessage(formatted)\n\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'message',\n            id: connectionId,\n            url: urlString,\n            direction: 'incoming' as const,\n            data: truncatedData,\n            size,\n            truncated: truncated || undefined,\n            ts: new Date().toISOString()\n          }\n        } as GasolineWsMessage,\n        window.location.origin\n      )\n    })\n\n    // Wrap send() for outgoing capture\n    const originalSend = ws.send.bind(ws)\n    ws.send = function (data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n      if (webSocketCaptureEnabled) {\n        tracker.recordMessage('outgoing', data as WebSocketMessageData)\n      }\n      if (webSocketCaptureEnabled && tracker.shouldSample('outgoing')) {\n        const size = getSize(data as WebSocketMessageData)\n        const formatted = formatPayload(data as WebSocketMessageData)\n        const { data: truncatedData, truncated } = truncateWsMessage(formatted)\n\n        window.postMessage(\n          {\n            type: 'GASOLINE_WS',\n            payload: {\n              type: 'websocket',\n              event: 'message',\n              id: connectionId,\n              url: urlString,\n              direction: 'outgoing' as const,\n              data: truncatedData,\n              size,\n              truncated: truncated || undefined,\n              ts: new Date().toISOString()\n            }\n          } as GasolineWsMessage,\n          window.location.origin\n        )\n      }\n\n      return originalSend(data)\n    }\n  }\n\n  if (adopted > 0) {\n    console.log(`[Gasoline] Adopted ${adopted} early WebSocket connection(s)`)\n  }\n\n  // Clean up early-patch globals\n  delete window.__GASOLINE_ORIGINAL_WS__\n  delete window.__GASOLINE_EARLY_WS__\n}\n\n/**\n * Set the WebSocket capture mode\n */\nexport function setWebSocketCaptureMode(mode: WebSocketCaptureMode): void {\n  webSocketCaptureMode = mode\n}\n\n/**\n * Set WebSocket capture enabled state\n */\nexport function setWebSocketCaptureEnabled(enabled: boolean): void {\n  webSocketCaptureEnabled = enabled\n}\n\n/**\n * Get the current WebSocket capture mode\n */\nexport function getWebSocketCaptureMode(): WebSocketCaptureMode {\n  return webSocketCaptureMode\n}\n\n/**\n * Uninstall WebSocket capture, restoring the original constructor\n */\nexport function uninstallWebSocketCapture(): void {\n  if (typeof window === 'undefined') return\n  if (originalWebSocket) {\n    window.WebSocket = originalWebSocket\n    originalWebSocket = null\n  }\n}\n\n/**\n * Reset all module state for testing purposes\n * Restores original WebSocket if installed, resets capture settings to defaults.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting(): void {\n  uninstallWebSocketCapture()\n  webSocketCaptureEnabled = false\n  webSocketCaptureMode = 'medium'\n  originalWebSocket = null\n  // Clean up early-patch globals if present\n  if (typeof window !== 'undefined') {\n    delete window.__GASOLINE_ORIGINAL_WS__\n    delete window.__GASOLINE_EARLY_WS__\n  }\n}\n", "/**\n * @fileoverview On-demand DOM queries.\n * Provides structured DOM querying, page info extraction, and\n * accessibility auditing via axe-core.\n */\n\nimport {\n  DOM_QUERY_MAX_ELEMENTS,\n  DOM_QUERY_MAX_TEXT,\n  DOM_QUERY_MAX_DEPTH,\n  DOM_QUERY_MAX_HTML,\n  A11Y_MAX_NODES_PER_VIOLATION,\n  A11Y_AUDIT_TIMEOUT_MS\n} from './constants.js'\nimport { scaleTimeout } from './timeouts'\n\n// DOM query parameters\nexport interface DOMQueryParams {\n  selector: string\n  include_styles?: boolean\n  properties?: string[]\n  include_children?: boolean\n  max_depth?: number\n}\n\n// Bounding box type\ninterface BoundingBox {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\n// Serialized DOM element entry\ninterface DOMElementEntry {\n  tag: string\n  text: string\n  visible: boolean\n  attributes?: Record<string, string>\n  boundingBox?: BoundingBox\n  styles?: Record<string, string>\n  children?: DOMElementEntry[]\n}\n\n// DOM query result\ninterface DOMQueryResult {\n  url: string\n  title: string\n  matchCount: number\n  returnedCount: number\n  matches: DOMElementEntry[]\n}\n\n// Page info result\ninterface PageInfoResult {\n  url: string\n  title: string\n  viewport: { width: number; height: number }\n  scroll: { x: number; y: number }\n  documentHeight: number\n  headings: string[]\n  links: number\n  images: number\n  interactiveElements: number\n  forms: FormInfo[]\n}\n\n// Form info\ninterface FormInfo {\n  id?: string\n  action?: string\n  fields: string[]\n}\n\n// Axe audit parameters\ninterface AxeAuditParams {\n  scope?: string\n  tags?: string[]\n  include_passes?: boolean\n}\n\n// Formatted axe node\ninterface FormattedAxeNode {\n  selector: string\n  html: string\n  failureSummary?: string\n}\n\n// Formatted axe violation\ninterface FormattedAxeViolation {\n  id: string\n  impact?: string\n  description: string\n  helpUrl: string\n  wcag?: string[]\n  nodes: FormattedAxeNode[]\n  nodeCount?: number\n}\n\n// Formatted axe results\ninterface FormattedAxeResults {\n  violations: FormattedAxeViolation[]\n  summary: {\n    violations: number\n    passes: number\n    incomplete: number\n    inapplicable: number\n  }\n  error?: string\n}\n\n// Axe-core types (minimal for our usage)\ninterface AxeNode {\n  target: string[] | string\n  html?: string\n  failureSummary?: string\n}\n\ninterface AxeViolation {\n  id: string\n  impact?: string\n  description: string\n  helpUrl: string\n  tags?: string[]\n  nodes?: AxeNode[]\n}\n\ninterface AxeResults {\n  violations?: AxeViolation[]\n  passes?: AxeViolation[]\n  incomplete?: AxeViolation[]\n  inapplicable?: AxeViolation[]\n}\n\ninterface AxeRunConfig {\n  runOnly?: string[]\n  resultTypes?: string[]\n}\n\n// Declare axe on window\ndeclare global {\n  interface Window {\n    axe?: {\n      run(context: Element | Document | { include: string[] }, config?: AxeRunConfig): Promise<AxeResults>\n    }\n  }\n}\n\n/**\n * Execute a DOM query and return structured results\n */\nexport async function executeDOMQuery(params: DOMQueryParams): Promise<DOMQueryResult> {\n  const { selector, include_styles, properties, include_children, max_depth } = params\n\n  const elements = document.querySelectorAll(selector)\n  const matchCount = elements.length\n  const cappedDepth = Math.min(max_depth || 3, DOM_QUERY_MAX_DEPTH)\n\n  const matches: DOMElementEntry[] = []\n  for (let i = 0; i < Math.min(elements.length, DOM_QUERY_MAX_ELEMENTS); i++) {\n    const el = elements[i]\n    if (!el) continue\n    const entry = serializeDOMElement(el, include_styles, properties, include_children, cappedDepth, 0)\n    matches.push(entry)\n  }\n\n  return {\n    url: window.location.href,\n    title: document.title,\n    matchCount,\n    returnedCount: matches.length,\n    matches\n  }\n}\n\n/**\n * Collect all attributes from an element into a plain object.\n */\nfunction collectAttributes(el: Element): Record<string, string> | undefined {\n  if (!el.attributes || el.attributes.length === 0) return undefined\n  const attrs: Record<string, string> = {}\n  for (const attr of el.attributes) {\n    attrs[attr.name] = attr.value\n  }\n  return attrs\n}\n\n/**\n * Get the bounding box of an element, or undefined if unavailable.\n */\nfunction collectBoundingBox(el: Element): BoundingBox | undefined {\n  if (!el.getBoundingClientRect) return undefined\n  const rect = el.getBoundingClientRect()\n  return { x: rect.x, y: rect.y, width: rect.width, height: rect.height }\n}\n\n/**\n * Get computed styles for an element, either specific properties or defaults.\n */\nfunction collectStyles(\n  el: Element,\n  includeStyles: boolean | undefined,\n  styleProps: string[] | undefined\n): Record<string, string> | undefined {\n  if (!includeStyles || typeof window.getComputedStyle !== 'function') return undefined\n  const computed = window.getComputedStyle(el)\n  if (styleProps && styleProps.length > 0) {\n    const styles: Record<string, string> = {}\n    for (const prop of styleProps) {\n      styles[prop] = computed.getPropertyValue(prop)\n    }\n    return styles\n  }\n  return { display: computed.display, color: computed.color, position: computed.position }\n}\n\n/**\n * Serialize child elements recursively up to maxDepth.\n */\n// #lizard forgives\nfunction collectChildren(\n  el: Element,\n  includeChildren: boolean | undefined,\n  maxDepth: number,\n  currentDepth: number\n): DOMElementEntry[] | undefined {\n  if (!includeChildren || currentDepth >= maxDepth || !el.children || el.children.length === 0) return undefined\n  const children: DOMElementEntry[] = []\n  const maxChildren = Math.min(el.children.length, DOM_QUERY_MAX_ELEMENTS)\n  for (let i = 0; i < maxChildren; i++) {\n    const child = el.children[i]\n    if (child) {\n      children.push(serializeDOMElement(child, false, undefined, true, maxDepth, currentDepth + 1))\n    }\n  }\n  return children\n}\n\n/**\n * Serialize a DOM element to a plain object\n */\nfunction serializeDOMElement(\n  el: Element,\n  includeStyles: boolean | undefined,\n  styleProps: string[] | undefined,\n  includeChildren: boolean | undefined,\n  maxDepth: number,\n  currentDepth: number\n): DOMElementEntry {\n  const entry: DOMElementEntry = {\n    tag: el.tagName ? el.tagName.toLowerCase() : '',\n    text: (el.textContent || '').slice(0, DOM_QUERY_MAX_TEXT),\n    visible:\n      (el as HTMLElement).offsetParent !== null || (el.getBoundingClientRect && el.getBoundingClientRect().width > 0)\n  }\n\n  entry.attributes = collectAttributes(el)\n  entry.boundingBox = collectBoundingBox(el)\n  entry.styles = collectStyles(el, includeStyles, styleProps)\n  entry.children = collectChildren(el, includeChildren, maxDepth, currentDepth)\n\n  return entry\n}\n\n/**\n * Get comprehensive page info\n */\nexport async function getPageInfo(): Promise<PageInfoResult> {\n  const headings: string[] = []\n  const headingEls = document.querySelectorAll('h1,h2,h3,h4,h5,h6')\n  for (const h of headingEls) {\n    headings.push((h.textContent || '').slice(0, DOM_QUERY_MAX_TEXT))\n  }\n\n  const forms: FormInfo[] = []\n  const formEls = document.querySelectorAll('form')\n  for (const form of formEls) {\n    const fields: string[] = []\n    const inputs = form.querySelectorAll('input,select,textarea')\n    for (const input of inputs) {\n      const inputEl = input as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n      if (inputEl.name) fields.push(inputEl.name)\n    }\n    forms.push({\n      id: form.id || undefined,\n      action: form.action || undefined,\n      fields\n    })\n  }\n\n  return {\n    url: window.location.href,\n    title: document.title,\n    viewport: { width: window.innerWidth, height: window.innerHeight },\n    scroll: { x: window.scrollX, y: window.scrollY },\n    documentHeight: document.documentElement.scrollHeight,\n    headings,\n    links: document.querySelectorAll('a').length,\n    images: document.querySelectorAll('img').length,\n    interactiveElements: document.querySelectorAll('button,input,select,textarea,a[href]').length,\n    forms\n  }\n}\n\n/**\n * Load axe-core dynamically if not already present.\n *\n * IMPORTANT: axe-core MUST be loaded from the bundled local copy (lib/axe.min.js).\n * Chrome Web Store policy prohibits loading remotely hosted code. All third-party\n * libraries must be bundled with the extension package.\n */\nfunction loadAxeCore(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (window.axe) {\n      resolve()\n      return\n    }\n\n    // Wait for axe-core to be injected by content script (which has chrome.runtime API access)\n    // Note: This function runs in page context (inject script), so we can't call chrome.runtime.getURL()\n    const checkInterval = setInterval(() => {\n      if (window.axe) {\n        clearInterval(checkInterval)\n        resolve()\n      }\n    }, scaleTimeout(100))\n\n    // Timeout after 5 seconds\n    setTimeout(() => {\n      clearInterval(checkInterval)\n      reject(\n        new Error(\n          'Accessibility audit failed: axe-core library not loaded (5s timeout). The extension content script may not have been injected on this page. Try reloading the tab and re-running the audit.'\n        )\n      )\n    }, scaleTimeout(5000))\n  })\n}\n\n/**\n * Run an accessibility audit using axe-core\n */\nexport async function runAxeAudit(params: AxeAuditParams): Promise<FormattedAxeResults> {\n  await loadAxeCore()\n\n  const context: Element | Document | { include: string[] } = params.scope ? { include: [params.scope] } : document\n  const config: AxeRunConfig = {}\n\n  if (params.tags && params.tags.length > 0) {\n    config.runOnly = params.tags\n  }\n\n  if (params.include_passes) {\n    config.resultTypes = ['violations', 'passes', 'incomplete', 'inapplicable']\n  } else {\n    config.resultTypes = ['violations', 'incomplete']\n  }\n\n  const results = await window.axe!.run(context, config)\n  return formatAxeResults(results)\n}\n\n/**\n * Run axe audit with a timeout\n */\nexport async function runAxeAuditWithTimeout(\n  params: AxeAuditParams,\n  timeoutMs: number = A11Y_AUDIT_TIMEOUT_MS\n): Promise<FormattedAxeResults> {\n  return Promise.race([\n    runAxeAudit(params),\n    new Promise<FormattedAxeResults>((resolve) => {\n      setTimeout(\n        () =>\n          resolve({\n            violations: [],\n            summary: { violations: 0, passes: 0, incomplete: 0, inapplicable: 0 },\n            error: 'Accessibility audit timeout'\n          }),\n        timeoutMs\n      )\n    })\n  ])\n}\n\n/**\n * Format axe-core results into a compact representation\n */\nexport function formatAxeResults(axeResult: AxeResults): FormattedAxeResults {\n  const formatViolation = (v: AxeViolation): FormattedAxeViolation => {\n    const formatted: FormattedAxeViolation = {\n      id: v.id,\n      impact: v.impact,\n      description: v.description,\n      helpUrl: v.helpUrl,\n      nodes: []\n    }\n\n    // Extract WCAG tags\n    if (v.tags) {\n      formatted.wcag = v.tags.filter((t) => t.startsWith('wcag'))\n    }\n\n    // Format nodes (cap at 10)\n    formatted.nodes = (v.nodes || []).slice(0, A11Y_MAX_NODES_PER_VIOLATION).map((node) => {\n      const selector = Array.isArray(node.target) ? node.target[0] : node.target\n      return {\n        selector: selector || '',\n        html: (node.html || '').slice(0, DOM_QUERY_MAX_HTML),\n        ...(node.failureSummary ? { failureSummary: node.failureSummary } : {})\n      }\n    })\n\n    if (v.nodes && v.nodes.length > A11Y_MAX_NODES_PER_VIOLATION) {\n      formatted.nodeCount = v.nodes.length\n    }\n\n    return formatted\n  }\n\n  return {\n    violations: (axeResult.violations || []).map(formatViolation),\n    summary: {\n      violations: (axeResult.violations || []).length,\n      passes: (axeResult.passes || []).length,\n      incomplete: (axeResult.incomplete || []).length,\n      inapplicable: (axeResult.inapplicable || []).length\n    }\n  }\n}\n", "/**\n * @fileoverview Gasoline API - Exposes window.__gasoline interface for developers\n * to interact with Gasoline capture capabilities.\n */\n\ndeclare const __GASOLINE_VERSION__: string\n\nimport type {\n  LogEntry,\n  ActionEntry,\n  EnhancedAction,\n  SelectorStrategies,\n  WaterfallEntry,\n  PerformanceMark,\n  PerformanceMeasure\n} from '../types/index'\n\nimport {\n  setContextAnnotation,\n  removeContextAnnotation,\n  clearContextAnnotations,\n  getContextAnnotations\n} from '../lib/context'\nimport {\n  computeSelectors,\n  recordEnhancedAction,\n  getEnhancedActionBuffer,\n  clearEnhancedActionBuffer,\n  generatePlaywrightScript\n} from '../lib/reproduction'\nimport { getActionBuffer, clearActionBuffer, setActionCaptureEnabled } from '../lib/actions'\nimport { getNetworkWaterfall, setNetworkWaterfallEnabled } from '../lib/network'\nimport { getPerformanceMarks, getPerformanceMeasures, setPerformanceMarksEnabled } from '../lib/performance'\nimport { enrichErrorWithAiContext, setAiContextEnabled, setAiContextStateSnapshot } from '../lib/ai-context'\n\n/**\n * GasolineAPI interface exposed on window.__gasoline\n */\nexport interface GasolineAPI {\n  annotate(key: string, value: unknown): void\n  removeAnnotation(key: string): void\n  clearAnnotations(): void\n  getContext(): Record<string, unknown> | null\n  getActions(): ActionEntry[]\n  clearActions(): void\n  setActionCapture(enabled: boolean): void\n  setNetworkWaterfall(enabled: boolean): void\n  getNetworkWaterfall(options?: { since?: number; initiatorTypes?: string[] }): WaterfallEntry[]\n  setPerformanceMarks(enabled: boolean): void\n  getMarks(options?: { since?: number }): PerformanceMark[]\n  getMeasures(options?: { since?: number }): PerformanceMeasure[]\n  enrichError(error: LogEntry): Promise<LogEntry>\n  setAiContext(enabled: boolean): void\n  setStateSnapshot(enabled: boolean): void\n  recordAction(type: string, element: Element, opts?: Record<string, unknown>): void\n  getEnhancedActions(): EnhancedAction[]\n  clearEnhancedActions(): void\n  generateScript(opts?: Record<string, unknown>): string\n  getSelectors(element: Element): SelectorStrategies\n  setInputValue(selector: string, value: string | boolean): boolean\n  version: string\n}\n\n// Extend Window interface for __gasoline\ndeclare global {\n  interface Window {\n    __gasoline?: GasolineAPI\n  }\n}\n\nfunction setWithNativeSetter<T extends HTMLElement>(\n  element: T,\n  proto: { prototype: T },\n  prop: string,\n  val: string | boolean\n): void {\n  const setter = Object.getOwnPropertyDescriptor(proto.prototype, prop)?.set\n  if (setter) setter.call(element, val)\n  else (element as unknown as Record<string, string | boolean>)[prop] = val\n}\n\n/** Use native property setter to set value on form elements, bypassing framework interception */\nfunction setNativeValue(element: Element, value: string | boolean): boolean {\n  if (element instanceof HTMLInputElement) {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      setWithNativeSetter(element, HTMLInputElement, 'checked', Boolean(value))\n    } else {\n      setWithNativeSetter(element, HTMLInputElement, 'value', String(value))\n    }\n    return true\n  }\n  if (element instanceof HTMLTextAreaElement) {\n    setWithNativeSetter(element, HTMLTextAreaElement, 'value', String(value))\n    return true\n  }\n  if (element instanceof HTMLSelectElement) {\n    setWithNativeSetter(element, HTMLSelectElement, 'value', String(value))\n    return true\n  }\n  return false\n}\n\n/**\n * Install the window.__gasoline API for developers to interact with Gasoline\n */\n// #lizard forgives\nexport function installGasolineAPI(): void {\n  if (typeof window === 'undefined') return\n\n  window.__gasoline = {\n    /**\n     * Add a context annotation that will be included with errors\n     * @param key - Annotation key (e.g., 'checkout-flow', 'user')\n     * @param value - Annotation value\n     * @example\n     * window.__gasoline.annotate('checkout-flow', { step: 'payment', items: 3 })\n     */\n    annotate(key: string, value: unknown): boolean {\n      return setContextAnnotation(key, value)\n    },\n\n    /**\n     * Remove a context annotation\n     * @param key - Annotation key to remove\n     */\n    removeAnnotation(key: string): boolean {\n      return removeContextAnnotation(key)\n    },\n\n    /**\n     * Clear all context annotations\n     */\n    clearAnnotations(): void {\n      clearContextAnnotations()\n    },\n\n    /**\n     * Get current context annotations\n     * @returns Current annotations or null if none\n     */\n    getContext(): Record<string, unknown> | null {\n      return getContextAnnotations()\n    },\n\n    /**\n     * Get the user action replay buffer\n     * @returns Recent user actions\n     */\n    getActions(): ActionEntry[] {\n      return getActionBuffer() as unknown as ActionEntry[]\n    },\n\n    /**\n     * Clear the user action replay buffer\n     */\n    clearActions(): void {\n      clearActionBuffer()\n    },\n\n    /**\n     * Enable or disable action capture\n     * @param enabled - Whether to capture user actions\n     */\n    setActionCapture(enabled: boolean): void {\n      setActionCaptureEnabled(enabled)\n    },\n\n    /**\n     * Enable or disable network waterfall capture\n     * @param enabled - Whether to capture network waterfall\n     */\n    setNetworkWaterfall(enabled: boolean): void {\n      setNetworkWaterfallEnabled(enabled)\n    },\n\n    /**\n     * Get current network waterfall\n     * @param options - Filter options\n     * @returns Network waterfall entries\n     */\n    getNetworkWaterfall(options?: { since?: number; initiatorTypes?: string[] }): WaterfallEntry[] {\n      return getNetworkWaterfall(options)\n    },\n\n    /**\n     * Enable or disable performance marks capture\n     * @param enabled - Whether to capture performance marks\n     */\n    setPerformanceMarks(enabled: boolean): void {\n      setPerformanceMarksEnabled(enabled)\n    },\n\n    /**\n     * Get performance marks\n     * @param options - Filter options\n     * @returns Performance mark entries\n     */\n    getMarks(options?: { since?: number }): PerformanceMark[] {\n      return getPerformanceMarks(options) as unknown as PerformanceMark[]\n    },\n\n    /**\n     * Get performance measures\n     * @param options - Filter options\n     * @returns Performance measure entries\n     */\n    getMeasures(options?: { since?: number }): PerformanceMeasure[] {\n      return getPerformanceMeasures(options) as unknown as PerformanceMeasure[]\n    },\n\n    // === AI Context ===\n\n    /**\n     * Enrich an error entry with AI context\n     * @param error - Error entry to enrich\n     * @returns Enriched error entry\n     */\n    enrichError(error: LogEntry): Promise<LogEntry> {\n      // enrichErrorWithAiContext expects ErrorEntryForEnrichment which is compatible with LogEntry\n      // The return type EnrichedErrorEntry extends LogEntry, so we can safely cast\n      return enrichErrorWithAiContext(error as { stack?: string; message?: string }) as Promise<LogEntry>\n    },\n\n    /**\n     * Enable or disable AI context enrichment\n     * @param enabled\n     */\n    setAiContext(enabled: boolean): void {\n      setAiContextEnabled(enabled)\n    },\n\n    /**\n     * Enable or disable state snapshot in AI context\n     * @param enabled\n     */\n    setStateSnapshot(enabled: boolean): void {\n      setAiContextStateSnapshot(enabled)\n    },\n\n    // === Reproduction Scripts ===\n\n    /**\n     * Record an enhanced action (for testing)\n     * @param type - Action type (click, input, keypress, navigate, select, scroll)\n     * @param element - Target element\n     * @param opts - Options\n     */\n    recordAction(\n      type: 'click' | 'input' | 'keypress' | 'navigate' | 'select' | 'scroll',\n      element: Element,\n      opts?: Record<string, unknown>\n    ): void {\n      recordEnhancedAction(type, element, opts)\n    },\n\n    /**\n     * Get the enhanced action buffer\n     * @returns\n     */\n    getEnhancedActions(): EnhancedAction[] {\n      return getEnhancedActionBuffer() as unknown as EnhancedAction[]\n    },\n\n    /**\n     * Clear the enhanced action buffer\n     */\n    clearEnhancedActions(): void {\n      clearEnhancedActionBuffer()\n    },\n\n    /**\n     * Generate a Playwright reproduction script\n     * @param opts - Generation options\n     * @returns Playwright test script\n     */\n    generateScript(opts?: Record<string, unknown>): string {\n      // Uses the internal enhanced action buffer which is populated by recordEnhancedAction\n      return generatePlaywrightScript(getEnhancedActionBuffer(), opts)\n    },\n\n    /**\n     * Compute multi-strategy selectors for an element\n     * @param element\n     * @returns\n     */\n    getSelectors(element: Element): SelectorStrategies {\n      return computeSelectors(element) as unknown as SelectorStrategies\n    },\n\n    /**\n     * Set input value and trigger React/Vue/Svelte change events\n     * Works with frameworks that track form state internally by dispatching\n     * the events that frameworks listen for.\n     *\n     * @param selector - CSS selector for the input element\n     * @param value - Value to set (string for text inputs, boolean for checkboxes)\n     * @returns true if successful, false if element not found\n     *\n     * @example\n     * // Text input\n     * window.__gasoline.setInputValue('input[name=\"email\"]', 'test@example.com')\n     *\n     * // Checkbox\n     * window.__gasoline.setInputValue('input[type=\"checkbox\"]', true)\n     *\n     * // Select dropdown\n     * window.__gasoline.setInputValue('select[name=\"country\"]', 'US')\n     */\n    setInputValue(selector: string, value: string | boolean): boolean {\n      const element = document.querySelector(selector)\n      if (!element) {\n        console.error('[Gasoline] Element not found:', selector)\n        return false\n      }\n\n      try {\n        if (!setNativeValue(element, value)) {\n          console.error('[Gasoline] Element is not a form input:', selector)\n          return false\n        }\n\n        // Dispatch events that React/Vue/Svelte listen for\n        element.dispatchEvent(new Event('input', { bubbles: true }))\n        element.dispatchEvent(new Event('change', { bubbles: true }))\n        element.dispatchEvent(new Event('blur', { bubbles: true }))\n        return true\n      } catch (err) {\n        console.error('[Gasoline] Failed to set input value:', err)\n        return false\n      }\n    },\n\n    /**\n     * Version of the Gasoline API\n     */\n    version: __GASOLINE_VERSION__\n  }\n}\n\n/**\n * Uninstall the window.__gasoline API\n */\nexport function uninstallGasolineAPI(): void {\n  if (typeof window !== 'undefined' && window.__gasoline) {\n    delete window.__gasoline\n  }\n}\n", "/**\n * @fileoverview Observers - Observer registration and management for DOM, network,\n * performance, and WebSocket events.\n */\n\nimport { installPerformanceCapture, uninstallPerformanceCapture, setPerformanceMarksEnabled } from '../lib/performance'\nimport { installPerfObservers } from '../lib/perf-snapshot'\nimport {\n  installWebSocketCapture,\n  setWebSocketCaptureMode,\n  setWebSocketCaptureEnabled,\n  uninstallWebSocketCapture\n} from '../lib/websocket'\nimport {\n  setNetworkWaterfallEnabled,\n  setNetworkBodyCaptureEnabled,\n  setServerUrl,\n  wrapFetchWithBodies\n} from '../lib/network'\nimport { installConsoleCapture, uninstallConsoleCapture } from '../lib/console'\nimport { installExceptionCapture, uninstallExceptionCapture } from '../lib/exceptions'\nimport {\n  installActionCapture,\n  uninstallActionCapture,\n  installNavigationCapture,\n  uninstallNavigationCapture\n} from '../lib/actions'\nimport { postLog } from '../lib/bridge'\nimport { MAX_RESPONSE_LENGTH, SENSITIVE_HEADERS, MEMORY_SOFT_LIMIT_MB, MEMORY_HARD_LIMIT_MB } from '../lib/constants'\nimport { createDeferredPromise } from '../lib/timeout-utils'\n\n// Store original fetch for restoration\nlet originalFetch: typeof fetch | null = null\n\n// Interception deferral state (Phase 1/Phase 2 split)\nlet deferralEnabled = true\nlet phase2Installed = false\nlet injectionTimestamp = 0\nlet phase2Timestamp = 0\n\n/**\n * Network error log payload\n */\ninterface NetworkErrorLog {\n  level: 'error'\n  type: 'network'\n  method: string\n  url: string\n  status?: number\n  statusText?: string\n  duration: number\n  response?: string\n  error?: string\n  headers?: Record<string, string>\n  [key: string]: unknown\n}\n\n/**\n * Wrap fetch to capture network errors\n */\n// #lizard forgives\nexport function wrapFetch(originalFetchFn: typeof fetch): typeof fetch {\n  // #lizard forgives\n  return async function (input: RequestInfo | URL, init?: RequestInit): Promise<Response> {\n    const startTime = Date.now()\n    const url = typeof input === 'string' ? input : (input as Request).url\n    const method =\n      init?.method || (typeof input === 'object' && 'method' in input ? (input as Request).method : 'GET') || 'GET'\n\n    try {\n      const response = await originalFetchFn(input, init)\n      const duration = Date.now() - startTime\n\n      // Capture errors (4xx, 5xx)\n      if (!response.ok) {\n        let responseBody = ''\n        try {\n          const cloned = response.clone()\n          responseBody = await cloned.text()\n          if (responseBody.length > MAX_RESPONSE_LENGTH) {\n            responseBody = responseBody.slice(0, MAX_RESPONSE_LENGTH) + '... [truncated]'\n          }\n        } catch {\n          responseBody = '[Could not read response]'\n        }\n\n        // Filter sensitive headers (check both init.headers and Request object headers)\n        const safeHeaders: Record<string, string> = {}\n        const rawHeaders =\n          init?.headers || (typeof input === 'object' && 'headers' in input ? (input as Request).headers : null)\n        if (rawHeaders) {\n          const headers: Record<string, string> =\n            rawHeaders instanceof Headers ? Object.fromEntries(rawHeaders) : (rawHeaders as Record<string, string>)\n          Object.keys(headers).forEach((key) => {\n            const value = headers[key]\n            if (value && !SENSITIVE_HEADERS.includes(key.toLowerCase())) {\n              safeHeaders[key] = value\n            }\n          })\n        }\n\n        const logPayload: NetworkErrorLog = {\n          level: 'error',\n          type: 'network',\n          method: method.toUpperCase(),\n          url,\n          status: response.status,\n          statusText: response.statusText,\n          duration,\n          response: responseBody,\n          ...(Object.keys(safeHeaders).length > 0 ? { headers: safeHeaders } : {})\n        }\n\n        postLog(logPayload)\n      }\n\n      return response\n    } catch (error) {\n      const duration = Date.now() - startTime\n\n      // Filter sensitive headers for the error path\n      const safeHeaders: Record<string, string> = {}\n      const rawHeaders =\n        init?.headers || (typeof input === 'object' && 'headers' in input ? (input as Request).headers : null)\n      if (rawHeaders) {\n        const headers: Record<string, string> =\n          rawHeaders instanceof Headers ? Object.fromEntries(rawHeaders) : (rawHeaders as Record<string, string>)\n        Object.keys(headers).forEach((key) => {\n          const value = headers[key]\n          if (value && !SENSITIVE_HEADERS.includes(key.toLowerCase())) {\n            safeHeaders[key] = value\n          }\n        })\n      }\n\n      const logPayload: NetworkErrorLog = {\n        level: 'error',\n        type: 'network',\n        method: method.toUpperCase(),\n        url,\n        error: (error as Error).message,\n        duration,\n        ...(Object.keys(safeHeaders).length > 0 ? { headers: safeHeaders } : {})\n      }\n\n      postLog(logPayload)\n\n      throw error\n    }\n  }\n}\n\n/**\n * Install fetch capture.\n * Uses wrapFetchWithBodies to capture request/response bodies for all requests,\n * then wraps that with wrapFetch to also capture error details for 4xx/5xx responses.\n */\nexport function installFetchCapture(): void {\n  originalFetch = window.fetch\n  // Layer 1: wrapFetchWithBodies captures request/response bodies for ALL requests\n  // Layer 2: wrapFetch captures detailed error logging for 4xx/5xx responses\n  // Use unknown intermediate cast to handle TypeScript's strict fetch overload types\n  // This is necessary because the DOM lib defines fetch with multiple overloads\n  // that TypeScript cannot reconcile with our simpler function signature\n  const wrappedWithBodies = wrapFetchWithBodies(originalFetch as unknown as Parameters<typeof wrapFetchWithBodies>[0])\n  window.fetch = wrapFetch(wrappedWithBodies as unknown as typeof window.fetch)\n}\n\n/**\n * Uninstall fetch capture\n */\nexport function uninstallFetchCapture(): void {\n  if (originalFetch) {\n    window.fetch = originalFetch\n    originalFetch = null\n  }\n}\n\n/**\n * Install all capture hooks\n */\nexport function install(): void {\n  installConsoleCapture()\n  installFetchCapture()\n  installExceptionCapture()\n  installActionCapture()\n  installNavigationCapture()\n  installWebSocketCapture()\n  installPerformanceCapture()\n}\n\n/**\n * Uninstall all capture hooks\n */\nexport function uninstall(): void {\n  uninstallConsoleCapture()\n  uninstallFetchCapture()\n  uninstallExceptionCapture()\n  uninstallActionCapture()\n  uninstallNavigationCapture()\n  uninstallWebSocketCapture()\n  uninstallPerformanceCapture()\n}\n\n/**\n * Check if heavy intercepts should be deferred until page load\n */\nexport function shouldDeferIntercepts(): boolean {\n  if (typeof document === 'undefined') return false\n  return document.readyState === 'loading'\n}\n\n/**\n * Memory pressure check state\n */\ninterface MemoryPressureState {\n  memoryUsageMB: number\n  networkBodiesEnabled: boolean\n  wsBufferCapacity: number\n  networkBufferCapacity: number\n}\n\n/**\n * Check memory pressure and adjust buffer capacities\n */\nexport function checkMemoryPressure(state: MemoryPressureState): MemoryPressureState {\n  const result = { ...state }\n\n  if (state.memoryUsageMB >= MEMORY_HARD_LIMIT_MB) {\n    // Hard limit: disable network bodies\n    result.networkBodiesEnabled = false\n    result.wsBufferCapacity = Math.floor(state.wsBufferCapacity * 0.25)\n    result.networkBufferCapacity = Math.floor(state.networkBufferCapacity * 0.25)\n  } else if (state.memoryUsageMB >= MEMORY_SOFT_LIMIT_MB) {\n    // Soft limit: reduce buffers\n    result.wsBufferCapacity = Math.floor(state.wsBufferCapacity * 0.5)\n    result.networkBufferCapacity = Math.floor(state.networkBufferCapacity * 0.5)\n  }\n\n  return result\n}\n\n/**\n * Phase 1 (Immediate): Lightweight, non-intercepting setup.\n */\nexport function installPhase1(): void {\n  console.log('[Gasoline] Phase 1 installing (lightweight API + perf observers)')\n  injectionTimestamp = performance.now()\n  phase2Installed = false\n  phase2Timestamp = 0\n\n  // Start PerformanceObservers (passive observers, no prototype modification)\n  installPerformanceCapture()\n\n  // Now handle Phase 2 scheduling\n  if (!deferralEnabled) {\n    // Deferral disabled: install Phase 2 immediately\n    installPhase2()\n  } else {\n    const installDeferred = (): void => {\n      if (!phase2Installed) setTimeout(installPhase2, 100)\n    }\n    if (document.readyState === 'complete') {\n      // Page already loaded, defer by 100ms\n      installDeferred()\n    } else {\n      // Wait for load event, then defer by 100ms\n      window.addEventListener('load', installDeferred, { once: true })\n      // 10-second timeout fallback\n      setTimeout(() => {\n        if (!phase2Installed) installPhase2()\n      }, 10000)\n    }\n  }\n}\n\n/**\n * Phase 2 (Deferred): Heavy interceptors.\n */\nexport function installPhase2(): void {\n  // Double-injection guard\n  if (phase2Installed) return\n\n  // Environment guard\n  if (typeof window === 'undefined' || typeof document === 'undefined') return\n\n  console.log('[Gasoline] Phase 2 installing (heavy interceptors: console, fetch, WS, errors, actions)')\n  phase2Timestamp = performance.now()\n  phase2Installed = true\n\n  // Install all heavy interceptors\n  install()\n\n  // FCP/LCP/CLS/INP/long-task observers (buffered: true replays pre-Phase-2 entries)\n  installPerfObservers()\n}\n\n/**\n * Get the current deferral state for diagnostics and testing.\n */\nexport interface DeferralState {\n  deferralEnabled: boolean\n  phase2Installed: boolean\n  injectionTimestamp: number\n  phase2Timestamp: number\n}\n\nexport function getDeferralState(): DeferralState {\n  return {\n    deferralEnabled,\n    phase2Installed,\n    injectionTimestamp,\n    phase2Timestamp\n  }\n}\n\n/**\n * Set whether interception deferral is enabled.\n */\nexport function setDeferralEnabled(enabled: boolean): void {\n  deferralEnabled = enabled\n}\n", "/**\n * @fileoverview Timeout and Promise utilities - Reusable patterns for handling timeouts,\n * promise races, and message-based async operations with cleanup.\n *\n * These utilities extract common patterns found throughout the Gasoline extension:\n * - Promise.race with timeout fallback\n * - Message-based request/response with timeout and cleanup\n * - Deferred promises for storing resolvers/rejecters\n * - Safe timeout management with resource cleanup\n */\n\n/**\n * Deferred Promise - Holds resolve/reject callbacks for external resolution\n * Useful for resolving a promise from outside async/await context\n * @template T The type of the resolved value\n */\nexport interface DeferredPromise<T> {\n  promise: Promise<T>\n  resolve: (value: T | PromiseLike<T>) => void\n  reject: (reason?: unknown) => void\n}\n\n/**\n * Create a deferred promise\n * @template T The type of the resolved value\n * @returns Deferred promise with resolve/reject methods\n *\n * @example\n * const deferred = createDeferredPromise<number>();\n * setTimeout(() => deferred.resolve(42), 100);\n * const result = await deferred.promise; // 42\n */\nexport function createDeferredPromise<T>(): DeferredPromise<T> {\n  let resolve!: (value: T | PromiseLike<T>) => void\n  let reject!: (reason?: unknown) => void\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n\n  return { promise, resolve, reject }\n}\n\n/**\n * Wrap a promise with a timeout fallback\n * Returns the result of the promise if it resolves before timeout,\n * otherwise returns the fallback value (or rejects if no fallback)\n *\n * @template T The type of the promise value\n * @param promise The promise to wrap\n * @param timeoutMs Timeout in milliseconds\n * @param fallback Optional fallback value to return on timeout\n * @returns Promise that resolves to the result or fallback (or rejects on timeout if no fallback)\n *\n * @example\n * // With fallback value\n * const result = await withTimeout(fetch('/api'), 5000, { ok: false });\n *\n * @example\n * // Without fallback (rejects on timeout)\n * try {\n *   const result = await withTimeout(slowOperation(), 3000);\n * } catch (err) {\n *   // Handle timeout\n * }\n */\nexport async function withTimeout<T>(promise: Promise<T>, timeoutMs: number, fallback?: T): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      setTimeout(() => {\n        if (fallback !== undefined) {\n          reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, fallback as T))\n        } else {\n          reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`))\n        }\n      }, timeoutMs)\n    })\n  ]).catch((err) => {\n    if (err instanceof TimeoutError && err.fallback !== undefined) {\n      return err.fallback as T\n    }\n    throw err\n  })\n}\n\n/**\n * Custom error for timeout operations that optionally carries a fallback value\n */\nexport class TimeoutError extends Error {\n  constructor(\n    message: string,\n    public fallback?: unknown\n  ) {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Wrap a promise with a timeout that rejects on timeout\n * This is a stricter version of withTimeout - no fallback allowed\n *\n * @template T The type of the promise value\n * @param promise The promise to wrap\n * @param timeoutMs Timeout in milliseconds\n * @returns Promise that resolves to the result or rejects on timeout\n *\n * @example\n * try {\n *   const data = await promiseWithTimeout(fetchData(), 5000);\n * } catch (err) {\n *   if (err instanceof TimeoutError) {\n *     console.error('Request timed out');\n *   }\n * }\n */\nexport async function promiseWithTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      setTimeout(() => {\n        reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`))\n      }, timeoutMs)\n    })\n  ])\n}\n\n/**\n * Message-based async operation with timeout and cleanup\n * Manages request/response correlation using a Map and IDs, with automatic cleanup\n *\n * This pattern is used extensively in content.ts for:\n * - Highlight requests (30s timeout)\n * - Execute JS requests (30s timeout)\n * - A11y audit requests (30s timeout)\n * - DOM query requests (30s timeout)\n * - Network waterfall requests (5s timeout)\n *\n * @template T The type of the response value\n * @param sender Function that sends the message/request\n * @param timeoutMs Timeout in milliseconds\n * @param cleanup Optional cleanup function called on timeout (e.g., to remove event listeners)\n * @returns Promise that resolves to the response or rejects on timeout\n *\n * @example\n * // Simple message send with timeout\n * const response = await messageWithTimeout(\n *   async () => chrome.runtime.sendMessage({ type: 'PING' }),\n *   5000\n * );\n *\n * @example\n * // With event listener cleanup\n * const response = await messageWithTimeout(\n *   async () => {\n *     const requestId = ++requestIdCounter;\n *     pendingRequests.set(requestId, (result) => deferred.resolve(result));\n *     window.postMessage({ type: 'REQUEST', requestId }, origin);\n *     return deferred.promise;\n *   },\n *   30000,\n *   () => {\n *     pendingRequests.delete(requestId);\n *     window.removeEventListener('message', handler);\n *   }\n * );\n */\nexport async function messageWithTimeout<T>(\n  sender: () => Promise<T>,\n  timeoutMs: number,\n  cleanup?: () => void\n): Promise<T> {\n  const timeoutHandle = setTimeout(() => {\n    cleanup?.()\n  }, timeoutMs)\n\n  try {\n    return await promiseWithTimeout(sender(), timeoutMs)\n  } finally {\n    clearTimeout(timeoutHandle)\n  }\n}\n\n/**\n * Race a promise against a timeout, calling a cleanup function if timeout wins\n * Used for operations that set up listeners or other resources that need cleanup\n *\n * @template T The type of the promise value\n * @param promise The promise to race against timeout\n * @param timeoutMs Timeout in milliseconds\n * @param timeoutFallback Value to return on timeout (if provided, doesn't throw)\n * @param cleanup Function to call if timeout occurs\n * @returns Promise that resolves to result, fallback (if provided), or rejects\n *\n * @example\n * const result = await promiseRaceWithCleanup(\n *   waitForResponse(),\n *   5000,\n *   { entries: [] }, // fallback for timeout\n *   () => removeEventListener('message', handler) // cleanup\n * );\n */\nexport async function promiseRaceWithCleanup<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutFallback: T | undefined,\n  cleanup?: () => void\n): Promise<T> {\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((_, reject) => {\n        setTimeout(() => {\n          cleanup?.()\n          if (timeoutFallback !== undefined) {\n            reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, timeoutFallback))\n          } else {\n            reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`))\n          }\n        }, timeoutMs)\n      })\n    ])\n  } catch (err) {\n    if (err instanceof TimeoutError && err.fallback !== undefined) {\n      return err.fallback as T\n    }\n    throw err\n  }\n}\n\n/**\n * Execute a callback with automatic timeout and fallback\n * The callback should return a promise that resolves with the result\n *\n * @template T The type of the result\n * @param callback Function that returns a promise\n * @param timeoutMs Timeout in milliseconds\n * @param fallback Optional fallback value to return on timeout\n * @returns Promise that resolves to the result, fallback, or rejects\n *\n * @example\n * const result = await executeWithTimeout(\n *   () => fetch('/api/data'),\n *   5000,\n *   { ok: false, status: 408 } // fallback\n * );\n */\nexport async function executeWithTimeout<T>(callback: () => Promise<T>, timeoutMs: number, fallback?: T): Promise<T> {\n  return withTimeout(callback(), timeoutMs, fallback)\n}\n\n/**\n * Create a promise that resolves after a delay\n * Useful for retry logic or deferring operations\n *\n * @param delayMs Delay in milliseconds\n * @returns Promise that resolves after the delay\n *\n * @example\n * await delay(1000); // Wait 1 second\n */\nexport function delay(delayMs: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, delayMs)\n  })\n}\n\n/**\n * Retry a promise-returning function with exponential backoff\n * Useful for flaky operations like network requests\n *\n * @template T The type of the result\n * @param fn Function that returns a promise\n * @param maxAttempts Maximum number of attempts\n * @param initialDelayMs Initial delay before first retry (doubles each attempt)\n * @returns Promise that resolves if any attempt succeeds, or rejects if all fail\n *\n * @example\n * const result = await retryWithBackoff(\n *   () => fetch('/api/data'),\n *   3,\n *   100\n * );\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxAttempts: number = 3,\n  initialDelayMs: number = 100\n): Promise<T> {\n  let lastError: unknown\n\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await fn()\n    } catch (err) {\n      lastError = err\n      if (attempt < maxAttempts - 1) {\n        const delayMs = initialDelayMs * Math.pow(2, attempt)\n        await delay(delayMs)\n      }\n    }\n  }\n\n  throw lastError\n}\n\n/**\n * Create a cancellable promise that can be aborted\n * @template T The type of the result\n * @param promise The promise to wrap\n * @param operationName Optional human-readable name of the operation for error messages\n * @returns Object with the promise and a cancel function\n *\n * @example\n * const { promise, cancel } = makeCancellable(fetch('/api/data'), 'fetch user data');\n * setTimeout(() => cancel(), 5000);\n * try {\n *   const result = await promise;\n * } catch (err) {\n *   if (err.message.includes('cancelled')) {\n *     console.log('Operation was cancelled:', err.message);\n *   }\n * }\n */\nexport function makeCancellable<T>(\n  promise: Promise<T>,\n  operationName?: string\n): {\n  promise: Promise<T>\n  cancel: () => void\n} {\n  let cancelled = false\n  let rejectFn: (reason?: unknown) => void\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    rejectFn = reject\n    promise\n      .then((value) => {\n        if (!cancelled) {\n          resolve(value)\n        }\n      })\n      .catch((err) => {\n        if (!cancelled) {\n          reject(err)\n        }\n      })\n  })\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      cancelled = true\n      const msg = operationName ? `Operation cancelled: ${operationName}` : 'cancelled'\n      rejectFn(new Error(msg))\n    }\n  }\n}\n\n/**\n * Wait for a condition to become true or timeout\n * Polls at regular intervals until condition is true or timeout occurs\n *\n * @param condition Function that returns true when condition is met\n * @param timeoutMs Maximum time to wait in milliseconds\n * @param pollIntervalMs How often to check the condition (default 100ms)\n * @returns Promise that resolves if condition becomes true, rejects on timeout\n *\n * @example\n * await waitFor(() => element.classList.contains('visible'), 5000);\n */\nexport async function waitFor(\n  condition: () => boolean,\n  timeoutMs: number,\n  pollIntervalMs: number = 100\n): Promise<void> {\n  const startTime = Date.now()\n\n  return new Promise((resolve, reject) => {\n    const check = (): void => {\n      if (condition()) {\n        resolve()\n      } else if (Date.now() - startTime > timeoutMs) {\n        reject(new TimeoutError(`Condition not met within ${timeoutMs}ms`))\n      } else {\n        setTimeout(check, pollIntervalMs)\n      }\n    }\n\n    check()\n  })\n}\n\n/**\n * Race multiple promises and return the result of the first one that settles\n * (resolves or rejects). This differs from Promise.race in that it includes\n * rejection reasons.\n *\n * @template T The type of the result\n * @param promises Promises to race\n * @returns Promise that settles with the result of the first settling promise\n *\n * @example\n * const result = await racePromises([\n *   fetch('/api/data'),\n *   delay(5000).then(() => { throw new TimeoutError('Too slow'); })\n * ]);\n */\nexport async function racePromises<T>(promises: Promise<T>[]): Promise<T> {\n  if (promises.length === 0) {\n    throw new Error('racePromises requires at least one promise')\n  }\n\n  return Promise.race(promises)\n}\n\n/**\n * Combine multiple timeout utilities: execute a callback with timeout,\n * automatic cleanup on timeout, and optional fallback\n *\n * @template T The type of the result\n * @param callback Callback that returns a promise\n * @param timeoutMs Timeout in milliseconds\n * @param fallback Optional fallback value on timeout\n * @param cleanup Optional cleanup function called on timeout\n * @returns Promise that resolves to result, fallback, or rejects\n *\n * @example\n * const result = await executeWithTimeoutAndCleanup(\n *   async () => {\n *     const requestId = generateId();\n *     window.addEventListener('message', handler);\n *     window.postMessage({ type: 'REQUEST', requestId });\n *     return deferred.promise;\n *   },\n *   5000,\n *   { success: false },\n *   () => window.removeEventListener('message', handler)\n * );\n */\nexport async function executeWithTimeoutAndCleanup<T>(\n  callback: () => Promise<T>,\n  timeoutMs: number,\n  fallback?: T,\n  cleanup?: () => void\n): Promise<T> {\n  let timeoutHandle: ReturnType<typeof setTimeout> | null = null\n\n  try {\n    return await new Promise<T>((resolve, reject) => {\n      timeoutHandle = setTimeout(() => {\n        cleanup?.()\n        if (fallback !== undefined) {\n          resolve(fallback)\n        } else {\n          reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`))\n        }\n      }, timeoutMs)\n\n      callback()\n        .then((result) => {\n          if (timeoutHandle !== null) {\n            clearTimeout(timeoutHandle)\n          }\n          resolve(result)\n        })\n        .catch((err) => {\n          if (timeoutHandle !== null) {\n            clearTimeout(timeoutHandle)\n          }\n          reject(err)\n        })\n    })\n  } catch (err) {\n    if (timeoutHandle !== null) {\n      clearTimeout(timeoutHandle)\n    }\n    throw err\n  }\n}\n", "/**\n * @fileoverview Link Health Checker\n * Extracts all links from the current page and checks their health.\n * Categorizes issues as: ok (2xx), redirect (3xx), requires_auth (401/403),\n * broken (4xx/5xx), timeout, or cors_blocked.\n *\n * Fallback chain for each link:\n *   1. HEAD request (fast, minimal bandwidth)\n *   2. GET request  (fallback when HEAD returns 405 or status 0)\n *   3. no-cors GET  (for cross-origin links: proves server reachability)\n */\n\nexport interface LinkHealthParams {\n  readonly timeout_ms?: number\n  readonly max_workers?: number\n}\n\nexport interface LinkCheckResult {\n  readonly url: string\n  readonly status: number | null\n  readonly code: 'ok' | 'redirect' | 'requires_auth' | 'broken' | 'timeout' | 'cors_blocked'\n  readonly timeMs: number\n  readonly isExternal: boolean\n  readonly redirectTo?: string\n  readonly error?: string\n  readonly needsServerVerification?: boolean\n}\n\nexport interface LinkHealthCheckResult {\n  readonly summary: {\n    readonly totalLinks: number\n    readonly ok: number\n    readonly redirect: number\n    readonly requiresAuth: number\n    readonly broken: number\n    readonly timeout: number\n    readonly corsBlocked: number\n    readonly needsServerVerification: number\n  }\n  readonly results: LinkCheckResult[]\n}\n\n/**\n * Check all links on the current page for health issues.\n * Extracts links, deduplicates, and checks max 20 concurrently.\n */\nfunction extractUniqueLinks(): string[] {\n  const linkElements = document.querySelectorAll('a[href]')\n  const urls = new Set<string>()\n  for (const elem of linkElements) {\n    const href = (elem as HTMLAnchorElement).href\n    if (href && !isIgnoredLink(href)) urls.add(href)\n  }\n  return Array.from(urls)\n}\n\nfunction aggregateResults(results: LinkCheckResult[]): LinkHealthCheckResult['summary'] {\n  const summary = {\n    totalLinks: results.length,\n    ok: 0,\n    redirect: 0,\n    requiresAuth: 0,\n    broken: 0,\n    timeout: 0,\n    corsBlocked: 0,\n    needsServerVerification: 0\n  }\n  const codeToField: Record<string, keyof typeof summary> = {\n    ok: 'ok',\n    redirect: 'redirect',\n    requires_auth: 'requiresAuth',\n    broken: 'broken',\n    timeout: 'timeout',\n    cors_blocked: 'corsBlocked'\n  }\n  for (const result of results) {\n    const field = codeToField[result.code]\n    if (field) summary[field]++\n    if (result.code === 'cors_blocked' && result.needsServerVerification) summary.needsServerVerification++\n  }\n  return summary\n}\n\nexport async function checkLinkHealth(params: LinkHealthParams): Promise<LinkHealthCheckResult> {\n  const timeout_ms = params.timeout_ms || 15000\n  const max_workers = params.max_workers || 20\n  const uniqueLinks = extractUniqueLinks()\n\n  const results: LinkCheckResult[] = []\n  const chunks = chunkArray(uniqueLinks, max_workers)\n  for (const chunk of chunks) {\n    const batchResults = await Promise.allSettled(chunk.map((url) => checkLink(url, timeout_ms)))\n    for (const result of batchResults) {\n      if (result.status === 'fulfilled' && result.value) results.push(result.value)\n    }\n  }\n\n  return { summary: aggregateResults(results), results }\n}\n\n/**\n * Classify an HTTP status code into a link health category.\n */\nfunction classifyStatus(status: number): LinkCheckResult['code'] {\n  if (status >= 200 && status < 300) return 'ok'\n  if (status >= 300 && status < 400) return 'redirect'\n  if (status === 401 || status === 403) return 'requires_auth'\n  return 'broken'\n}\n\n/**\n * Returns true if the status indicates we should retry with GET.\n * 405 = Method Not Allowed (server rejects HEAD).\n * 0   = opaque/CORS-blocked response (no readable status).\n */\nfunction shouldFallbackToGet(status: number): boolean {\n  return status === 405 || status === 0\n}\n\n/**\n * Returns true if the error looks like a CORS or network failure (not a timeout).\n */\nfunction isCorsOrNetworkError(error: Error): boolean {\n  return error.name === 'TypeError'\n}\n\n/**\n * Try a no-cors GET as a last resort to check if the server is reachable.\n * An opaque response (status 0, type \"opaque\") proves the server is up,\n * even though we cannot read the actual status code.\n */\nasync function tryNoCors(url: string, signal: AbortSignal): Promise<boolean> {\n  try {\n    await fetch(url, { method: 'GET', mode: 'no-cors', signal, redirect: 'follow' })\n    // Any response (even opaque) means the server is reachable\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Check a single link for health issues.\n *\n * Fallback chain:\n *   1. HEAD \u2014 fast, minimal bandwidth\n *   2. GET  \u2014 when HEAD returns 405 or 0, or throws (CORS)\n *   3. no-cors GET \u2014 for cross-origin links, proves reachability\n */\nasync function checkLink(url: string, timeout_ms: number): Promise<LinkCheckResult> {\n  const startTime = performance.now()\n  const isExternal = new URL(url).origin !== window.location.origin\n\n  const controller = new AbortController()\n  const timeoutId = setTimeout(() => controller.abort(), timeout_ms)\n\n  try {\n    // === Step 1: HEAD request ===\n    const headResult = await tryFetch(url, 'HEAD', controller.signal)\n\n    if (headResult.ok) {\n      // HEAD succeeded, but check if we need to fall back\n      if (!shouldFallbackToGet(headResult.response.status)) {\n        clearTimeout(timeoutId)\n        const timeMs = Math.round(performance.now() - startTime)\n        return buildResult(url, headResult.response, timeMs, isExternal)\n      }\n      // 405 or 0 \u2014 fall through to GET\n    }\n\n    // === Step 2: GET request (fallback) ===\n    const getResult = await tryFetch(url, 'GET', controller.signal)\n\n    if (getResult.ok && getResult.response.status !== 0) {\n      clearTimeout(timeoutId)\n      const timeMs = Math.round(performance.now() - startTime)\n      return buildResult(url, getResult.response, timeMs, isExternal)\n    }\n\n    // === Step 3: no-cors fallback for external links ===\n    if (isExternal) {\n      const reachable = await tryNoCors(url, controller.signal)\n      clearTimeout(timeoutId)\n      const timeMs = Math.round(performance.now() - startTime)\n      return {\n        url,\n        status: null,\n        code: 'cors_blocked',\n        timeMs,\n        isExternal,\n        error: reachable\n          ? 'CORS policy blocked the request (server is reachable)'\n          : 'CORS policy blocked the request (server may be unreachable)',\n        needsServerVerification: true\n      }\n    }\n\n    // Internal link returned status 0 on both HEAD and GET \u2014 unusual\n    clearTimeout(timeoutId)\n    const timeMs = Math.round(performance.now() - startTime)\n    return {\n      url,\n      status: null,\n      code: 'broken',\n      timeMs,\n      isExternal,\n      error: 'Request returned status 0'\n    }\n  } catch (error) {\n    clearTimeout(timeoutId)\n    const timeMs = Math.round(performance.now() - startTime)\n    const err = error as Error\n    const isTimeout = err.name === 'AbortError'\n\n    if (isTimeout) {\n      return { url, status: null, code: 'timeout', timeMs, isExternal, error: 'timeout' }\n    }\n\n    // CORS/network errors on external links \u2014 classify as cors_blocked, not broken\n    if (isExternal && isCorsOrNetworkError(err)) {\n      return {\n        url,\n        status: null,\n        code: 'cors_blocked',\n        timeMs,\n        isExternal,\n        error: 'CORS policy blocked the request',\n        needsServerVerification: true\n      }\n    }\n\n    return {\n      url,\n      status: null,\n      code: 'broken',\n      timeMs,\n      isExternal,\n      error: err.message\n    }\n  }\n}\n\n/** Result of a single fetch attempt. */\ninterface FetchAttempt {\n  readonly ok: boolean\n  readonly response: Response\n}\n\n/** Sentinel response for failed fetch attempts. */\nconst FAILED_RESPONSE: Response = { status: 0, ok: false, redirected: false, url: '', headers: new Headers() } as Response\n\n/**\n * Attempt a fetch and return a normalized result.\n * Re-throws AbortError (timeout) so the caller can handle it.\n * All other errors are captured as { ok: false }.\n */\nasync function tryFetch(url: string, method: string, signal: AbortSignal): Promise<FetchAttempt> {\n  try {\n    const response = await fetch(url, { method, signal, redirect: 'follow' })\n    return { ok: true, response }\n  } catch (error) {\n    // Let AbortError (timeout) propagate to the outer catch\n    if ((error as Error).name === 'AbortError') throw error\n    return { ok: false, response: FAILED_RESPONSE }\n  }\n}\n\n/**\n * Build a LinkCheckResult from a successful HTTP response.\n */\nfunction buildResult(url: string, response: Response, timeMs: number, isExternal: boolean): LinkCheckResult {\n  return {\n    url,\n    status: response.status,\n    code: classifyStatus(response.status),\n    timeMs,\n    isExternal,\n    redirectTo: response.redirected ? response.url : undefined\n  }\n}\n\n/**\n * Determine if a link should be skipped (javascript:, mailto:, #anchor).\n */\nfunction isIgnoredLink(href: string): boolean {\n  if (href.startsWith('javascript:')) return true\n  if (href.startsWith('mailto:')) return true\n  if (href.startsWith('tel:')) return true\n  if (href.startsWith('#')) return true\n  if (href === '') return true\n  return false\n}\n\n/**\n * Split array into chunks of specified size.\n */\nfunction chunkArray<T>(arr: T[], chunkSize: number): T[][] {\n  const chunks: T[][] = []\n  for (let i = 0; i < arr.length; i += chunkSize) {\n    chunks.push(arr.slice(i, i + chunkSize))\n  }\n  return chunks\n}\n", "/**\n * @fileoverview Message Handlers - Handles messages from content script including\n * settings, state management, JavaScript execution, and DOM/accessibility queries.\n */\n\nimport type { BrowserStateSnapshot, StateAction, ExecuteJsResult, WebSocketCaptureMode } from '../types/index'\n\nimport { createDeferredPromise, TimeoutError } from '../lib/timeout-utils'\nimport { executeDOMQuery, runAxeAuditWithTimeout, type DOMQueryParams } from '../lib/dom-queries'\nimport { checkLinkHealth } from '../lib/link-health'\nimport {\n  getNetworkWaterfall,\n  setNetworkWaterfallEnabled,\n  setNetworkBodyCaptureEnabled,\n  setServerUrl\n} from '../lib/network'\nimport { setPerformanceMarksEnabled, installPerformanceCapture, uninstallPerformanceCapture } from '../lib/performance'\nimport { setActionCaptureEnabled } from '../lib/actions'\nimport {\n  setWebSocketCaptureEnabled,\n  setWebSocketCaptureMode,\n  installWebSocketCapture,\n  uninstallWebSocketCapture\n} from '../lib/websocket'\nimport { setPerformanceSnapshotEnabled } from '../lib/perf-snapshot'\nimport { setDeferralEnabled } from './observers'\n\n/** Read the page nonce set by the content script on the inject script element */\nlet pageNonce = ''\nif (typeof document !== 'undefined' && typeof document.querySelector === 'function') {\n  const nonceEl = document.querySelector('script[data-gasoline-nonce]')\n  if (nonceEl) {\n    pageNonce = nonceEl.getAttribute('data-gasoline-nonce') || ''\n  }\n}\n\n/**\n * Valid setting names from content script\n */\nconst VALID_SETTINGS = new Set([\n  'setNetworkWaterfallEnabled',\n  'setPerformanceMarksEnabled',\n  'setActionReplayEnabled',\n  'setWebSocketCaptureEnabled',\n  'setWebSocketCaptureMode',\n  'setPerformanceSnapshotEnabled',\n  'setDeferralEnabled',\n  'setNetworkBodyCaptureEnabled',\n  'setServerUrl'\n])\n\nconst VALID_STATE_ACTIONS = new Set<StateAction>(['capture', 'restore'])\n\n/**\n * Setting message from content script\n */\ninterface SettingMessageData {\n  type: 'GASOLINE_SETTING'\n  setting: string\n  enabled?: boolean\n  mode?: string\n  url?: string\n}\n\n/**\n * State command message from content script\n */\ninterface StateCommandMessageData {\n  type: 'GASOLINE_STATE_COMMAND'\n  messageId: string\n  action: StateAction\n  state?: BrowserStateSnapshot\n  include_url?: boolean\n}\n\n/**\n * Execute JS request message from content script\n */\ninterface ExecuteJsRequestMessageData {\n  type: 'GASOLINE_EXECUTE_JS'\n  requestId: number | string\n  script: string\n  timeoutMs?: number\n}\n\n/**\n * A11y query request message from content script\n */\ninterface A11yQueryRequestMessageData {\n  type: 'GASOLINE_A11Y_QUERY'\n  requestId: number | string\n  params?: Record<string, unknown>\n}\n\n/**\n * DOM query request message from content script\n */\ninterface DomQueryRequestMessageData {\n  type: 'GASOLINE_DOM_QUERY'\n  requestId: number | string\n  params?: Record<string, unknown>\n}\n\n/**\n * Highlight request message from content script\n */\ninterface HighlightRequestMessageData {\n  type: 'GASOLINE_HIGHLIGHT_REQUEST'\n  requestId: number | string\n  params?: {\n    selector: string\n    duration_ms?: number\n  }\n}\n\n/**\n * Get waterfall request message from content script\n */\ninterface GetWaterfallRequestMessageData {\n  type: 'GASOLINE_GET_WATERFALL'\n  requestId: number | string\n}\n\n/**\n * Link health query request message from content script\n */\ninterface LinkHealthQueryRequestMessageData {\n  type: 'GASOLINE_LINK_HEALTH_QUERY'\n  requestId: number | string\n  params?: Record<string, unknown>\n}\n\n/**\n * Union of all page message data types\n */\ntype PageMessageData =\n  | SettingMessageData\n  | StateCommandMessageData\n  | ExecuteJsRequestMessageData\n  | A11yQueryRequestMessageData\n  | DomQueryRequestMessageData\n  | HighlightRequestMessageData\n  | GetWaterfallRequestMessageData\n  | LinkHealthQueryRequestMessageData\n\n/**\n * Safe serialization for complex objects returned from executeJavaScript.\n */\n// #lizard forgives\nfunction serializeObject(obj: object, depth: number, seen: WeakSet<object>): unknown {\n  if (seen.has(obj)) return '[Circular]'\n  seen.add(obj)\n\n  if (Array.isArray(obj)) return obj.slice(0, 100).map((v) => safeSerializeForExecute(v, depth + 1, seen))\n  if (obj instanceof Error) return { error: obj.message, stack: obj.stack }\n  if (obj instanceof Date) return obj.toISOString()\n  if (obj instanceof RegExp) return obj.toString()\n  if (typeof Node !== 'undefined' && obj instanceof Node) {\n    const node = obj as Node & { id?: string }\n    return `[${node.nodeName}${node.id ? '#' + node.id : ''}]`\n  }\n\n  const result: Record<string, unknown> = {}\n  const keys = Object.keys(obj).slice(0, 50)\n  for (const key of keys) {\n    try {\n      result[key] = safeSerializeForExecute((obj as Record<string, unknown>)[key], depth + 1, seen)\n    } catch {\n      result[key] = '[unserializable]'\n    }\n  }\n  if (Object.keys(obj).length > 50) {\n    result['...'] = `[${Object.keys(obj).length - 50} more keys]`\n  }\n  return result\n}\n\nexport function safeSerializeForExecute(\n  value: unknown,\n  depth: number = 0,\n  seen: WeakSet<object> = new WeakSet()\n): unknown {\n  if (depth > 10) return '[max depth exceeded]'\n  if (value === null || value === undefined) return value\n\n  const type = typeof value\n  if (type === 'string' || type === 'number' || type === 'boolean') return value\n  if (type === 'function') return `[Function: ${(value as (...args: unknown[]) => unknown).name || 'anonymous'}]`\n  if (type === 'symbol') return (value as symbol).toString()\n  if (type === 'object') return serializeObject(value as object, depth, seen)\n\n  return String(value)\n}\n\n/**\n * Execute arbitrary JavaScript in the page context with timeout handling.\n */\nexport function executeJavaScript(script: string, timeoutMs: number = 5000): Promise<ExecuteJsResult> {\n  const deferred = createDeferredPromise<ExecuteJsResult>()\n\n  // #lizard forgives\n  const executeWithTimeoutProtection = async (): Promise<void> => {\n    const timeoutHandle = setTimeout(() => {\n      deferred.resolve({\n        success: false,\n        error: 'execution_timeout',\n        message: `Script exceeded ${timeoutMs}ms timeout. RECOMMENDED ACTIONS:\n\n1. Check for infinite loops or blocking operations in your script\n2. Break the task into smaller pieces (< 2s execution time works best)\n3. Verify the script logic - test with simpler operations first\n\nTip: Run small test scripts to isolate the issue, then build up complexity.`\n      })\n    }, timeoutMs)\n\n    try {\n      const cleanScript = script.trim()\n\n      // Try expression form first (captures return values from IIFEs, expressions).\n      // If it throws SyntaxError (statements like try/catch, if/else), fall back to statement form.\n      let fn: () => unknown\n      try {\n        // eslint-disable-next-line no-new-func\n        fn = new Function(`\"use strict\"; return (${cleanScript});`) as () => unknown // nosemgrep: javascript.lang.security.eval.rule-eval-with-expression -- Function() constructor for controlled sandbox execution\n      } catch {\n        // eslint-disable-next-line no-new-func\n        fn = new Function(`\"use strict\"; ${cleanScript}`) as () => unknown // nosemgrep: javascript.lang.security.eval.rule-eval-with-expression -- Function() constructor for controlled sandbox execution\n      }\n\n      const result = fn()\n\n      // Handle promises\n      if (result && typeof (result as Promise<unknown>).then === 'function') {\n        ;(result as Promise<unknown>)\n          .then((value) => {\n            clearTimeout(timeoutHandle)\n            deferred.resolve({ success: true, result: safeSerializeForExecute(value) })\n          })\n          .catch((err: Error) => {\n            clearTimeout(timeoutHandle)\n            deferred.resolve({\n              success: false,\n              error: 'promise_rejected',\n              message: err.message,\n              stack: err.stack\n            })\n          })\n      } else {\n        clearTimeout(timeoutHandle)\n        deferred.resolve({ success: true, result: safeSerializeForExecute(result) })\n      }\n    } catch (err) {\n      clearTimeout(timeoutHandle)\n\n      const error = err as Error\n      if (\n        error.message &&\n        (error.message.includes('Content Security Policy') ||\n          error.message.includes('unsafe-eval') ||\n          error.message.includes('Trusted Type'))\n      ) {\n        deferred.resolve({\n          success: false,\n          error: 'csp_blocked',\n          message:\n            'This page has a Content Security Policy that blocks script execution in the MAIN world. ' +\n            'Use world: \"isolated\" to bypass CSP (DOM access only, no page JS globals). ' +\n            'With world: \"auto\" (default), this fallback happens automatically.'\n        })\n      } else {\n        deferred.resolve({\n          success: false,\n          error: 'execution_error',\n          message: error.message,\n          stack: error.stack\n        })\n      }\n    }\n  }\n\n  executeWithTimeoutProtection().catch((err) => {\n    console.error('[Gasoline] Unexpected error in executeJavaScript:', err)\n    deferred.resolve({\n      success: false,\n      error: 'execution_error',\n      message: 'Unexpected error during script execution'\n    })\n  })\n\n  return deferred.promise\n}\n\n/**\n * Handle link health check request from content script\n */\nexport async function handleLinkHealthQuery(data: LinkHealthQueryRequestMessageData): Promise<unknown> {\n  try {\n    const params = data.params || {}\n    const result = await checkLinkHealth(params)\n    return result\n  } catch (err) {\n    return {\n      error: 'link_health_error',\n      message: (err as Error).message || 'Failed to check link health'\n    }\n  }\n}\n\n/**\n * Install message listener for handling content script messages\n */\nfunction isValidSettingPayload(data: SettingMessageData): boolean {\n  if (!VALID_SETTINGS.has(data.setting)) {\n    console.warn('[Gasoline] Invalid setting:', data.setting)\n    return false\n  }\n  if (data.setting === 'setWebSocketCaptureMode') return typeof data.mode === 'string'\n  if (data.setting === 'setServerUrl') return typeof data.url === 'string'\n  // Boolean settings\n  if (typeof data.enabled !== 'boolean') {\n    console.warn('[Gasoline] Invalid enabled value type')\n    return false\n  }\n  return true\n}\n\nfunction handleLinkHealthMessage(data: LinkHealthQueryRequestMessageData): void {\n  handleLinkHealthQuery(data)\n    .then((result) => {\n      window.postMessage(\n        { type: 'GASOLINE_LINK_HEALTH_RESPONSE', requestId: data.requestId, result },\n        window.location.origin\n      )\n    })\n    .catch((err: Error) => {\n      window.postMessage(\n        {\n          type: 'GASOLINE_LINK_HEALTH_RESPONSE',\n          requestId: data.requestId,\n          result: { error: 'link_health_error', message: err.message || 'Failed to check link health' }\n        },\n        window.location.origin\n      )\n    })\n}\n\nexport function installMessageListener(\n  captureStateFn: () => BrowserStateSnapshot,\n  restoreStateFn: (state: BrowserStateSnapshot, includeUrl: boolean) => unknown\n): void {\n  if (typeof window === 'undefined') return\n\n  const messageHandlers: Record<string, (data: PageMessageData) => void> = {\n    GASOLINE_SETTING: (data) => {\n      const settingData = data as SettingMessageData\n      if (isValidSettingPayload(settingData)) handleSetting(settingData)\n    },\n    GASOLINE_STATE_COMMAND: (data) =>\n      handleStateCommand(data as StateCommandMessageData, captureStateFn, restoreStateFn),\n    GASOLINE_EXECUTE_JS: (data) => handleExecuteJs(data as ExecuteJsRequestMessageData),\n    GASOLINE_A11Y_QUERY: (data) => handleA11yQuery(data as A11yQueryRequestMessageData),\n    GASOLINE_DOM_QUERY: (data) => handleDomQuery(data as DomQueryRequestMessageData),\n    GASOLINE_GET_WATERFALL: (data) => handleGetWaterfall(data as GetWaterfallRequestMessageData),\n    GASOLINE_LINK_HEALTH_QUERY: (data) => handleLinkHealthMessage(data as LinkHealthQueryRequestMessageData)\n  }\n\n  window.addEventListener('message', (event: MessageEvent<PageMessageData>) => {\n    if (event.source !== window || event.origin !== window.location.origin) return\n    if (pageNonce && (event.data as unknown as { _nonce?: string })?._nonce !== pageNonce) return\n\n    const msgType = event.data?.type\n    if (!msgType) return\n\n    const handler = messageHandlers[msgType] // nosemgrep: unsafe-dynamic-method\n    if (handler) handler(event.data)\n  })\n}\n\ntype SettingHandler = (data: SettingMessageData) => void\n\nconst SETTING_HANDLERS: Record<string, SettingHandler> = {\n  setNetworkWaterfallEnabled: (data) => setNetworkWaterfallEnabled(data.enabled!),\n  setPerformanceMarksEnabled: (data) => {\n    setPerformanceMarksEnabled(data.enabled!)\n    if (data.enabled) installPerformanceCapture()\n    else uninstallPerformanceCapture()\n  },\n  setActionReplayEnabled: (data) => setActionCaptureEnabled(data.enabled!),\n  setWebSocketCaptureEnabled: (data) => {\n    setWebSocketCaptureEnabled(data.enabled!)\n    if (data.enabled) installWebSocketCapture()\n    else uninstallWebSocketCapture()\n  },\n  setWebSocketCaptureMode: (data) => setWebSocketCaptureMode((data.mode || 'medium') as WebSocketCaptureMode),\n  setPerformanceSnapshotEnabled: (data) => setPerformanceSnapshotEnabled(data.enabled!),\n  setDeferralEnabled: (data) => setDeferralEnabled(data.enabled!),\n  setNetworkBodyCaptureEnabled: (data) => setNetworkBodyCaptureEnabled(data.enabled!),\n  setServerUrl: (data) => setServerUrl(data.url!)\n}\n\nfunction handleSetting(data: SettingMessageData): void {\n  const handler = SETTING_HANDLERS[data.setting]\n  if (handler) handler(data)\n}\n\nfunction handleStateCommand(\n  data: StateCommandMessageData,\n  captureStateFn: () => BrowserStateSnapshot,\n  restoreStateFn: (state: BrowserStateSnapshot, includeUrl: boolean) => unknown\n): void {\n  const { messageId, action, state } = data\n\n  // Validate action\n  if (!VALID_STATE_ACTIONS.has(action)) {\n    console.warn('[Gasoline] Invalid state action:', action)\n    window.postMessage(\n      {\n        type: 'GASOLINE_STATE_RESPONSE',\n        messageId,\n        result: { error: `Invalid action: ${action}` }\n      },\n      window.location.origin\n    )\n    return\n  }\n\n  // Validate state object for restore action\n  if (action === 'restore' && (!state || typeof state !== 'object')) {\n    console.warn('[Gasoline] Invalid state object for restore')\n    window.postMessage(\n      {\n        type: 'GASOLINE_STATE_RESPONSE',\n        messageId,\n        result: { error: 'Invalid state object' }\n      },\n      window.location.origin\n    )\n    return\n  }\n\n  let result: BrowserStateSnapshot | unknown\n\n  try {\n    if (action === 'capture') {\n      result = captureStateFn()\n    } else if (action === 'restore') {\n      const includeUrl = data.include_url !== false\n      result = restoreStateFn(state!, includeUrl)\n    } else {\n      result = { error: `Unknown action: ${action}` }\n    }\n  } catch (err) {\n    result = { error: (err as Error).message }\n  }\n\n  // Send response back to content script\n  window.postMessage(\n    {\n      type: 'GASOLINE_STATE_RESPONSE',\n      messageId,\n      result\n    },\n    window.location.origin\n  )\n}\n\nfunction handleExecuteJs(data: ExecuteJsRequestMessageData): void {\n  const { requestId, script, timeoutMs } = data\n\n  // Validate parameters\n  if (typeof script !== 'string') {\n    console.warn('[Gasoline] Script must be a string')\n    window.postMessage(\n      {\n        type: 'GASOLINE_EXECUTE_JS_RESULT',\n        requestId,\n        result: { success: false, error: 'invalid_script', message: 'Script must be a string' }\n      },\n      window.location.origin\n    )\n    return\n  }\n\n  if (typeof requestId !== 'number' && typeof requestId !== 'string') {\n    console.warn('[Gasoline] Invalid requestId type')\n    return\n  }\n\n  executeJavaScript(script, timeoutMs)\n    .then((result) => {\n      window.postMessage(\n        {\n          type: 'GASOLINE_EXECUTE_JS_RESULT',\n          requestId,\n          result\n        },\n        window.location.origin\n      )\n    })\n    .catch((err: Error) => {\n      console.error('[Gasoline] Failed to execute JS:', err)\n      window.postMessage(\n        {\n          type: 'GASOLINE_EXECUTE_JS_RESULT',\n          requestId,\n          result: { success: false, error: 'execution_failed', message: err.message }\n        },\n        window.location.origin\n      )\n    })\n}\n\nfunction handleA11yQuery(data: A11yQueryRequestMessageData): void {\n  const { requestId, params } = data\n\n  if (typeof runAxeAuditWithTimeout !== 'function') {\n    window.postMessage(\n      {\n        type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n        requestId,\n        result: {\n          error: 'runAxeAuditWithTimeout not available - try reloading the extension'\n        }\n      },\n      window.location.origin\n    )\n    return\n  }\n\n  try {\n    runAxeAuditWithTimeout(params || {})\n      .then((result) => {\n        window.postMessage(\n          {\n            type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n            requestId,\n            result\n          },\n          window.location.origin\n        )\n      })\n      .catch((err: Error) => {\n        console.error('[Gasoline] Accessibility audit error:', err)\n        window.postMessage(\n          {\n            type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n            requestId,\n            result: { error: err.message || 'Accessibility audit failed' }\n          },\n          window.location.origin\n        )\n      })\n  } catch (err) {\n    console.error('[Gasoline] Failed to run accessibility audit:', err)\n    window.postMessage(\n      {\n        type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n        requestId,\n        result: { error: (err as Error).message || 'Failed to run accessibility audit' }\n      },\n      window.location.origin\n    )\n  }\n}\n\nfunction handleDomQuery(data: DomQueryRequestMessageData): void {\n  const { requestId, params } = data\n\n  if (typeof executeDOMQuery !== 'function') {\n    window.postMessage(\n      {\n        type: 'GASOLINE_DOM_QUERY_RESPONSE',\n        requestId,\n        result: {\n          error: 'executeDOMQuery not available - try reloading the extension'\n        }\n      },\n      window.location.origin\n    )\n    return\n  }\n\n  try {\n    executeDOMQuery((params || {}) as unknown as DOMQueryParams)\n      .then((result) => {\n        window.postMessage(\n          {\n            type: 'GASOLINE_DOM_QUERY_RESPONSE',\n            requestId,\n            result\n          },\n          window.location.origin\n        )\n      })\n      .catch((err: Error) => {\n        console.error('[Gasoline] DOM query error:', err)\n        window.postMessage(\n          {\n            type: 'GASOLINE_DOM_QUERY_RESPONSE',\n            requestId,\n            result: { error: err.message || 'DOM query failed' }\n          },\n          window.location.origin\n        )\n      })\n  } catch (err) {\n    console.error('[Gasoline] Failed to run DOM query:', err)\n    window.postMessage(\n      {\n        type: 'GASOLINE_DOM_QUERY_RESPONSE',\n        requestId,\n        result: { error: (err as Error).message || 'Failed to run DOM query' }\n      },\n      window.location.origin\n    )\n  }\n}\n\nfunction handleGetWaterfall(data: GetWaterfallRequestMessageData): void {\n  const { requestId } = data\n\n  try {\n    const entries = getNetworkWaterfall({})\n\n    // Convert camelCase WaterfallEntry fields to snake_case for Go daemon\n    const snakeEntries = (entries || []).map((e) => ({\n      url: e.url,\n      name: e.url,\n      initiator_type: e.initiatorType,\n      start_time: e.startTime,\n      duration: e.duration,\n      transfer_size: e.transferSize,\n      encoded_body_size: e.encodedBodySize,\n      decoded_body_size: e.decodedBodySize\n    }))\n\n    window.postMessage(\n      {\n        type: 'GASOLINE_WATERFALL_RESPONSE',\n        requestId,\n        entries: snakeEntries,\n        page_url: window.location.href\n      },\n      window.location.origin\n    )\n  } catch (err) {\n    console.error('[Gasoline] Failed to get network waterfall:', err)\n    window.postMessage(\n      {\n        type: 'GASOLINE_WATERFALL_RESPONSE',\n        requestId,\n        entries: []\n      },\n      window.location.origin\n    )\n  }\n}\n", "/**\n * @fileoverview State Management - Handles browser state capture/restore and\n * element highlighting for the AI Web Pilot.\n */\n\nimport type { BrowserStateSnapshot } from '../types/index'\nimport { sendPerformanceSnapshot } from '../lib/perf-snapshot'\n\n/** Read the page nonce set by the content script on the inject script element */\nlet pageNonce = ''\nif (typeof document !== 'undefined' && typeof document.querySelector === 'function') {\n  const nonceEl = document.querySelector('script[data-gasoline-nonce]')\n  if (nonceEl) {\n    pageNonce = nonceEl.getAttribute('data-gasoline-nonce') || ''\n  }\n}\n\n/** Patterns for sensitive storage keys whose values should be redacted */\nconst SENSITIVE_KEY_PATTERNS = /token|secret|password|api.?key|auth|session.?id|csrf|jwt/i\n\nlet gasolineHighlighter: HTMLDivElement | null = null\n\n/**\n * Highlight result\n */\nexport interface HighlightResult {\n  success: boolean\n  selector?: string\n  bounds?: { x: number; y: number; width: number; height: number }\n  error?: string\n}\n\n/**\n * Restored state counts\n */\nexport interface RestoredCounts {\n  localStorage: number\n  sessionStorage: number\n  cookies: number\n  skipped: number\n}\n\n/**\n * Restore state result\n */\nexport interface RestoreStateResult {\n  success: boolean\n  restored?: RestoredCounts\n  error?: string\n}\n\n/**\n * Capture browser state (localStorage, sessionStorage, cookies).\n * Returns a snapshot that can be restored later.\n */\nexport function captureState(): BrowserStateSnapshot {\n  const state: BrowserStateSnapshot = {\n    url: window.location.href,\n    timestamp: Date.now(),\n    localStorage: {},\n    sessionStorage: {},\n    cookies: document.cookie\n      .split(';')\n      .map((c) => {\n        const [name, ...rest] = c.split('=')\n        if (name && SENSITIVE_KEY_PATTERNS.test(name.trim())) {\n          return `${name}=[REDACTED]`\n        }\n        return c\n      })\n      .join(';')\n  }\n\n  const localStorageData: Record<string, string> = {}\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i)\n    if (key) {\n      localStorageData[key] = SENSITIVE_KEY_PATTERNS.test(key) ? '[REDACTED]' : localStorage.getItem(key) || ''\n    }\n  }\n  ;(state as { localStorage: Record<string, string> }).localStorage = localStorageData\n\n  const sessionStorageData: Record<string, string> = {}\n  for (let i = 0; i < sessionStorage.length; i++) {\n    const key = sessionStorage.key(i)\n    if (key) {\n      sessionStorageData[key] = SENSITIVE_KEY_PATTERNS.test(key) ? '[REDACTED]' : sessionStorage.getItem(key) || ''\n    }\n  }\n  ;(state as { sessionStorage: Record<string, string> }).sessionStorage = sessionStorageData\n\n  return state\n}\n\n/**\n * Validates a storage key to prevent prototype pollution and other attacks\n */\nfunction isValidStorageKey(key: string): boolean {\n  if (typeof key !== 'string') return false\n  if (key.length === 0 || key.length > 256) return false\n\n  // Reject prototype pollution vectors\n  const dangerous = ['__proto__', 'constructor', 'prototype']\n  const lowerKey = key.toLowerCase()\n  for (const pattern of dangerous) {\n    if (lowerKey.includes(pattern)) return false\n  }\n\n  return true\n}\n\n/**\n * Restore browser state from a snapshot.\n * Clears existing state before restoring.\n */\nconst MAX_STORAGE_VALUE_SIZE = 10 * 1024 * 1024\n\n// #lizard forgives\nfunction restoreStorageEntries(storage: Storage, entries: Record<string, string>, label: string): number {\n  let skipped = 0\n  for (const [key, value] of Object.entries(entries)) {\n    if (!isValidStorageKey(key)) {\n      skipped++\n      console.warn(`[gasoline] Skipped ${label} key with invalid pattern:`, key) // nosemgrep: javascript.lang.security.audit.unsafe-formatstring.unsafe-formatstring -- console.warn with internal state key, not user-controlled\n      continue\n    }\n    if (typeof value === 'string' && value.length > MAX_STORAGE_VALUE_SIZE) {\n      skipped++\n      console.warn(`[gasoline] Skipped ${label} value exceeding 10MB:`, key) // nosemgrep: javascript.lang.security.audit.unsafe-formatstring.unsafe-formatstring -- console.warn with internal state key, not user-controlled\n      continue\n    }\n    storage.setItem(key, value)\n  }\n  return skipped\n}\n\nfunction clearAllCookies(): void {\n  const isSecure = window.location.protocol === 'https:'\n  document.cookie.split(';').forEach((c) => {\n    const name = (c.split('=')[0] || '').trim()\n    if (!name) return\n    let deleteCookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`\n    if (isSecure) deleteCookie += '; Secure'\n    deleteCookie += '; SameSite=Strict'\n    document.cookie = deleteCookie\n  })\n}\n\nfunction restoreCookies(cookieString: string): void {\n  const isSecure = window.location.protocol === 'https:'\n  cookieString.split(';').forEach((c) => {\n    const trimmed = c.trim()\n    if (!trimmed) return\n    let securedCookie = trimmed\n    if (isSecure && !securedCookie.toLowerCase().includes('secure')) securedCookie += '; Secure'\n    if (!securedCookie.toLowerCase().includes('samesite')) securedCookie += '; SameSite=Strict'\n    document.cookie = securedCookie\n  })\n}\n\nfunction navigateSameOrigin(url: string): void {\n  if (url === window.location.href) return\n  try {\n    const parsed = new URL(url)\n    if ((parsed.protocol === 'http:' || parsed.protocol === 'https:') && parsed.origin === window.location.origin) {\n      window.location.href = url\n    } else {\n      console.warn('[gasoline] Skipped navigation: URL must be same origin', url, 'current:', window.location.origin)\n    }\n  } catch (e) {\n    console.warn('[gasoline] Invalid URL for navigation:', url, e)\n  }\n}\n\n// #lizard forgives\nexport function restoreState(state: BrowserStateSnapshot, includeUrl: boolean = true): RestoreStateResult {\n  if (!state || typeof state !== 'object') {\n    return { success: false, error: 'Invalid state object' }\n  }\n\n  let skipped = restoreStorageEntries(localStorage, state.localStorage || {}, 'localStorage')\n  skipped += restoreStorageEntries(sessionStorage, state.sessionStorage || {}, 'sessionStorage')\n\n  clearAllCookies()\n  if (state.cookies) restoreCookies(state.cookies)\n\n  const restored: RestoredCounts = {\n    localStorage: Object.keys(state.localStorage || {}).length - skipped,\n    sessionStorage: Object.keys(state.sessionStorage || {}).length,\n    cookies: (state.cookies || '').split(';').filter((c) => c.trim()).length,\n    skipped\n  }\n\n  if (includeUrl && state.url) navigateSameOrigin(state.url)\n  if (skipped > 0) console.warn(`[gasoline] restoreState completed with ${skipped} skipped item(s)`)\n\n  return { success: true, restored }\n}\n\n/**\n * Highlight a DOM element by injecting a blue glow overlay div.\n */\n// #lizard forgives\nexport function highlightElement(selector: string, durationMs: number = 5000): HighlightResult | undefined {\n  // Remove existing highlight\n  if (gasolineHighlighter) {\n    gasolineHighlighter.remove()\n    gasolineHighlighter = null\n  }\n\n  const element = document.querySelector(selector)\n  if (!element) {\n    return { success: false, error: 'element_not_found', selector }\n  }\n\n  const rect = element.getBoundingClientRect()\n\n  gasolineHighlighter = document.createElement('div')\n  gasolineHighlighter.id = 'gasoline-highlighter'\n  gasolineHighlighter.dataset.selector = selector\n  Object.assign(gasolineHighlighter.style, {\n    position: 'fixed',\n    top: `${rect.top}px`,\n    left: `${rect.left}px`,\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    border: '2px solid rgba(59, 130, 246, 0.7)',\n    borderRadius: '4px',\n    backgroundColor: 'rgba(59, 130, 246, 0.08)',\n    boxShadow: '0 0 12px rgba(59, 130, 246, 0.5)',\n    zIndex: '2147483647',\n    pointerEvents: 'none',\n    boxSizing: 'border-box'\n  })\n\n  const targetElement = document.body || document.documentElement\n  if (targetElement) {\n    targetElement.appendChild(gasolineHighlighter)\n  } else {\n    console.warn('[Gasoline] No document body available for highlighter injection')\n    return\n  }\n\n  setTimeout(() => {\n    if (gasolineHighlighter) {\n      gasolineHighlighter.remove()\n      gasolineHighlighter = null\n    }\n  }, durationMs)\n\n  return {\n    success: true,\n    selector,\n    bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height }\n  }\n}\n\n/**\n * Clear any existing highlight\n */\n// #lizard forgives\nexport function clearHighlight(): void {\n  if (gasolineHighlighter) {\n    gasolineHighlighter.remove()\n    gasolineHighlighter = null\n  }\n}\n\n/**\n * Handle scroll - update highlight position\n */\nif (typeof window !== 'undefined') {\n  window.addEventListener(\n    'scroll',\n    () => {\n      if (gasolineHighlighter) {\n        const selector = gasolineHighlighter.dataset.selector\n        if (selector) {\n          const el = document.querySelector(selector)\n          if (el) {\n            const rect = el.getBoundingClientRect()\n            gasolineHighlighter.style.top = `${rect.top}px`\n            gasolineHighlighter.style.left = `${rect.left}px`\n          }\n        }\n      }\n    },\n    { passive: true }\n  )\n}\n\n/**\n * Handle GASOLINE_HIGHLIGHT_REQUEST messages from content script\n */\nif (typeof window !== 'undefined') {\n  window.addEventListener('message', (event: MessageEvent) => {\n    if (event.source !== window || event.origin !== window.location.origin) return\n    if (pageNonce && (event.data as Record<string, unknown>)?._nonce !== pageNonce) return\n    if (event.data?.type === 'GASOLINE_HIGHLIGHT_REQUEST') {\n      const { requestId, params } = event.data\n      const { selector, duration_ms } = params || { selector: '' }\n      const result = highlightElement(selector, duration_ms)\n      window.postMessage(\n        {\n          type: 'GASOLINE_HIGHLIGHT_RESPONSE',\n          requestId,\n          result\n        },\n        window.location.origin\n      )\n    }\n  })\n}\n\n/**\n * Wrapper for sending performance snapshot (exported for compatibility)\n */\nexport function sendPerformanceSnapshotWrapper(): void {\n  sendPerformanceSnapshot()\n}\n", "/**\n * @fileoverview inject/index.ts - Main orchestration and barrel exports\n * Combines API, observers, and message handlers for page-level capture.\n */\n\n// Re-export barrel pattern for tests and consumers\nexport { safeSerialize, getElementSelector, isSensitiveInput } from '../lib/serialize'\nexport {\n  getContextAnnotations,\n  setContextAnnotation,\n  removeContextAnnotation,\n  clearContextAnnotations\n} from '../lib/context'\nexport {\n  getImplicitRole,\n  isDynamicClass,\n  computeCssPath,\n  computeSelectors,\n  recordEnhancedAction,\n  getEnhancedActionBuffer,\n  clearEnhancedActionBuffer,\n  generatePlaywrightScript\n} from '../lib/reproduction'\nexport {\n  recordAction,\n  getActionBuffer,\n  clearActionBuffer,\n  handleClick,\n  handleInput,\n  handleScroll,\n  handleKeydown,\n  handleChange,\n  installActionCapture,\n  uninstallActionCapture,\n  setActionCaptureEnabled,\n  installNavigationCapture,\n  uninstallNavigationCapture\n} from '../lib/actions'\nexport {\n  parseResourceTiming,\n  getNetworkWaterfall,\n  trackPendingRequest,\n  completePendingRequest,\n  getPendingRequests,\n  clearPendingRequests,\n  getNetworkWaterfallForError,\n  setNetworkWaterfallEnabled,\n  isNetworkWaterfallEnabled,\n  setNetworkBodyCaptureEnabled,\n  isNetworkBodyCaptureEnabled,\n  shouldCaptureUrl,\n  setServerUrl,\n  sanitizeHeaders,\n  truncateRequestBody,\n  truncateResponseBody,\n  readResponseBody,\n  readResponseBodyWithTimeout,\n  wrapFetchWithBodies\n} from '../lib/network'\nexport {\n  getPerformanceMarks,\n  getPerformanceMeasures,\n  getCapturedMarks,\n  getCapturedMeasures,\n  installPerformanceCapture,\n  uninstallPerformanceCapture,\n  isPerformanceCaptureActive,\n  getPerformanceSnapshotForError,\n  setPerformanceMarksEnabled,\n  isPerformanceMarksEnabled\n} from '../lib/performance'\nexport { postLog } from '../lib/bridge'\nexport { installConsoleCapture, uninstallConsoleCapture } from '../lib/console'\nexport {\n  parseStackFrames,\n  parseSourceMap,\n  extractSnippet,\n  extractSourceSnippets,\n  detectFramework,\n  getReactComponentAncestry,\n  captureStateSnapshot,\n  generateAiSummary,\n  enrichErrorWithAiContext,\n  setAiContextEnabled,\n  setAiContextStateSnapshot,\n  setSourceMapCache,\n  getSourceMapCache,\n  getSourceMapCacheSize\n} from '../lib/ai-context'\nexport { installExceptionCapture, uninstallExceptionCapture } from '../lib/exceptions'\nexport {\n  getSize,\n  formatPayload,\n  truncateWsMessage,\n  createConnectionTracker,\n  installWebSocketCapture,\n  setWebSocketCaptureMode,\n  setWebSocketCaptureEnabled,\n  getWebSocketCaptureMode,\n  uninstallWebSocketCapture,\n  resetForTesting\n} from '../lib/websocket'\nexport { executeDOMQuery, getPageInfo, runAxeAudit, runAxeAuditWithTimeout, formatAxeResults } from '../lib/dom-queries'\nexport {\n  mapInitiatorType,\n  aggregateResourceTiming,\n  capturePerformanceSnapshot,\n  installPerfObservers,\n  uninstallPerfObservers,\n  getLongTaskMetrics,\n  getFCP,\n  getLCP,\n  getCLS,\n  getINP,\n  sendPerformanceSnapshot,\n  isPerformanceSnapshotEnabled,\n  setPerformanceSnapshotEnabled\n} from '../lib/perf-snapshot'\n\n// Re-export constants that tests import from inject.js\nexport { MAX_WATERFALL_ENTRIES, MAX_PERFORMANCE_ENTRIES, SENSITIVE_HEADERS } from '../lib/constants'\n\n// Export API module\nexport { installGasolineAPI, uninstallGasolineAPI, type GasolineAPI } from './api'\n\n// Export observer module\nexport {\n  install,\n  uninstall,\n  wrapFetch,\n  installFetchCapture,\n  uninstallFetchCapture,\n  installPhase1,\n  installPhase2,\n  getDeferralState,\n  setDeferralEnabled,\n  shouldDeferIntercepts,\n  checkMemoryPressure,\n  type DeferralState\n} from './observers'\n\n// Export message handlers module\nexport { installMessageListener, executeJavaScript, safeSerializeForExecute } from './message-handlers'\n\n// Export state management functions\nexport {\n  captureState,\n  restoreState,\n  highlightElement,\n  clearHighlight,\n  type RestoreStateResult,\n  type RestoredCounts,\n  type HighlightResult\n} from './state'\n\nimport { installGasolineAPI } from './api'\nimport { installPhase1 } from './observers'\nimport { installMessageListener } from './message-handlers'\nimport { captureState, restoreState, sendPerformanceSnapshotWrapper } from './state'\nimport { sendPerformanceSnapshot } from '../lib/perf-snapshot'\n\n/**\n * Auto-install when loaded in browser\n */\nif (\n  typeof window !== 'undefined' &&\n  typeof document !== 'undefined' &&\n  typeof (globalThis as Record<string, unknown>).process === 'undefined'\n) {\n  // Install Phase 1 (lightweight API + observers)\n  installPhase1()\n\n  // Install message listener with state functions\n  installMessageListener(captureState, restoreState)\n\n  // Install Gasoline API\n  installGasolineAPI()\n\n  // Send performance snapshot after page load + 2s settling time\n  window.addEventListener('load', () => {\n    setTimeout(() => {\n      sendPerformanceSnapshot()\n    }, 2000)\n  })\n}\n"],
  "mappings": "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",
  "names": ["window", "timeMs", "serializeObject", "pageNonce"]
}
