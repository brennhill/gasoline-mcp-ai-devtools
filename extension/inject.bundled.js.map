{
  "version": 3,
  "sources": ["../src/lib/constants.ts", "../src/lib/serialize.ts", "../src/lib/context.ts", "../src/lib/reproduction.ts", "../src/lib/actions.ts", "../src/lib/network.ts", "../src/lib/performance.ts", "../src/lib/bridge.ts", "../src/lib/console.ts", "../src/lib/ai-context.ts", "../src/lib/exceptions.ts", "../src/lib/websocket.ts", "../src/lib/dom-queries.ts", "../src/lib/perf-snapshot.ts", "../src/inject/api.ts", "../src/inject/observers.ts", "../src/lib/timeout-utils.ts", "../src/inject/message-handlers.ts", "../src/inject/state.ts", "../src/inject/index.ts"],
  "sourcesContent": ["/**\n * @fileoverview Shared constants for the Gasoline extension capture modules.\n */\n\n// Serialization limits\nexport const MAX_STRING_LENGTH = 10240 // 10KB\nexport const MAX_RESPONSE_LENGTH = 5120 // 5KB\nexport const MAX_DEPTH = 10\nexport const MAX_CONTEXT_SIZE = 50 // Max number of context keys\nexport const MAX_CONTEXT_VALUE_SIZE = 4096 // Max size of serialized context value\nexport const SENSITIVE_HEADERS: readonly string[] = [\n  'authorization',\n  'cookie',\n  'set-cookie',\n  'x-auth-token',\n  'x-api-key',\n  'x-csrf-token',\n  'proxy-authorization',\n]\n\n// User action replay settings\nexport const MAX_ACTION_BUFFER_SIZE = 20 // Max number of recent actions to keep\nexport const SCROLL_THROTTLE_MS = 250 // Throttle scroll events\nexport const SENSITIVE_INPUT_TYPES: readonly string[] = ['password', 'credit-card', 'cc-number', 'cc-exp', 'cc-csc']\n\n// Network Waterfall settings\nexport const MAX_WATERFALL_ENTRIES = 50 // Max network entries to capture\nexport const WATERFALL_TIME_WINDOW_MS = 30000 // Only capture last 30 seconds\n\n// Performance Marks settings\nexport const MAX_PERFORMANCE_ENTRIES = 50 // Max performance entries to capture\nexport const PERFORMANCE_TIME_WINDOW_MS = 60000 // Only capture last 60 seconds\n\n// WebSocket capture settings\nexport const WS_MAX_BODY_SIZE = 4096 // 4KB truncation limit\nexport const WS_PREVIEW_LIMIT = 200 // Preview character limit\n\n// Network body capture settings\nexport const REQUEST_BODY_MAX = 8192 // 8KB\nexport const RESPONSE_BODY_MAX = 16384 // 16KB\n// Intentionally aggressive (5ms) to avoid blocking the main thread during fetch body reads.\n// Network body capture uses this as a race timeout - if the body isn't available nearly\n// instantly, we skip it rather than degrade page performance.\nexport const BODY_READ_TIMEOUT_MS = 5\nexport const SENSITIVE_HEADER_PATTERNS =\n  /^(authorization|cookie|set-cookie|x-api-key|x-auth-token|x-secret|x-password|.*token.*|.*secret.*|.*key.*|.*password.*)$/i\nexport const BINARY_CONTENT_TYPES = /^(image|video|audio|font)\\/|^application\\/(wasm|octet-stream|zip|gzip|pdf)/\n\n// DOM query settings\nexport const DOM_QUERY_MAX_ELEMENTS = 50\nexport const DOM_QUERY_MAX_TEXT = 500\nexport const DOM_QUERY_MAX_DEPTH = 5\nexport const DOM_QUERY_MAX_HTML = 200\nexport const A11Y_MAX_NODES_PER_VIOLATION = 10\nexport const A11Y_AUDIT_TIMEOUT_MS = 30000\n\n// Memory pressure settings\nexport const MEMORY_SOFT_LIMIT_MB = 20\nexport const MEMORY_HARD_LIMIT_MB = 50\n\n// AI Context settings\nexport const AI_CONTEXT_SNIPPET_LINES = 5 // Lines before and after error\nexport const AI_CONTEXT_MAX_LINE_LENGTH = 200 // Truncate lines\nexport const AI_CONTEXT_MAX_SNIPPETS_SIZE = 10240 // 10KB total snippets\nexport const AI_CONTEXT_MAX_ANCESTRY_DEPTH = 10\nexport const AI_CONTEXT_MAX_PROP_KEYS = 20\nexport const AI_CONTEXT_MAX_STATE_KEYS = 10\nexport const AI_CONTEXT_MAX_RELEVANT_SLICE = 10\nexport const AI_CONTEXT_MAX_VALUE_LENGTH = 200\nexport const AI_CONTEXT_SOURCE_MAP_CACHE_SIZE = 20\nexport const AI_CONTEXT_PIPELINE_TIMEOUT_MS = 3000\n\n// Reproduction script settings\nexport const ENHANCED_ACTION_BUFFER_SIZE = 50\nexport const CSS_PATH_MAX_DEPTH = 5\nexport const SELECTOR_TEXT_MAX_LENGTH = 50\nexport const SCRIPT_MAX_SIZE = 51200 // 50KB\nexport const CLICKABLE_TAGS: ReadonlySet<string> = new Set(['BUTTON', 'A', 'SUMMARY'])\n\n// Actionable keys for recording\nexport const ACTIONABLE_KEYS: ReadonlySet<string> = new Set([\n  'Enter',\n  'Escape',\n  'Tab',\n  'ArrowUp',\n  'ArrowDown',\n  'ArrowLeft',\n  'ArrowRight',\n  'Backspace',\n  'Delete',\n])\n\n// Performance snapshot settings\nexport const MAX_LONG_TASKS = 50\nexport const MAX_SLOWEST_REQUESTS = 3\nexport const MAX_URL_LENGTH = 80\n", "/**\n * @fileoverview Serialization utilities for safe value handling.\n * Provides safe serialization with circular reference detection, DOM element\n * selector generation, and sensitive input detection.\n *\n * NOTE: This module has NO mutable state. All functions are pure and stateless.\n * No resetForTesting() function is needed.\n */\n\nimport { MAX_STRING_LENGTH, MAX_DEPTH, SENSITIVE_INPUT_TYPES } from './constants.js'\nimport type { JsonValue } from '../types/index'\n\n// Extended input element interface for type checking\ninterface InputLikeElement extends Element {\n  type?: string\n  autocomplete?: string\n  name?: string\n  value?: string\n}\n\n// DOM element with extended properties\ninterface DOMElementLike {\n  nodeType?: number\n  tagName?: string\n  id?: string\n  className?: string | SVGAnimatedString\n  getAttribute?(name: string): string | null\n  textContent?: string | null\n}\n\n/**\n * Safely serialize a value, handling circular references and special types\n */\nexport function safeSerialize(value: unknown, depth = 0, seen = new WeakSet<object>()): JsonValue {\n  // Handle null/undefined\n  if (value === null) return null\n  if (value === undefined) return null\n\n  // Handle primitives\n  const type = typeof value\n  if (type === 'string') {\n    const strValue = value as string\n    if (strValue.length > MAX_STRING_LENGTH) {\n      return strValue.slice(0, MAX_STRING_LENGTH) + '... [truncated]'\n    }\n    return strValue\n  }\n  if (type === 'number') {\n    return value as number\n  }\n  if (type === 'boolean') {\n    return value as boolean\n  }\n\n  // Handle functions\n  if (type === 'function') {\n    const fn = value as { name?: string }\n    return `[Function: ${fn.name || 'anonymous'}]`\n  }\n\n  // Handle Error objects specially\n  if (value instanceof Error) {\n    return {\n      name: value.name,\n      message: value.message,\n      stack: value.stack || null,\n    }\n  }\n\n  // Depth limit\n  if (depth >= MAX_DEPTH) {\n    return '[Max depth exceeded]'\n  }\n\n  // Handle objects\n  if (type === 'object') {\n    const objValue = value as object\n\n    // Circular reference check\n    if (seen.has(objValue)) {\n      return '[Circular]'\n    }\n    seen.add(objValue)\n\n    // Handle DOM elements\n    const domLike = value as DOMElementLike\n    if (domLike.nodeType) {\n      const tag = domLike.tagName ? domLike.tagName.toLowerCase() : 'node'\n      const id = domLike.id ? `#${domLike.id}` : ''\n      const classNameValue = domLike.className\n      let className = ''\n      if (typeof classNameValue === 'string' && classNameValue) {\n        className = `.${classNameValue.split(' ').join('.')}`\n      }\n      return `[${tag}${id}${className}]`\n    }\n\n    // Handle arrays (cap at 100 elements to prevent OOM)\n    if (Array.isArray(value)) {\n      return value.slice(0, 100).map((item) => safeSerialize(item, depth + 1, seen))\n    }\n\n    // Handle plain objects (cap at 50 keys to prevent OOM)\n    const result: Record<string, JsonValue> = {}\n    for (const key of Object.keys(objValue).slice(0, 50)) {\n      try {\n        result[key] = safeSerialize((objValue as Record<string, unknown>)[key], depth + 1, seen)\n      } catch {\n        result[key] = '[Unserializable]'\n      }\n    }\n    return result\n  }\n\n  return String(value)\n}\n\n/**\n * Get element selector for identification\n */\nexport function getElementSelector(element: Element | null): string {\n  if (!element || !element.tagName) return ''\n\n  const tag = element.tagName.toLowerCase()\n  const id = element.id ? `#${element.id}` : ''\n\n  let classes = ''\n  const classNameValue = element.className\n  if (classNameValue && typeof classNameValue === 'string') {\n    classes = '.' + classNameValue.trim().split(/\\s+/).slice(0, 2).join('.')\n  }\n\n  // Add data-testid if present\n  const testId = element.getAttribute('data-testid')\n  const testIdStr = testId ? `[data-testid=\"${testId}\"]` : ''\n\n  return `${tag}${id}${classes}${testIdStr}`.slice(0, 100)\n}\n\n/**\n * Check if an input contains sensitive data\n */\nexport function isSensitiveInput(element: Element | null): boolean {\n  if (!element) return false\n\n  const inputElement = element as InputLikeElement\n  const type = (inputElement.type || '').toLowerCase()\n  const autocomplete = (inputElement.autocomplete || '').toLowerCase()\n  const name = (inputElement.name || '').toLowerCase()\n\n  // Check type attribute\n  if (SENSITIVE_INPUT_TYPES.includes(type)) return true\n\n  // Check autocomplete attribute\n  if (autocomplete.includes('password') || autocomplete.includes('cc-') || autocomplete.includes('credit-card'))\n    return true\n\n  // Check name attribute for common patterns\n  if (\n    name.includes('password') ||\n    name.includes('passwd') ||\n    name.includes('secret') ||\n    name.includes('token') ||\n    name.includes('credit') ||\n    name.includes('card') ||\n    name.includes('cvv') ||\n    name.includes('cvc') ||\n    name.includes('ssn')\n  )\n    return true\n\n  return false\n}\n", "/**\n * @fileoverview Context annotations storage and management.\n * Provides key-value annotations that attach to captured events for\n * richer debugging context (e.g., user flow, feature flag, session info).\n */\n\nimport { MAX_CONTEXT_SIZE, MAX_CONTEXT_VALUE_SIZE } from './constants.js'\nimport { safeSerialize } from './serialize.js'\nimport type { JsonValue } from '../types/index'\n\n// Context annotations storage\nconst contextAnnotations: Map<string, JsonValue> = new Map()\n\n/**\n * Get current context annotations as an object\n */\nexport function getContextAnnotations(): Record<string, JsonValue> | null {\n  if (contextAnnotations.size === 0) return null\n\n  const result: Record<string, JsonValue> = {}\n  for (const [key, value] of contextAnnotations) {\n    result[key] = value\n  }\n  return result\n}\n\n/**\n * Set a context annotation\n */\nexport function setContextAnnotation(key: string, value: unknown): boolean {\n  if (typeof key !== 'string' || key.length === 0) {\n    console.warn('[Gasoline] annotate() requires a non-empty string key')\n    return false\n  }\n\n  if (key.length > 100) {\n    console.warn('[Gasoline] annotate() key must be 100 characters or less')\n    return false\n  }\n\n  // Enforce max context keys\n  if (!contextAnnotations.has(key) && contextAnnotations.size >= MAX_CONTEXT_SIZE) {\n    console.warn(`[Gasoline] Maximum context annotations (${MAX_CONTEXT_SIZE}) reached`)\n    return false\n  }\n\n  // Serialize and check size\n  const serialized = safeSerialize(value)\n  const serializedStr = JSON.stringify(serialized)\n\n  if (serializedStr.length > MAX_CONTEXT_VALUE_SIZE) {\n    console.warn(`[Gasoline] Context value for \"${key}\" exceeds max size, truncating`)\n    contextAnnotations.set(key, '[Value too large]')\n    return false\n  }\n\n  contextAnnotations.set(key, serialized)\n  return true\n}\n\n/**\n * Remove a context annotation\n */\nexport function removeContextAnnotation(key: string): boolean {\n  return contextAnnotations.delete(key)\n}\n\n/**\n * Clear all context annotations\n */\nexport function clearContextAnnotations(): void {\n  contextAnnotations.clear()\n}\n", "/**\n * @fileoverview Reproduction script generation and enhanced action recording.\n * Captures user interactions with multi-strategy selectors (testId, role, aria,\n * text, CSS path) and generates Playwright test scripts for reproducing issues.\n */\n\nimport {\n  ENHANCED_ACTION_BUFFER_SIZE,\n  CSS_PATH_MAX_DEPTH,\n  SELECTOR_TEXT_MAX_LENGTH,\n  SCRIPT_MAX_SIZE,\n  CLICKABLE_TAGS,\n} from './constants.js'\nimport { isSensitiveInput } from './serialize.js'\n\n// Action types\ntype EnhancedActionType = 'click' | 'input' | 'keypress' | 'navigate' | 'select' | 'scroll'\n\n// Role selector info\ninterface RoleSelector {\n  role: string\n  name?: string\n}\n\n// Selector strategies\ninterface SelectorStrategies {\n  testId?: string\n  ariaLabel?: string\n  role?: RoleSelector\n  id?: string\n  text?: string\n  cssPath: string\n}\n\n// Enhanced action record\ninterface EnhancedActionRecord {\n  type: EnhancedActionType\n  timestamp: number\n  url: string\n  selectors?: SelectorStrategies\n  inputType?: string\n  value?: string\n  key?: string\n  fromUrl?: string\n  toUrl?: string\n  selectedValue?: string\n  selectedText?: string\n  scrollY?: number\n}\n\n// Script generation options\ninterface ScriptOptions {\n  errorMessage?: string\n  baseUrl?: string\n  lastNActions?: number\n}\n\n// Element with extended properties for type checking\ntype ElementWithProperties = Element & {\n  innerText?: string\n  type?: string\n}\n\n// Enhanced action buffer (separate from v3 action buffer)\nlet enhancedActionBuffer: EnhancedActionRecord[] = []\n\n/**\n * Get the implicit ARIA role for an element\n */\nexport function getImplicitRole(element: Element | null): string | null {\n  if (!element || !element.tagName) return null\n\n  const tag = element.tagName.toLowerCase()\n  const el = element as ElementWithProperties\n  const type = el.getAttribute ? el.getAttribute('type') : null\n\n  switch (tag) {\n    case 'button':\n      return 'button'\n    case 'a':\n      return el.getAttribute && el.getAttribute('href') !== null ? 'link' : null\n    case 'textarea':\n      return 'textbox'\n    case 'select':\n      return 'combobox'\n    case 'nav':\n      return 'navigation'\n    case 'main':\n      return 'main'\n    case 'header':\n      return 'banner'\n    case 'footer':\n      return 'contentinfo'\n    case 'input': {\n      const inputType = type || 'text'\n      switch (inputType) {\n        case 'text':\n        case 'email':\n        case 'password':\n        case 'tel':\n        case 'url':\n          return 'textbox'\n        case 'checkbox':\n          return 'checkbox'\n        case 'radio':\n          return 'radio'\n        case 'search':\n          return 'searchbox'\n        case 'number':\n          return 'spinbutton'\n        case 'range':\n          return 'slider'\n        default:\n          return 'textbox'\n      }\n    }\n    default:\n      return null\n  }\n}\n\n/**\n * Detect if a CSS class name is dynamically generated (CSS-in-JS)\n */\nexport function isDynamicClass(className: string | null): boolean {\n  if (!className) return false\n  // Known CSS-in-JS prefixes\n  if (/^(css|sc|emotion|styled|chakra)-/.test(className)) return true\n  // Random hash classes: 5-8 lowercase-only chars\n  if (/^[a-z]{5,8}$/.test(className)) return true\n  return false\n}\n\n/**\n * Compute a CSS path for an element\n */\nexport function computeCssPath(element: Element | null): string {\n  if (!element) return ''\n\n  const parts: string[] = []\n  let current: Element | null = element\n\n  while (current && parts.length < CSS_PATH_MAX_DEPTH) {\n    let selector = current.tagName ? current.tagName.toLowerCase() : ''\n\n    // Stop at element with ID\n    if (current.id) {\n      selector = `#${current.id}`\n      parts.unshift(selector)\n      break\n    }\n\n    // Add non-dynamic classes (max 2)\n    const classNameValue = current.className\n    const classList: string[] =\n      classNameValue && typeof classNameValue === 'string'\n        ? classNameValue\n            .trim()\n            .split(/\\s+/)\n            .filter((c) => c && !isDynamicClass(c))\n        : []\n    if (classList.length > 0) {\n      selector += '.' + classList.slice(0, 2).join('.')\n    }\n\n    parts.unshift(selector)\n    current = current.parentElement\n  }\n\n  return parts.join(' > ')\n}\n\n/**\n * Compute multi-strategy selectors for an element\n */\nexport function computeSelectors(element: Element | null): SelectorStrategies {\n  if (!element) return { cssPath: '' }\n\n  const selectors: Partial<SelectorStrategies> = {}\n  const el = element as ElementWithProperties\n\n  // Priority 1: Test ID\n  const testId =\n    (el.getAttribute &&\n      (el.getAttribute('data-testid') ||\n        el.getAttribute('data-test-id') ||\n        el.getAttribute('data-cy'))) ||\n    undefined\n  if (testId) selectors.testId = testId\n\n  // Priority 2: ARIA label\n  const ariaLabel = el.getAttribute && el.getAttribute('aria-label')\n  if (ariaLabel) selectors.ariaLabel = ariaLabel\n\n  // Priority 3: Role + accessible name\n  const explicitRole = el.getAttribute && el.getAttribute('role')\n  const role = explicitRole || getImplicitRole(element)\n  const name = ariaLabel || (el.textContent && el.textContent.trim().slice(0, SELECTOR_TEXT_MAX_LENGTH))\n  if (role && name) {\n    selectors.role = { role, name: ariaLabel || name }\n  }\n\n  // Priority 4: ID\n  if (element.id) selectors.id = element.id\n\n  // Priority 5: Text content (for clickable elements only)\n  if (element.tagName && CLICKABLE_TAGS.has(element.tagName.toUpperCase())) {\n    const text = (el.textContent || el.innerText || '').trim()\n    if (text && text.length > 0) {\n      selectors.text = text.slice(0, SELECTOR_TEXT_MAX_LENGTH)\n    }\n  } else if (el.getAttribute && el.getAttribute('role') === 'button') {\n    const text = (el.textContent || el.innerText || '').trim()\n    if (text && text.length > 0) {\n      selectors.text = text.slice(0, SELECTOR_TEXT_MAX_LENGTH)\n    }\n  }\n\n  // Priority 6: CSS path (always computed as fallback)\n  selectors.cssPath = computeCssPath(element)\n\n  return selectors as SelectorStrategies\n}\n\n// Options for recording enhanced actions\ninterface RecordActionOptions {\n  value?: string\n  key?: string\n  fromUrl?: string\n  toUrl?: string\n  selectedValue?: string\n  selectedText?: string\n  scrollY?: number\n}\n\n// PostMessage payload type\ninterface GasolineEnhancedActionMessage {\n  type: 'GASOLINE_ENHANCED_ACTION'\n  payload: EnhancedActionRecord\n}\n\n/**\n * Record an enhanced action with multi-strategy selectors\n */\nexport function recordEnhancedAction(\n  type: EnhancedActionType,\n  element: Element | null,\n  opts: RecordActionOptions = {}\n): EnhancedActionRecord {\n  const action: EnhancedActionRecord = {\n    type,\n    timestamp: Date.now(),\n    url: typeof window !== 'undefined' && window.location ? window.location.href : '',\n  }\n\n  // Compute selectors for element (if provided)\n  if (element) {\n    action.selectors = computeSelectors(element)\n  }\n\n  // Type-specific data\n  switch (type) {\n    case 'input': {\n      const el = element as ElementWithProperties | null\n      const inputType = el && el.getAttribute ? el.getAttribute('type') : 'text'\n      action.inputType = inputType || 'text'\n      // Redact sensitive values\n      if (inputType === 'password' || (element && isSensitiveInput(element))) {\n        action.value = '[redacted]'\n      } else {\n        action.value = opts.value || ''\n      }\n      break\n    }\n    case 'keypress':\n      action.key = opts.key || ''\n      break\n    case 'navigate':\n      action.fromUrl = opts.fromUrl || ''\n      action.toUrl = opts.toUrl || ''\n      break\n    case 'select':\n      action.selectedValue = opts.selectedValue || ''\n      action.selectedText = opts.selectedText || ''\n      break\n    case 'scroll':\n      action.scrollY = opts.scrollY || 0\n      break\n  }\n\n  // Add to buffer\n  enhancedActionBuffer.push(action)\n  if (enhancedActionBuffer.length > ENHANCED_ACTION_BUFFER_SIZE) {\n    enhancedActionBuffer.shift()\n  }\n\n  // Emit to content script for server relay\n  if (typeof window !== 'undefined' && window.postMessage) {\n    window.postMessage(\n      { type: 'GASOLINE_ENHANCED_ACTION', payload: action } as GasolineEnhancedActionMessage,\n      window.location.origin\n    )\n  }\n\n  return action\n}\n\n/**\n * Get the enhanced action buffer\n */\nexport function getEnhancedActionBuffer(): EnhancedActionRecord[] {\n  return [...enhancedActionBuffer]\n}\n\n/**\n * Clear the enhanced action buffer\n */\nexport function clearEnhancedActionBuffer(): void {\n  enhancedActionBuffer = []\n}\n\n/**\n * Generate a Playwright test script from captured actions\n */\nexport function generatePlaywrightScript(actions: EnhancedActionRecord[], opts: ScriptOptions = {}): string {\n  const { errorMessage, baseUrl, lastNActions } = opts\n\n  // Apply lastNActions filter\n  let filteredActions = actions\n  if (lastNActions && lastNActions > 0 && actions.length > lastNActions) {\n    filteredActions = actions.slice(-lastNActions)\n  }\n\n  // Determine start URL\n  let startUrl = ''\n  if (filteredActions.length > 0) {\n    const firstAction = filteredActions[0]\n    if (firstAction) {\n      startUrl = firstAction.url || ''\n    }\n  }\n  if (baseUrl && startUrl) {\n    try {\n      const parsed = new URL(startUrl)\n      startUrl = baseUrl + parsed.pathname\n    } catch {\n      startUrl = baseUrl\n    }\n  }\n\n  // Build test name\n  const testName = errorMessage ? `reproduction: ${errorMessage.slice(0, 80)}` : 'reproduction: captured user actions'\n\n  // Generate step code\n  const steps: string[] = []\n  let prevTimestamp: number | null = null\n\n  for (const action of filteredActions) {\n    // Add pause comment for long gaps\n    if (prevTimestamp && action.timestamp - prevTimestamp > 2000) {\n      const gap = Math.round((action.timestamp - prevTimestamp) / 1000)\n      steps.push(`  // [${gap}s pause]`)\n    }\n    prevTimestamp = action.timestamp\n\n    const locator = getPlaywrightLocator(action.selectors || { cssPath: '' })\n\n    switch (action.type) {\n      case 'click':\n        if (locator) {\n          steps.push(`  await page.${locator}.click();`)\n        } else {\n          steps.push(`  // click action - no selector available`)\n        }\n        break\n      case 'input': {\n        const value = action.value === '[redacted]' ? '[user-provided]' : action.value || ''\n        if (locator) {\n          steps.push(`  await page.${locator}.fill('${escapeString(value)}');`)\n        }\n        break\n      }\n      case 'keypress':\n        steps.push(`  await page.keyboard.press('${escapeString(action.key || '')}');`)\n        break\n      case 'navigate': {\n        let toUrl = action.toUrl || ''\n        if (baseUrl && toUrl) {\n          try {\n            const parsed = new URL(toUrl)\n            toUrl = baseUrl + parsed.pathname\n          } catch {\n            /* use as-is */\n          }\n        }\n        steps.push(`  await page.waitForURL('${escapeString(toUrl)}');`)\n        break\n      }\n      case 'select':\n        if (locator) {\n          steps.push(`  await page.${locator}.selectOption('${escapeString(action.selectedValue || '')}');`)\n        }\n        break\n      case 'scroll':\n        steps.push(`  // User scrolled to y=${action.scrollY || 0}`)\n        break\n    }\n  }\n\n  // Assemble script\n  let script = `import { test, expect } from '@playwright/test';\\n\\n`\n  script += `test('${escapeString(testName)}', async ({ page }) => {\\n`\n  if (startUrl) {\n    script += `  await page.goto('${escapeString(startUrl)}');\\n\\n`\n  }\n  script += steps.join('\\n')\n  if (steps.length > 0) script += '\\n'\n  if (errorMessage) {\n    script += `\\n  // Error occurred here: ${errorMessage}\\n`\n  }\n  script += `});\\n`\n\n  // Cap output size\n  if (script.length > SCRIPT_MAX_SIZE) {\n    script = script.slice(0, SCRIPT_MAX_SIZE)\n  }\n\n  return script\n}\n\n/**\n * Get the best Playwright locator for a set of selectors\n * Priority: testId > role > ariaLabel > text > id > cssPath\n */\nfunction getPlaywrightLocator(selectors: SelectorStrategies): string | null {\n  if (selectors.testId) {\n    return `getByTestId('${escapeString(selectors.testId)}')`\n  }\n  if (selectors.role && selectors.role.role) {\n    if (selectors.role.name) {\n      return `getByRole('${escapeString(selectors.role.role)}', { name: '${escapeString(selectors.role.name)}' })`\n    }\n    return `getByRole('${escapeString(selectors.role.role)}')`\n  }\n  if (selectors.ariaLabel) {\n    return `getByLabel('${escapeString(selectors.ariaLabel)}')`\n  }\n  if (selectors.text) {\n    return `getByText('${escapeString(selectors.text)}')`\n  }\n  if (selectors.id) {\n    return `locator('#${escapeString(selectors.id)}')`\n  }\n  if (selectors.cssPath) {\n    return `locator('${escapeString(selectors.cssPath)}')`\n  }\n  return null\n}\n\n/**\n * Escape a string for use in JavaScript string literals\n */\nfunction escapeString(str: string | undefined): string {\n  if (!str) return ''\n  return str\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/'/g, \"\\\\'\")\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\t/g, '\\\\t')\n    .replace(/`/g, '\\\\`')\n}\n", "/**\n * @fileoverview User action capture and replay buffer.\n * Records click, input, scroll, keydown, and change events with throttling\n * and sensitive data redaction. Also captures navigation events (pushState,\n * replaceState, popstate) for enhanced reproduction scripts.\n */\n\nimport { MAX_ACTION_BUFFER_SIZE, SCROLL_THROTTLE_MS, ACTIONABLE_KEYS } from './constants.js'\nimport { getElementSelector, isSensitiveInput } from './serialize.js'\nimport { recordEnhancedAction } from './reproduction.js'\n\n// Action record type\ninterface ActionRecord {\n  ts: string\n  type: string\n  target?: string\n  x?: number\n  y?: number\n  text?: string\n  inputType?: string\n  value?: string\n  length?: number\n  scrollX?: number\n  scrollY?: number\n}\n\n// Extended event target types\ninterface InputElement extends HTMLElement {\n  type?: string\n  value?: string\n}\n\ninterface SelectElement extends HTMLSelectElement {\n  options: HTMLOptionsCollection\n  selectedIndex: number\n  value: string\n}\n\n// User action replay buffer\nlet actionBuffer: ActionRecord[] = []\nlet lastScrollTime = 0\nlet actionCaptureEnabled = true\nlet clickHandler: ((event: MouseEvent) => void) | null = null\nlet inputHandler: ((event: Event) => void) | null = null\nlet scrollHandler: ((event: Event) => void) | null = null\nlet keydownHandler: ((event: KeyboardEvent) => void) | null = null\nlet changeHandler: ((event: Event) => void) | null = null\n\n/**\n * Record a user action to the buffer\n */\nexport function recordAction(action: Omit<ActionRecord, 'ts'>): void {\n  if (!actionCaptureEnabled) return\n\n  actionBuffer.push({\n    ts: new Date().toISOString(),\n    ...action,\n  })\n\n  // Keep buffer size limited\n  if (actionBuffer.length > MAX_ACTION_BUFFER_SIZE) {\n    actionBuffer.shift()\n  }\n}\n\n/**\n * Get the current action buffer\n */\nexport function getActionBuffer(): ActionRecord[] {\n  return [...actionBuffer]\n}\n\n/**\n * Clear the action buffer\n */\nexport function clearActionBuffer(): void {\n  actionBuffer = []\n}\n\n/**\n * Handle click events\n */\nexport function handleClick(event: MouseEvent): void {\n  const target = event.target as Element | null\n  if (!target) return\n\n  const action: Omit<ActionRecord, 'ts'> = {\n    type: 'click',\n    target: getElementSelector(target),\n    x: event.clientX,\n    y: event.clientY,\n  }\n\n  // Include button text if available (truncated)\n  const text = (target as HTMLElement).textContent || (target as HTMLElement).innerText || ''\n  if (text && text.length > 0) {\n    action.text = text.trim().slice(0, 50)\n  }\n\n  recordAction(action)\n  recordEnhancedAction('click', target)\n}\n\n/**\n * Handle input events\n */\nexport function handleInput(event: Event): void {\n  const target = event.target as InputElement | null\n  if (!target) return\n\n  const action: Omit<ActionRecord, 'ts'> = {\n    type: 'input',\n    target: getElementSelector(target),\n    inputType: target.type || 'text',\n  }\n\n  // Only include value for non-sensitive fields\n  if (!isSensitiveInput(target)) {\n    const value = target.value || ''\n    action.value = value.slice(0, 100)\n    action.length = value.length\n  } else {\n    action.value = '[redacted]'\n    action.length = (target.value || '').length\n  }\n\n  recordAction(action)\n  recordEnhancedAction('input', target, { value: action.value })\n}\n\n/**\n * Handle scroll events (throttled)\n */\nexport function handleScroll(event: Event): void {\n  const now = Date.now()\n  if (now - lastScrollTime < SCROLL_THROTTLE_MS) return\n  lastScrollTime = now\n\n  const target = event.target\n  recordAction({\n    type: 'scroll',\n    scrollX: Math.round(window.scrollX),\n    scrollY: Math.round(window.scrollY),\n    target: target === document ? 'document' : getElementSelector(target as Element),\n  })\n  recordEnhancedAction('scroll', null, { scrollY: Math.round(window.scrollY) })\n}\n\n/**\n * Handle keydown events - only records actionable keys\n */\nexport function handleKeydown(event: KeyboardEvent): void {\n  if (!ACTIONABLE_KEYS.has(event.key)) return\n  const target = event.target as Element | null\n  recordEnhancedAction('keypress', target, { key: event.key })\n}\n\n/**\n * Handle change events on select elements\n */\nexport function handleChange(event: Event): void {\n  const target = event.target as SelectElement | null\n  if (!target || !target.tagName || target.tagName.toUpperCase() !== 'SELECT') return\n\n  const selectedOption = target.options && target.options[target.selectedIndex]\n  const selectedValue = target.value || ''\n  const selectedText = selectedOption ? selectedOption.text || '' : ''\n\n  recordEnhancedAction('select', target, { selectedValue, selectedText })\n}\n\n/**\n * Install user action capture\n */\nexport function installActionCapture(): void {\n  if (typeof window === 'undefined' || typeof document === 'undefined') return\n  if (typeof document.addEventListener !== 'function') return\n\n  clickHandler = handleClick\n  inputHandler = handleInput\n  scrollHandler = handleScroll\n  keydownHandler = handleKeydown\n  changeHandler = handleChange\n\n  document.addEventListener('click', clickHandler, { capture: true, passive: true })\n  document.addEventListener('input', inputHandler, { capture: true, passive: true })\n  document.addEventListener('keydown', keydownHandler, { capture: true, passive: true })\n  document.addEventListener('change', changeHandler, { capture: true, passive: true })\n  window.addEventListener('scroll', scrollHandler, { capture: true, passive: true })\n}\n\n/**\n * Uninstall user action capture\n */\nexport function uninstallActionCapture(): void {\n  if (clickHandler) {\n    document.removeEventListener('click', clickHandler, { capture: true })\n    clickHandler = null\n  }\n  if (inputHandler) {\n    document.removeEventListener('input', inputHandler, { capture: true })\n    inputHandler = null\n  }\n  if (keydownHandler) {\n    document.removeEventListener('keydown', keydownHandler, { capture: true })\n    keydownHandler = null\n  }\n  if (changeHandler) {\n    document.removeEventListener('change', changeHandler, { capture: true })\n    changeHandler = null\n  }\n  if (scrollHandler) {\n    window.removeEventListener('scroll', scrollHandler, { capture: true })\n    scrollHandler = null\n  }\n  clearActionBuffer()\n}\n\n/**\n * Set whether action capture is enabled\n */\nexport function setActionCaptureEnabled(enabled: boolean): void {\n  actionCaptureEnabled = enabled\n  if (!enabled) {\n    clearActionBuffer()\n  }\n}\n\n// =============================================================================\n// NAVIGATION CAPTURE\n// =============================================================================\n\nlet navigationPopstateHandler: (() => void) | null = null\nlet originalPushState: typeof history.pushState | null = null\nlet originalReplaceState: typeof history.replaceState | null = null\n\n/**\n * Install navigation capture to record enhanced actions on navigation events\n */\nexport function installNavigationCapture(): void {\n  if (typeof window === 'undefined') return\n\n  // Track current URL for fromUrl\n  let lastUrl = window.location.href\n\n  // Popstate handler (back/forward)\n  navigationPopstateHandler = function (): void {\n    const toUrl = window.location.href\n    recordEnhancedAction('navigate', null, { fromUrl: lastUrl, toUrl })\n    lastUrl = toUrl\n  }\n  window.addEventListener('popstate', navigationPopstateHandler)\n\n  // Patch pushState\n  if (window.history && window.history.pushState) {\n    originalPushState = window.history.pushState\n    window.history.pushState = function (\n      this: History,\n      state: unknown,\n      title: string,\n      url?: string | URL | null\n    ): void {\n      const fromUrl = lastUrl\n      originalPushState!.call(this, state, title, url)\n      const toUrl = url || window.location.href\n      recordEnhancedAction('navigate', null, { fromUrl, toUrl: String(toUrl) })\n      lastUrl = window.location.href\n    }\n  }\n\n  // Patch replaceState\n  if (window.history && window.history.replaceState) {\n    originalReplaceState = window.history.replaceState\n    window.history.replaceState = function (\n      this: History,\n      state: unknown,\n      title: string,\n      url?: string | URL | null\n    ): void {\n      const fromUrl = lastUrl\n      originalReplaceState!.call(this, state, title, url)\n      const toUrl = url || window.location.href\n      recordEnhancedAction('navigate', null, { fromUrl, toUrl: String(toUrl) })\n      lastUrl = window.location.href\n    }\n  }\n}\n\n/**\n * Uninstall navigation capture\n */\nexport function uninstallNavigationCapture(): void {\n  if (navigationPopstateHandler) {\n    window.removeEventListener('popstate', navigationPopstateHandler)\n    navigationPopstateHandler = null\n  }\n  if (originalPushState && window.history) {\n    window.history.pushState = originalPushState\n    originalPushState = null\n  }\n  if (originalReplaceState && window.history) {\n    window.history.replaceState = originalReplaceState\n    originalReplaceState = null\n  }\n}\n", "/**\n * @fileoverview Network waterfall and body capture.\n * Provides PerformanceResourceTiming parsing, pending request tracking,\n * fetch body capture with size limits, and sensitive header sanitization.\n */\n\nimport type {\n  WaterfallEntry,\n  WaterfallPhases,\n  PendingRequest,\n} from '../types/index';\n\nimport {\n  MAX_WATERFALL_ENTRIES,\n  WATERFALL_TIME_WINDOW_MS,\n  REQUEST_BODY_MAX,\n  RESPONSE_BODY_MAX,\n  BODY_READ_TIMEOUT_MS,\n  SENSITIVE_HEADER_PATTERNS,\n  BINARY_CONTENT_TYPES,\n} from './constants.js';\n\n// =============================================================================\n// TYPE DEFINITIONS\n// =============================================================================\n\n/**\n * Options for filtering network waterfall entries\n */\ninterface WaterfallFilterOptions {\n  since?: number;\n  initiatorTypes?: string[];\n}\n\n/**\n * Truncation result for request/response bodies\n */\ninterface TruncationResult {\n  body: string | null;\n  truncated: boolean;\n}\n\n/**\n * Internal pending request tracking with mutable id\n */\ninterface InternalPendingRequest {\n  id: string;\n  url: string;\n  method: string;\n  startTime: number;\n}\n\n/**\n * Request info for tracking\n */\ninterface RequestInfo {\n  url: string;\n  method: string;\n  startTime: number;\n}\n\n/**\n * Network body payload posted to content script\n */\ninterface NetworkBodyPostMessage {\n  type: 'GASOLINE_NETWORK_BODY';\n  payload: {\n    url: string;\n    method: string;\n    status: number;\n    contentType: string;\n    requestBody?: string;\n    responseBody?: string;\n    duration: number;\n  };\n}\n\n// =============================================================================\n// MODULE STATE\n// =============================================================================\n\n// Configured server URL for filtering (updated via setServerUrl)\nlet configuredServerUrl = '';\n\n// Network Waterfall state\nlet networkWaterfallEnabled = false;\nconst pendingRequests = new Map<string, InternalPendingRequest>(); // requestId -> { url, method, startTime }\nlet requestIdCounter = 0;\n\n// Network body capture state\nlet networkBodyCaptureEnabled = true; // Default: capture request/response bodies\n\n// =============================================================================\n// NETWORK WATERFALL\n// =============================================================================\n\n/**\n * Parse a PerformanceResourceTiming entry into waterfall phases\n * @param timing - The timing entry\n * @returns Parsed waterfall entry\n */\nexport function parseResourceTiming(timing: PerformanceResourceTiming): WaterfallEntry {\n  const phases: WaterfallPhases = {\n    dns: Math.max(0, timing.domainLookupEnd - timing.domainLookupStart),\n    connect: Math.max(0, timing.connectEnd - timing.connectStart),\n    tls: timing.secureConnectionStart > 0 ? Math.max(0, timing.connectEnd - timing.secureConnectionStart) : 0,\n    ttfb: Math.max(0, timing.responseStart - timing.requestStart),\n    download: Math.max(0, timing.responseEnd - timing.responseStart),\n  };\n\n  const result: WaterfallEntry = {\n    url: timing.name,\n    initiatorType: timing.initiatorType,\n    startTime: timing.startTime,\n    duration: timing.duration,\n    phases,\n    transferSize: timing.transferSize || 0,\n    encodedBodySize: timing.encodedBodySize || 0,\n    decodedBodySize: timing.decodedBodySize || 0,\n  };\n\n  // Detect cache hit\n  if (timing.transferSize === 0 && timing.encodedBodySize > 0) {\n    (result as { cached?: boolean }).cached = true;\n  }\n\n  return result;\n}\n\n/**\n * Get network waterfall entries\n * @param options - Options for filtering\n * @returns Array of waterfall entries\n */\nexport function getNetworkWaterfall(options: WaterfallFilterOptions = {}): WaterfallEntry[] {\n  if (typeof performance === 'undefined' || !performance) return [];\n\n  try {\n    let entries = performance.getEntriesByType('resource') as PerformanceResourceTiming[] || [];\n\n    // Filter by time range\n    if (options.since) {\n      entries = entries.filter((e) => e.startTime >= options.since!);\n    }\n\n    // Filter by initiator type\n    if (options.initiatorTypes) {\n      entries = entries.filter((e) => options.initiatorTypes!.includes(e.initiatorType));\n    }\n\n    // Exclude data URLs\n    entries = entries.filter((e) => !e.name.startsWith('data:'));\n\n    // Sort by start time\n    entries.sort((a, b) => a.startTime - b.startTime);\n\n    // Limit entries\n    if (entries.length > MAX_WATERFALL_ENTRIES) {\n      entries = entries.slice(-MAX_WATERFALL_ENTRIES);\n    }\n\n    return entries.map(parseResourceTiming);\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Track a pending request\n * @param request - Request info { url, method, startTime }\n * @returns Request ID\n */\nexport function trackPendingRequest(request: RequestInfo): string {\n  const id = `req_${++requestIdCounter}`;\n  pendingRequests.set(id, {\n    ...request,\n    id,\n  });\n  return id;\n}\n\n/**\n * Complete a pending request\n * @param requestId - The request ID to complete\n */\nexport function completePendingRequest(requestId: string): void {\n  pendingRequests.delete(requestId);\n}\n\n/**\n * Get all pending requests\n * @returns Array of pending requests\n */\nexport function getPendingRequests(): PendingRequest[] {\n  return Array.from(pendingRequests.values());\n}\n\n/**\n * Clear all pending requests\n */\nexport function clearPendingRequests(): void {\n  pendingRequests.clear();\n}\n\n/**\n * Network waterfall snapshot for an error\n */\ninterface NetworkWaterfallSnapshot {\n  type: 'network_waterfall';\n  ts: string;\n  _errorTs: string;\n  entries: WaterfallEntry[];\n  pending: PendingRequest[];\n}\n\n/**\n * Error entry with timestamp\n */\ninterface ErrorEntry {\n  ts: string;\n}\n\n/**\n * Get network waterfall snapshot for an error\n * @param errorEntry - The error entry\n * @returns The waterfall snapshot\n */\nexport async function getNetworkWaterfallForError(errorEntry: ErrorEntry): Promise<NetworkWaterfallSnapshot | null> {\n  if (!networkWaterfallEnabled) return null;\n\n  const now = typeof performance !== 'undefined' && performance?.now ? performance.now() : 0;\n  const since = Math.max(0, now - WATERFALL_TIME_WINDOW_MS);\n\n  const entries = getNetworkWaterfall({ since });\n  const pending = getPendingRequests();\n\n  return {\n    type: 'network_waterfall',\n    ts: new Date().toISOString(),\n    _errorTs: errorEntry.ts,\n    entries,\n    pending,\n  };\n}\n\n/**\n * Set whether network waterfall is enabled\n * @param enabled - Whether to enable network waterfall\n */\nexport function setNetworkWaterfallEnabled(enabled: boolean): void {\n  networkWaterfallEnabled = enabled;\n}\n\n/**\n * Check if network waterfall is enabled\n * @returns Whether network waterfall is enabled\n */\nexport function isNetworkWaterfallEnabled(): boolean {\n  return networkWaterfallEnabled;\n}\n\n// =============================================================================\n// NETWORK BODY CAPTURE\n// =============================================================================\n\n/**\n * Set whether network body capture is enabled\n * @param enabled - Whether to enable body capture\n */\nexport function setNetworkBodyCaptureEnabled(enabled: boolean): void {\n  networkBodyCaptureEnabled = enabled;\n}\n\n/**\n * Check if network body capture is enabled\n * @returns Whether body capture is enabled\n */\nexport function isNetworkBodyCaptureEnabled(): boolean {\n  return networkBodyCaptureEnabled;\n}\n\n/**\n * Set the configured server URL for capture filtering.\n * Called when the server URL is loaded from settings.\n * @param url - The server URL (e.g., 'http://localhost:7890')\n */\nexport function setServerUrl(url: string): void {\n  configuredServerUrl = url || '';\n}\n\n/**\n * Check if a URL should be captured (not gasoline server or extension)\n * @param url - The URL to check\n * @returns True if the URL should be captured\n */\nexport function shouldCaptureUrl(url: string): boolean {\n  if (!url) return true;\n  // Filter against the configured server URL if set\n  if (configuredServerUrl) {\n    try {\n      const serverParsed = new URL(configuredServerUrl);\n      const hostPort = serverParsed.host; // e.g., 'localhost:7890'\n      if (url.includes(hostPort)) return false;\n    } catch {\n      // Fall through to hardcoded defaults\n    }\n  }\n  // Hardcoded fallback for default server URL\n  if (url.includes('localhost:7890') || url.includes('127.0.0.1:7890')) return false;\n  if (url.startsWith('chrome-extension://')) return false;\n  return true;\n}\n\n/**\n * Sanitize headers by removing sensitive ones\n * @param headers - Headers to sanitize\n * @returns Sanitized headers object\n */\nexport function sanitizeHeaders(headers: HeadersInit | Headers | Record<string, string> | null): Record<string, string> {\n  if (!headers) return {};\n\n  const result: Record<string, string> = {};\n\n  if (headers instanceof Headers || (typeof (headers as unknown as Headers).forEach === 'function')) {\n    // Headers object or Map\n    (headers as unknown as Headers).forEach((value: string, key: string) => {\n      if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n        result[key] = value;\n      }\n    });\n  } else if (typeof (headers as { entries?: () => Iterable<[string, string]> }).entries === 'function') {\n    for (const [key, value] of (headers as { entries: () => Iterable<[string, string]> }).entries()) {\n      if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n        result[key] = value;\n      }\n    }\n  } else if (typeof headers === 'object') {\n    for (const [key, value] of Object.entries(headers as Record<string, string>)) {\n      if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n        result[key] = value;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Truncate request body at 8KB limit\n * @param body - The request body\n * @returns Truncation result\n */\nexport function truncateRequestBody(body: string | null | undefined): TruncationResult {\n  if (body === null || body === undefined) return { body: null, truncated: false };\n  if (body.length <= REQUEST_BODY_MAX) return { body, truncated: false };\n  return { body: body.slice(0, REQUEST_BODY_MAX), truncated: true };\n}\n\n/**\n * Truncate response body at 16KB limit\n * @param body - The response body\n * @returns Truncation result\n */\nexport function truncateResponseBody(body: string | null | undefined): TruncationResult {\n  if (body === null || body === undefined) return { body: null, truncated: false };\n  if (body.length <= RESPONSE_BODY_MAX) return { body, truncated: false };\n  return { body: body.slice(0, RESPONSE_BODY_MAX), truncated: true };\n}\n\n/**\n * Read a response body, returning text for text types and size info for binary\n * @param response - The cloned response object\n * @returns The body content or binary size placeholder\n */\nexport async function readResponseBody(response: Response): Promise<string> {\n  const contentType = response.headers?.get?.('content-type') || '';\n\n  if (BINARY_CONTENT_TYPES.test(contentType)) {\n    const blob = await response.blob();\n    return `[Binary: ${blob.size} bytes, ${contentType}]`;\n  }\n\n  // Text-like or unknown content type: try reading as text\n  return await response.text();\n}\n\n/**\n * Read response body with a timeout\n * @param response - The cloned response object\n * @param timeoutMs - Timeout in milliseconds\n * @returns The body or timeout message\n */\nexport async function readResponseBodyWithTimeout(response: Response, timeoutMs: number = BODY_READ_TIMEOUT_MS): Promise<string> {\n  return Promise.race([\n    readResponseBody(response),\n    new Promise<string>((resolve) => {\n      setTimeout(() => resolve('[Skipped: body read timeout]'), timeoutMs);\n    }),\n  ]);\n}\n\n/**\n * Reset all module state for testing purposes\n * Clears pending requests, resets counters, and restores default settings.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting(): void {\n  configuredServerUrl = '';\n  networkWaterfallEnabled = false;\n  pendingRequests.clear();\n  requestIdCounter = 0;\n  networkBodyCaptureEnabled = true;\n}\n\n/**\n * Wrap a fetch function to capture request/response bodies\n * @param fetchFn - The original fetch function\n * @returns Wrapped fetch that captures bodies\n */\nexport function wrapFetchWithBodies(fetchFn: typeof fetch): any {\n  return async function (input: any, init?: RequestInit): Promise<Response> {\n    const startTime = Date.now();\n\n    // Extract URL and method\n    let url = '';\n    let method = 'GET';\n    let requestBody: BodyInit | null | undefined = null;\n\n    if (typeof input === 'string') {\n      url = input;\n    } else if (input && (input as unknown as Request).url) {\n      url = (input as unknown as Request).url;\n      method = (input as unknown as Request).method || 'GET';\n    }\n\n    if (init) {\n      method = init.method || method;\n      requestBody = init.body || null;\n    }\n\n    // Skip gasoline server requests\n    if (!shouldCaptureUrl(url)) {\n      return fetchFn(input, init);\n    }\n\n    // Call original fetch\n    const response = await fetchFn(input, init);\n    const duration = Date.now() - startTime;\n\n    // Capture body asynchronously (don't block return)\n    const contentType = response.headers?.get?.('content-type') || '';\n    const cloned = response.clone ? response.clone() : null;\n    // Capture window reference now so deferred callback posts to correct target\n    const win = typeof window !== 'undefined' ? window : null;\n\n    Promise.resolve()\n      .then(async () => {\n        try {\n          let responseBody = '';\n          if (cloned) {\n            if (BINARY_CONTENT_TYPES.test(contentType)) {\n              const blob = await cloned.blob();\n              responseBody = `[Binary: ${blob.size} bytes, ${contentType}]`;\n            } else {\n              responseBody = await readResponseBodyWithTimeout(cloned);\n            }\n          }\n\n          const { body: truncResp } = truncateResponseBody(responseBody);\n          const { body: truncReq } = truncateRequestBody(typeof requestBody === 'string' ? requestBody : null);\n\n          if (win && networkBodyCaptureEnabled) {\n            const message: NetworkBodyPostMessage = {\n              type: 'GASOLINE_NETWORK_BODY',\n              payload: {\n                url,\n                method,\n                status: response.status,\n                contentType,\n                requestBody: truncReq || (typeof requestBody === 'string' ? requestBody : undefined),\n                responseBody: truncResp || responseBody,\n                duration,\n              },\n            };\n            win.postMessage(message, '*');\n          }\n        } catch {\n          // Body capture failure should not affect user code\n        }\n      })\n      .catch((err: Error) => {\n        // Log but don't throw - body capture is best-effort\n        console.debug('[Gasoline] Network body capture error:', err);\n      });\n\n    return response;\n  };\n}\n", "/**\n * @fileoverview Performance marks and measures capture.\n * Wraps performance.mark/measure to capture calls, uses PerformanceObserver\n * for additional entries, and provides error-time performance snapshots.\n */\n\nimport { MAX_PERFORMANCE_ENTRIES, PERFORMANCE_TIME_WINDOW_MS } from './constants';\nimport type { PerformanceMark, PerformanceMeasure } from '../types/index';\n\n// Performance Marks state\nlet performanceMarksEnabled = false;\nlet capturedMarks: Array<PerformanceMark & { detail?: unknown; capturedAt: string }> = [];\nlet capturedMeasures: Array<PerformanceMeasure & { capturedAt: string }> = [];\nlet originalPerformanceMark: ((name: string, options?: PerformanceMarkOptions) => PerformanceMark) | null = null;\nlet originalPerformanceMeasure: ((name: string, startMark?: string, endMark?: string) => PerformanceMeasure) | null = null;\nlet performanceObserver: PerformanceObserver | null = null;\nlet performanceCaptureActive = false;\n\n/**\n * Get performance marks\n */\nexport function getPerformanceMarks(options: { since?: number } = {}): Array<Omit<PerformanceMark, 'entryType'> & { detail?: unknown | null }> {\n  if (typeof performance === 'undefined' || !performance) return [];\n\n  try {\n    let marks = (performance.getEntriesByType('mark') as PerformanceEntry[]) || [];\n\n    // Filter by time range\n    if (options.since) {\n      marks = marks.filter((m) => m.startTime >= options.since!);\n    }\n\n    // Sort by start time\n    marks.sort((a, b) => a.startTime - b.startTime);\n\n    // Limit entries\n    if (marks.length > MAX_PERFORMANCE_ENTRIES) {\n      marks = marks.slice(-MAX_PERFORMANCE_ENTRIES);\n    }\n\n    return marks.map((m) => ({\n      name: m.name,\n      startTime: m.startTime,\n      detail: (m as PerformanceEntry & { detail?: unknown }).detail || null,\n    }));\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get performance measures\n */\nexport function getPerformanceMeasures(options: { since?: number } = {}): Array<Omit<PerformanceMeasure, 'entryType'>> {\n  if (typeof performance === 'undefined' || !performance) return [];\n\n  try {\n    let measures = (performance.getEntriesByType('measure') as PerformanceEntry[]) || [];\n\n    // Filter by time range\n    if (options.since) {\n      measures = measures.filter((m) => m.startTime >= options.since!);\n    }\n\n    // Sort by start time\n    measures.sort((a, b) => a.startTime - b.startTime);\n\n    // Limit entries\n    if (measures.length > MAX_PERFORMANCE_ENTRIES) {\n      measures = measures.slice(-MAX_PERFORMANCE_ENTRIES);\n    }\n\n    return measures.map((m) => ({\n      name: m.name,\n      startTime: m.startTime,\n      duration: m.duration,\n    }));\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Get captured marks from wrapper\n */\nexport function getCapturedMarks(): Array<PerformanceMark & { detail?: unknown; capturedAt: string }> {\n  return [...capturedMarks];\n}\n\n/**\n * Get captured measures from wrapper\n */\nexport function getCapturedMeasures(): Array<PerformanceMeasure & { capturedAt: string }> {\n  return [...capturedMeasures];\n}\n\n/**\n * Install performance capture wrapper\n */\nexport function installPerformanceCapture(): void {\n  if (typeof performance === 'undefined' || !performance) return;\n\n  // Guard against double installation (prevents infinite recursion)\n  if (performanceCaptureActive) {\n    console.warn('[Gasoline] Performance capture already installed, skipping');\n    return;\n  }\n\n  // Clear previous captured data\n  capturedMarks = [];\n  capturedMeasures = [];\n\n  // Store originals\n  originalPerformanceMark = performance.mark.bind(performance) as (name: string, options?: PerformanceMarkOptions) => PerformanceMark;\n  originalPerformanceMeasure = performance.measure.bind(performance) as (name: string, startMark?: string, endMark?: string) => PerformanceMeasure;\n\n  // Wrap performance.mark\n  (performance.mark as any) = function (name: string, options?: PerformanceMarkOptions): PerformanceMark {\n    const result = originalPerformanceMark!.call(performance, name, options) as PerformanceMark;\n\n    capturedMarks.push({\n      name,\n      startTime: (result as PerformanceEntry).startTime || performance.now(),\n      entryType: 'mark',\n      detail: (options as any)?.detail || undefined,\n      capturedAt: new Date().toISOString(),\n    });\n\n    // Limit captured marks\n    if (capturedMarks.length > MAX_PERFORMANCE_ENTRIES) {\n      capturedMarks.shift();\n    }\n\n    return result;\n  };\n\n  // Wrap performance.measure\n  (performance.measure as any) = function (name: string, startMark?: string, endMark?: string): PerformanceMeasure {\n    const result = originalPerformanceMeasure!.call(performance, name, startMark, endMark) as PerformanceMeasure;\n\n    capturedMeasures.push({\n      name,\n      startTime: result.startTime || 0,\n      duration: result.duration || 0,\n      entryType: 'measure',\n      capturedAt: new Date().toISOString(),\n    });\n\n    // Limit captured measures\n    if (capturedMeasures.length > MAX_PERFORMANCE_ENTRIES) {\n      capturedMeasures.shift();\n    }\n\n    return result;\n  };\n\n  performanceCaptureActive = true;\n\n  // Try to use PerformanceObserver for additional entries\n  if (typeof window !== 'undefined' && (window as any).PerformanceObserver) {\n    try {\n      performanceObserver = new (window as any).PerformanceObserver((list: PerformanceObserverEntryList): void => {\n        for (const entry of list.getEntries()) {\n          if (entry.entryType === 'mark') {\n            // Avoid duplicates from our wrapper\n            if (!capturedMarks.some((m) => m.name === entry.name && m.startTime === entry.startTime)) {\n              capturedMarks.push({\n                name: entry.name,\n                startTime: entry.startTime,\n                entryType: 'mark',\n                detail: (entry as any).detail || undefined,\n                capturedAt: new Date().toISOString(),\n              });\n            }\n          } else if (entry.entryType === 'measure') {\n            if (!capturedMeasures.some((m) => m.name === entry.name && m.startTime === entry.startTime)) {\n              capturedMeasures.push({\n                name: entry.name,\n                startTime: entry.startTime,\n                duration: entry.duration,\n                entryType: 'measure',\n                capturedAt: new Date().toISOString(),\n              });\n            }\n          }\n        }\n      });\n      if (performanceObserver) {\n        performanceObserver.observe({ entryTypes: ['mark', 'measure'] });\n      }\n    } catch {\n      // PerformanceObserver not supported, continue without it\n    }\n  }\n}\n\n/**\n * Uninstall performance capture wrapper\n */\nexport function uninstallPerformanceCapture(): void {\n  if (typeof performance === 'undefined' || !performance) return;\n\n  if (originalPerformanceMark) {\n    performance.mark = originalPerformanceMark as any;\n    originalPerformanceMark = null;\n  }\n\n  if (originalPerformanceMeasure) {\n    performance.measure = originalPerformanceMeasure as any;\n    originalPerformanceMeasure = null;\n  }\n\n  if (performanceObserver) {\n    performanceObserver.disconnect();\n    performanceObserver = null;\n  }\n\n  capturedMarks = [];\n  capturedMeasures = [];\n  performanceCaptureActive = false;\n}\n\n/**\n * Check if performance capture is active\n */\nexport function isPerformanceCaptureActive(): boolean {\n  return performanceCaptureActive;\n}\n\ninterface PerformanceSnapshot {\n  type: 'performance';\n  ts: string;\n  _enrichments: readonly string[];\n  _errorTs?: string;\n  marks: Array<Omit<PerformanceMark, 'entryType'> & { detail?: unknown | null }>;\n  measures: Array<Omit<PerformanceMeasure, 'entryType'>>;\n  navigation: {\n    type?: string;\n    startTime: number;\n    domContentLoadedEventEnd: number;\n    loadEventEnd: number;\n  } | null;\n}\n\n/**\n * Get performance snapshot for an error\n */\nexport async function getPerformanceSnapshotForError(errorEntry: { ts?: string }): Promise<PerformanceSnapshot | null> {\n  if (!performanceMarksEnabled) return null;\n\n  const now = typeof performance !== 'undefined' && performance?.now ? performance.now() : 0;\n  const since = Math.max(0, now - PERFORMANCE_TIME_WINDOW_MS);\n\n  const marks = getPerformanceMarks({ since });\n  const measures = getPerformanceMeasures({ since });\n\n  // Include navigation timing if available\n  let navigation: PerformanceSnapshot['navigation'] = null;\n  if (typeof performance !== 'undefined' && performance) {\n    try {\n      const navEntries = (performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]) || [];\n      if (navEntries && navEntries.length > 0) {\n        const nav = navEntries[0];\n        if (nav) {\n          navigation = {\n            type: nav.type,\n            startTime: nav.startTime,\n            domContentLoadedEventEnd: nav.domContentLoadedEventEnd,\n            loadEventEnd: nav.loadEventEnd,\n          };\n        }\n      }\n    } catch {\n      // Navigation timing not available\n    }\n  }\n\n  return {\n    type: 'performance',\n    ts: new Date().toISOString(),\n    _enrichments: ['performanceMarks'],\n    _errorTs: errorEntry.ts,\n    marks,\n    measures,\n    navigation,\n  };\n}\n\n/**\n * Set whether performance marks are enabled\n */\nexport function setPerformanceMarksEnabled(enabled: boolean): void {\n  performanceMarksEnabled = enabled;\n}\n\n/**\n * Check if performance marks are enabled\n */\nexport function isPerformanceMarksEnabled(): boolean {\n  return performanceMarksEnabled;\n}\n", "/**\n * @fileoverview Message bridge for posting log events to the content script.\n * Enriches error-level messages with context annotations and user action replay.\n */\n\nimport { getContextAnnotations } from './context';\nimport { getActionBuffer } from './actions';\n\nexport interface BridgePayload {\n  level?: string;\n  message?: string;\n  error?: string;\n  args?: unknown[];\n  filename?: string;\n  lineno?: number;\n  [key: string]: unknown;\n}\n\n/**\n * Post a log message to the content script\n */\nexport function postLog(payload: BridgePayload): void {\n  // Include context annotations and action replay for errors\n  const context = getContextAnnotations();\n  const actions = payload.level === 'error' ? getActionBuffer() : null;\n\n  // Build enrichments list to help AI understand what data is attached\n  const enrichments: string[] = [];\n  if (context && payload.level === 'error') enrichments.push('context');\n  if (actions && actions.length > 0) enrichments.push('userActions');\n\n  // Extract fields we want from payload (exclude ts, message, source, url to avoid overwriting enrichments)\n  const { level, type, args, error, stack, ...otherFields } = payload;\n\n  window.postMessage(\n    {\n      type: 'GASOLINE_LOG',\n      payload: {\n        // Enriched fields (these are the source of truth)\n        ts: new Date().toISOString(),\n        url: window.location.href,\n        message:\n          payload.message ||\n          payload.error ||\n          (payload.args?.[0] !== null && payload.args?.[0] !== undefined ? String(payload.args[0]) : ''),\n        source: payload.filename ? `${payload.filename}:${payload.lineno || 0}` : '',\n        // Core fields from payload\n        level,\n        ...(type ? { type } : {}),\n        ...(args ? { args } : {}),\n        ...(error ? { error } : {}),\n        ...(stack ? { stack } : {}),\n        // Optional enrichments\n        ...(enrichments.length > 0 ? { _enrichments: enrichments } : {}),\n        ...(context && payload.level === 'error' ? { _context: context } : {}),\n        ...(actions && actions.length > 0 ? { _actions: actions } : {}),\n        // Any other fields from payload (excluding the ones we destructured)\n        ...otherFields,\n      },\n    },\n    '*',\n  );\n}\n", "/**\n * @fileoverview Console method capture.\n * Monkey-patches console.log/warn/error/info/debug to capture messages\n * and forward them via postLog, while preserving original behavior.\n */\n\nimport { safeSerialize } from './serialize';\nimport { postLog } from './bridge';\n\ntype ConsoleMethods = 'log' | 'warn' | 'error' | 'info' | 'debug';\n\n// Store original methods\nlet originalConsole: Partial<Record<ConsoleMethods, (...args: unknown[]) => void>> = {};\n\n/**\n * Install console capture hooks\n */\nexport function installConsoleCapture(): void {\n  const methods: ConsoleMethods[] = ['log', 'warn', 'error', 'info', 'debug'];\n\n  methods.forEach((method) => {\n    // eslint-disable-next-line security/detect-object-injection -- method from known-safe local array of console methods\n    originalConsole[method] = console[method];\n\n    // eslint-disable-next-line security/detect-object-injection -- method from known-safe local array of console methods\n    console[method] = function (...args: unknown[]): void {\n      // Post to extension\n      postLog({\n        level: method,\n        type: 'console',\n        args: args.map((arg) => safeSerialize(arg)),\n      });\n\n      // Call original\n      // eslint-disable-next-line security/detect-object-injection -- method from known-safe local array of console methods\n      originalConsole[method]!.apply(console, args);\n    };\n  });\n}\n\n/**\n * Uninstall console capture hooks\n */\nexport function uninstallConsoleCapture(): void {\n  Object.keys(originalConsole).forEach((method) => {\n    // eslint-disable-next-line security/detect-object-injection -- method from Object.keys of our own originalConsole storage\n    console[method as ConsoleMethods] = originalConsole[method as ConsoleMethods]!;\n  });\n  originalConsole = {};\n}\n", "/**\n * @fileoverview AI-preprocessed error enrichment pipeline.\n * Parses stack traces, resolves source maps, extracts code snippets,\n * detects UI frameworks (React/Vue/Svelte), captures state snapshots,\n * and generates AI-friendly error summaries. All within a timeout guard.\n */\n\nimport type {\n  LogEntry,\n  StackFrame,\n  SourceSnippet,\n  AiContextData,\n  ParsedSourceMap,\n} from '../types/index';\n\nimport {\n  AI_CONTEXT_SNIPPET_LINES,\n  AI_CONTEXT_MAX_LINE_LENGTH,\n  AI_CONTEXT_MAX_SNIPPETS_SIZE,\n  AI_CONTEXT_MAX_ANCESTRY_DEPTH,\n  AI_CONTEXT_MAX_PROP_KEYS,\n  AI_CONTEXT_MAX_STATE_KEYS,\n  AI_CONTEXT_MAX_RELEVANT_SLICE,\n  AI_CONTEXT_MAX_VALUE_LENGTH,\n  AI_CONTEXT_SOURCE_MAP_CACHE_SIZE,\n  AI_CONTEXT_PIPELINE_TIMEOUT_MS,\n} from './constants.js';\n\n// =============================================================================\n// TYPE DEFINITIONS\n// =============================================================================\n\n/**\n * Parsed stack frame (internal representation with nullable functionName)\n */\ninterface InternalStackFrame {\n  functionName: string | null;\n  filename: string;\n  lineno: number;\n  colno: number;\n}\n\n/**\n * Code snippet line entry\n */\ninterface SnippetLine {\n  line: number;\n  text: string;\n  isError?: boolean;\n}\n\n/**\n * Source snippet with file and line info\n */\ninterface InternalSourceSnippet {\n  file: string;\n  line: number;\n  snippet: SnippetLine[];\n}\n\n/**\n * Framework detection result\n */\ninterface FrameworkDetection {\n  framework: 'react' | 'vue' | 'svelte';\n  key?: string;\n}\n\n/**\n * React component ancestry entry\n */\ninterface ReactComponentEntry {\n  name: string;\n  propKeys?: string[];\n  hasState?: boolean;\n  stateKeys?: string[];\n}\n\n/**\n * React fiber node (partial typing for what we access)\n */\ninterface ReactFiber {\n  type?: {\n    displayName?: string;\n    name?: string;\n  } | string;\n  memoizedProps?: Record<string, unknown>;\n  memoizedState?: Record<string, unknown> | unknown[] | null;\n  return?: ReactFiber | null;\n}\n\n/**\n * Component ancestry result\n */\ninterface ComponentAncestryResult {\n  framework: 'react';\n  components: ReactComponentEntry[];\n}\n\n/**\n * Redux store interface\n */\ninterface ReduxStore {\n  getState: () => Record<string, unknown>;\n}\n\n/**\n * State snapshot result\n */\ninterface StateSnapshotResult {\n  source: 'redux';\n  keys: Record<string, { type: string }>;\n  relevantSlice: Record<string, unknown>;\n}\n\n/**\n * AI summary generation data\n */\ninterface AiSummaryData {\n  errorType: string;\n  message: string;\n  file: string | null;\n  line: number | null;\n  componentAncestry: ComponentAncestryResult | null;\n  stateSnapshot: StateSnapshotResult | null;\n}\n\n/**\n * Enriched error entry with AI context\n */\ntype EnrichedErrorEntry = LogEntry & {\n  _aiContext?: AiContextData;\n  _enrichments?: string[];\n};\n\n/**\n * Internal AI context result\n */\ninterface InternalAiContext {\n  sourceSnippets?: InternalSourceSnippet[];\n  componentAncestry?: ComponentAncestryResult;\n  stateSnapshot?: StateSnapshotResult;\n  summary: string;\n}\n\n/**\n * Element with framework markers\n */\ninterface FrameworkElement {\n  __vueParentComponent?: unknown;\n  __vue_app__?: unknown;\n  __svelte_meta?: unknown;\n  [key: string]: unknown;\n}\n\n// Extend Window interface for Redux store\ndeclare global {\n  interface Window {\n    __REDUX_STORE__?: ReduxStore;\n  }\n}\n\n// =============================================================================\n// MODULE STATE\n// =============================================================================\n\n// AI Context state\nlet aiContextEnabled = true;\nlet aiContextStateSnapshotEnabled = false;\nconst aiSourceMapCache = new Map<string, ParsedSourceMap>();\n\n// =============================================================================\n// STACK FRAME PARSING\n// =============================================================================\n\n/**\n * Parse stack trace into structured frames\n * Supports Chrome and Firefox formats\n * @param stack - The stack trace string\n * @returns Array of frame objects { functionName, filename, lineno, colno }\n */\nexport function parseStackFrames(stack: string | undefined): InternalStackFrame[] {\n  if (!stack) return [];\n\n  const frames: InternalStackFrame[] = [];\n  const lines = stack.split('\\n');\n\n  for (const line of lines) {\n    const trimmed = line.trim();\n\n    // Chrome format: \"    at functionName (url:line:col)\"\n    // or \"    at url:line:col\"\n    const chromeMatch = trimmed.match(/^at\\s+(?:(.+?)\\s+\\()?(.+?):(\\d+):(\\d+)\\)?$/);\n    if (chromeMatch) {\n      const filename = chromeMatch[2];\n      if (!filename || filename.includes('<anonymous>')) continue;\n      const lineStr = chromeMatch[3];\n      const colStr = chromeMatch[4];\n      if (!lineStr || !colStr) continue;\n      frames.push({\n        functionName: chromeMatch[1] || null,\n        filename,\n        lineno: parseInt(lineStr, 10),\n        colno: parseInt(colStr, 10),\n      });\n      continue;\n    }\n\n    // Firefox format: \"functionName@url:line:col\"\n    const firefoxMatch = trimmed.match(/^(.+?)@(.+?):(\\d+):(\\d+)$/);\n    if (firefoxMatch) {\n      const filename = firefoxMatch[2];\n      if (!filename || filename.includes('<anonymous>')) continue;\n      const lineStr = firefoxMatch[3];\n      const colStr = firefoxMatch[4];\n      if (!lineStr || !colStr) continue;\n      frames.push({\n        functionName: firefoxMatch[1] || null,\n        filename,\n        lineno: parseInt(lineStr, 10),\n        colno: parseInt(colStr, 10),\n      });\n      continue;\n    }\n  }\n\n  return frames;\n}\n\n// =============================================================================\n// SOURCE MAP PARSING\n// =============================================================================\n\n/**\n * Parse an inline base64 source map data URL\n * @param dataUrl - The data: URL containing the source map\n * @returns Parsed source map or null\n */\nexport function parseSourceMap(dataUrl: string | undefined | null): ParsedSourceMap | null {\n  if (!dataUrl || typeof dataUrl !== 'string') return null;\n  if (!dataUrl.startsWith('data:')) return null;\n\n  try {\n    // Extract base64 content after the last comma\n    const base64Match = dataUrl.match(/;base64,(.+)$/);\n    if (!base64Match || !base64Match[1]) return null;\n\n    const decoded = atob(base64Match[1]);\n    const parsed = JSON.parse(decoded) as ParsedSourceMap;\n\n    // Only useful if it has sourcesContent\n    if (!parsed.sourcesContent || parsed.sourcesContent.length === 0) return null;\n\n    return parsed;\n  } catch {\n    return null;\n  }\n}\n\n// =============================================================================\n// CODE SNIPPET EXTRACTION\n// =============================================================================\n\n/**\n * Extract a code snippet around a given line number\n * @param sourceContent - The full source file content\n * @param line - The 1-based line number of the error\n * @returns Array of { line, text, isError? } or null\n */\nexport function extractSnippet(sourceContent: string | undefined | null, line: number): SnippetLine[] | null {\n  if (!sourceContent || typeof sourceContent !== 'string') return null;\n  if (!line || line < 1) return null;\n\n  const lines = sourceContent.split('\\n');\n  if (line > lines.length) return null;\n\n  const start = Math.max(0, line - 1 - AI_CONTEXT_SNIPPET_LINES);\n  const end = Math.min(lines.length, line + AI_CONTEXT_SNIPPET_LINES);\n\n  const snippet: SnippetLine[] = [];\n  for (let i = start; i < end; i++) {\n    let text = lines[i];\n    if (!text) continue;\n    if (text.length > AI_CONTEXT_MAX_LINE_LENGTH) {\n      text = text.slice(0, AI_CONTEXT_MAX_LINE_LENGTH);\n    }\n    const entry: SnippetLine = { line: i + 1, text };\n    if (i + 1 === line) entry.isError = true;\n    snippet.push(entry);\n  }\n\n  return snippet;\n}\n\n/**\n * Source map lookup for extractSourceSnippets\n */\ntype SourceMapLookup = Record<string, ParsedSourceMap>;\n\n/**\n * Extract source snippets for multiple stack frames\n * @param frames - Parsed stack frames\n * @param mockSourceMaps - Map of filename to parsed source map\n * @returns Array of snippet objects\n */\nexport async function extractSourceSnippets(frames: InternalStackFrame[], mockSourceMaps: SourceMapLookup): Promise<InternalSourceSnippet[]> {\n  const snippets: InternalSourceSnippet[] = [];\n  let totalSize = 0;\n\n  for (const frame of frames.slice(0, 3)) {\n    if (totalSize >= AI_CONTEXT_MAX_SNIPPETS_SIZE) break;\n\n    const sourceMap = mockSourceMaps[frame.filename];\n    if (!sourceMap || !sourceMap.sourcesContent || !sourceMap.sourcesContent[0]) continue;\n\n    const snippet = extractSnippet(sourceMap.sourcesContent[0], frame.lineno);\n    if (!snippet) continue;\n\n    const snippetObj: InternalSourceSnippet = { file: frame.filename, line: frame.lineno, snippet };\n    const snippetSize = JSON.stringify(snippetObj).length;\n\n    if (totalSize + snippetSize > AI_CONTEXT_MAX_SNIPPETS_SIZE) break;\n\n    totalSize += snippetSize;\n    snippets.push(snippetObj);\n  }\n\n  return snippets;\n}\n\n// =============================================================================\n// FRAMEWORK DETECTION\n// =============================================================================\n\n/**\n * Detect which UI framework an element belongs to\n * @param element - The DOM element (or element-like object)\n * @returns { framework, key? } or null\n */\nexport function detectFramework(element: FrameworkElement | null | undefined): FrameworkDetection | null {\n  if (!element || typeof element !== 'object') return null;\n\n  // React: __reactFiber$ or __reactInternalInstance$\n  const keys = Object.keys(element);\n  const reactKey = keys.find((k) => k.startsWith('__reactFiber$') || k.startsWith('__reactInternalInstance$'));\n  if (reactKey) return { framework: 'react', key: reactKey };\n\n  // Vue 3: __vueParentComponent or __vue_app__\n  if (element.__vueParentComponent || element.__vue_app__) {\n    return { framework: 'vue' };\n  }\n\n  // Svelte: __svelte_meta\n  if (element.__svelte_meta) {\n    return { framework: 'svelte' };\n  }\n\n  return null;\n}\n\n// =============================================================================\n// REACT COMPONENT ANCESTRY\n// =============================================================================\n\n/**\n * Walk a React fiber tree to extract component ancestry\n * @param fiber - The React fiber node\n * @returns Array of { name, propKeys?, hasState?, stateKeys? } in root-first order\n */\nexport function getReactComponentAncestry(fiber: ReactFiber | null | undefined): ReactComponentEntry[] | null {\n  if (!fiber) return null;\n\n  const ancestry: ReactComponentEntry[] = [];\n  let current: ReactFiber | null | undefined = fiber;\n  let depth = 0;\n\n  while (current && depth < AI_CONTEXT_MAX_ANCESTRY_DEPTH) {\n    depth++;\n\n    // Only include component fibers (type is function/object), skip host elements (type is string)\n    if (current.type && typeof current.type !== 'string') {\n      const typeObj = current.type as { displayName?: string; name?: string };\n      const name = typeObj.displayName || typeObj.name || 'Anonymous';\n      const entry: ReactComponentEntry = { name };\n\n      // Extract prop keys (excluding children)\n      if (current.memoizedProps && typeof current.memoizedProps === 'object') {\n        entry.propKeys = Object.keys(current.memoizedProps)\n          .filter((k) => k !== 'children')\n          .slice(0, AI_CONTEXT_MAX_PROP_KEYS);\n      }\n\n      // Extract state keys\n      if (current.memoizedState && typeof current.memoizedState === 'object' && !Array.isArray(current.memoizedState)) {\n        entry.hasState = true;\n        entry.stateKeys = Object.keys(current.memoizedState as Record<string, unknown>).slice(0, AI_CONTEXT_MAX_STATE_KEYS);\n      }\n\n      ancestry.push(entry);\n    }\n\n    current = current.return;\n  }\n\n  return ancestry.reverse(); // Root-first order\n}\n\n// =============================================================================\n// STATE SNAPSHOT\n// =============================================================================\n\n/**\n * Capture application state snapshot from known store patterns\n * @param errorMessage - The error message for keyword matching\n * @returns State snapshot or null\n */\nexport function captureStateSnapshot(errorMessage: string): StateSnapshotResult | null {\n  if (typeof window === 'undefined') return null;\n\n  try {\n    // Try Redux store\n    const store = window.__REDUX_STORE__;\n    if (!store || typeof store.getState !== 'function') return null;\n\n    const state = store.getState();\n    if (!state || typeof state !== 'object') return null;\n\n    // Build keys with types\n    const keys: Record<string, { type: string }> = {};\n    for (const [key, value] of Object.entries(state)) {\n      if (Array.isArray(value)) {\n        keys[key] = { type: 'array' };\n      } else if (value === null) {\n        keys[key] = { type: 'null' };\n      } else {\n        keys[key] = { type: typeof value };\n      }\n    }\n\n    // Build relevant slice\n    const relevantSlice: Record<string, unknown> = {};\n    let sliceCount = 0;\n\n    const errorWords = (errorMessage || '')\n      .toLowerCase()\n      .split(/\\W+/)\n      .filter((w) => w.length > 2);\n\n    for (const [key, value] of Object.entries(state)) {\n      if (sliceCount >= AI_CONTEXT_MAX_RELEVANT_SLICE) break;\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        for (const [subKey, subValue] of Object.entries(value as Record<string, unknown>)) {\n          if (sliceCount >= AI_CONTEXT_MAX_RELEVANT_SLICE) break;\n\n          const isRelevantKey = ['error', 'loading', 'status', 'failed'].some((k) => subKey.toLowerCase().includes(k));\n          const isKeywordMatch = errorWords.some((w) => key.toLowerCase().includes(w));\n\n          if (isRelevantKey || isKeywordMatch) {\n            let val: unknown = subValue;\n            if (typeof val === 'string' && val.length > AI_CONTEXT_MAX_VALUE_LENGTH) {\n              val = val.slice(0, AI_CONTEXT_MAX_VALUE_LENGTH);\n            }\n            relevantSlice[`${key}.${subKey}`] = val;\n            sliceCount++;\n          }\n        }\n      }\n    }\n\n    return {\n      source: 'redux',\n      keys,\n      relevantSlice,\n    };\n  } catch {\n    return null;\n  }\n}\n\n// =============================================================================\n// AI SUMMARY GENERATION\n// =============================================================================\n\n/**\n * Generate a template-based AI summary from enrichment data\n * @param data - { errorType, message, file, line, componentAncestry, stateSnapshot }\n * @returns Summary string\n */\nexport function generateAiSummary(data: AiSummaryData): string {\n  const parts: string[] = [];\n\n  // Error type and location\n  if (data.file && data.line) {\n    parts.push(`${data.errorType} in ${data.file}:${data.line} \u2014 ${data.message}`);\n  } else {\n    parts.push(`${data.errorType}: ${data.message}`);\n  }\n\n  // Component context\n  if (data.componentAncestry && data.componentAncestry.components) {\n    const path = data.componentAncestry.components.map((c) => c.name).join(' > ');\n    parts.push(`Component tree: ${path}.`);\n  }\n\n  // State context\n  if (data.stateSnapshot && data.stateSnapshot.relevantSlice) {\n    const sliceKeys = Object.keys(data.stateSnapshot.relevantSlice);\n    if (sliceKeys.length > 0) {\n      const stateInfo = sliceKeys.map((k) => `${k}=${JSON.stringify(data.stateSnapshot!.relevantSlice[k])}`).join(', ');\n      parts.push(`State: ${stateInfo}.`);\n    }\n  }\n\n  return parts.join(' ');\n}\n\n// =============================================================================\n// ERROR ENRICHMENT PIPELINE\n// =============================================================================\n\n/**\n * Error entry for enrichment (partial typing for what we access)\n */\ninterface ErrorEntryForEnrichment {\n  stack?: string;\n  message?: string;\n}\n\n/**\n * Full error enrichment pipeline\n * @param error - The error entry to enrich\n * @returns The enriched error entry\n */\nexport async function enrichErrorWithAiContext(error: ErrorEntryForEnrichment): Promise<EnrichedErrorEntry> {\n  if (!aiContextEnabled) return error as EnrichedErrorEntry;\n\n  const enriched: EnrichedErrorEntry = { ...error } as EnrichedErrorEntry;\n\n  try {\n    // Race the entire pipeline against a timeout\n    const context = await Promise.race<InternalAiContext>([\n      (async (): Promise<InternalAiContext> => {\n        const result: Partial<InternalAiContext> = {};\n\n        // Parse stack frames\n        const frames = parseStackFrames(error.stack);\n        if (frames.length === 0) {\n          return { summary: error.message || 'Unknown error' };\n        }\n        const topFrame = frames[0];\n\n        // Source snippets (from cache)\n        if (topFrame) {\n          const cached = getSourceMapCache(topFrame.filename);\n          if (cached) {\n            const snippets = await extractSourceSnippets(frames, { [topFrame.filename]: cached });\n            if (snippets.length > 0) result.sourceSnippets = snippets;\n          }\n        }\n\n        // Component ancestry from activeElement\n        if (typeof document !== 'undefined' && document.activeElement) {\n          const framework = detectFramework(document.activeElement as unknown as FrameworkElement);\n          if (framework && framework.framework === 'react' && framework.key) {\n            const fiber = (document.activeElement as unknown as Record<string, ReactFiber>)[framework.key];\n            const components = getReactComponentAncestry(fiber);\n            if (components && components.length > 0) {\n              result.componentAncestry = { framework: 'react', components };\n            }\n          }\n        }\n\n        // State snapshot (if enabled)\n        if (aiContextStateSnapshotEnabled) {\n          const snapshot = captureStateSnapshot(error.message || '');\n          if (snapshot) result.stateSnapshot = snapshot;\n        }\n\n        // Generate summary\n        result.summary = generateAiSummary({\n          errorType: error.message?.split(':')[0] || 'Error',\n          message: error.message || '',\n          file: topFrame?.filename || null,\n          line: topFrame?.lineno || null,\n          componentAncestry: result.componentAncestry || null,\n          stateSnapshot: result.stateSnapshot || null,\n        });\n\n        return result as InternalAiContext;\n      })(),\n      new Promise<InternalAiContext>((resolve) => {\n        setTimeout(() => resolve({ summary: `${error.message || 'Error'}` }), AI_CONTEXT_PIPELINE_TIMEOUT_MS);\n      }),\n    ]);\n\n    enriched._aiContext = context as AiContextData;\n    if (!enriched._enrichments) enriched._enrichments = [];\n    enriched._enrichments.push('aiContext');\n  } catch {\n    // Pipeline failed, add minimal context\n    enriched._aiContext = { summary: error.message || 'Unknown error' };\n    if (!enriched._enrichments) enriched._enrichments = [];\n    enriched._enrichments.push('aiContext');\n  }\n\n  return enriched;\n}\n\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n\n/**\n * Enable or disable AI context enrichment\n * @param enabled\n */\nexport function setAiContextEnabled(enabled: boolean): void {\n  aiContextEnabled = enabled;\n}\n\n/**\n * Enable or disable state snapshot in AI context\n * @param enabled\n */\nexport function setAiContextStateSnapshot(enabled: boolean): void {\n  aiContextStateSnapshotEnabled = enabled;\n}\n\n// =============================================================================\n// SOURCE MAP CACHE\n// =============================================================================\n\n/**\n * Cache a parsed source map for a URL\n * @param url - The script URL\n * @param map - The parsed source map\n */\nexport function setSourceMapCache(url: string, map: ParsedSourceMap): void {\n  // Evict oldest if adding new entry and at capacity\n  if (!aiSourceMapCache.has(url) && aiSourceMapCache.size >= AI_CONTEXT_SOURCE_MAP_CACHE_SIZE) {\n    const firstKey = aiSourceMapCache.keys().next().value;\n    if (firstKey) {\n      aiSourceMapCache.delete(firstKey);\n    }\n  }\n  // Move to end (LRU): delete first if exists, then add\n  // This ensures recently accessed/updated entries are kept longest\n  aiSourceMapCache.delete(url);\n  aiSourceMapCache.set(url, map);\n}\n\n/**\n * Get a cached source map\n * @param url - The script URL\n * @returns The cached source map or null\n */\nexport function getSourceMapCache(url: string): ParsedSourceMap | null {\n  return aiSourceMapCache.get(url) || null;\n}\n\n/**\n * Get the number of cached source maps\n * @returns\n */\nexport function getSourceMapCacheSize(): number {\n  return aiSourceMapCache.size;\n}\n\n/**\n * Reset all module state for testing purposes\n * Clears source map cache and restores default settings.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting(): void {\n  aiContextEnabled = true;\n  aiContextStateSnapshotEnabled = false;\n  aiSourceMapCache.clear();\n}\n", "/**\n * @fileoverview Exception and unhandled rejection capture.\n * Monkey-patches window.onerror and listens for unhandledrejection events,\n * enriching errors with AI context before posting via bridge.\n */\n\nimport { postLog, type BridgePayload } from './bridge';\nimport { enrichErrorWithAiContext } from './ai-context';\n\ninterface ExceptionEntry extends Record<string, unknown> {\n  level: 'error';\n  type: 'exception';\n  message: string;\n  source?: string;\n  filename?: string;\n  lineno?: number;\n  colno?: number;\n  stack?: string;\n}\n\n// Exception capture state\nlet originalOnerror: OnErrorEventHandler | null = null;\nlet unhandledrejectionHandler: ((event: PromiseRejectionEvent) => void) | null = null;\n\n/**\n * Install exception capture\n */\nexport function installExceptionCapture(): void {\n  originalOnerror = window.onerror;\n\n  window.onerror = function (\n    message: string | Event,\n    filename?: string,\n    lineno?: number,\n    colno?: number,\n    error?: Error,\n  ): boolean | void {\n    const messageStr = typeof message === 'string' ? message : (message as Event).type || 'Error';\n    const entry: ExceptionEntry = {\n      level: 'error',\n      type: 'exception',\n      message: messageStr,\n      source: filename ? `${filename}:${lineno || 0}` : '',\n      filename: filename || '',\n      lineno: lineno || 0,\n      colno: colno || 0,\n      stack: error?.stack || '',\n    };\n\n    // Enrich with AI context then post (async, fire-and-forget)\n    void (async (): Promise<void> => {\n      try {\n        const enriched = await enrichErrorWithAiContext(entry);\n        postLog(enriched as unknown as BridgePayload);\n      } catch {\n        postLog(entry as unknown as BridgePayload);\n      }\n    })().catch((err: Error) => {\n      console.error('[Gasoline] Exception enrichment error:', err);\n      // Fallback: ensure entry is logged even if something fails\n      try {\n        postLog(entry as unknown as BridgePayload);\n      } catch (postErr) {\n        console.error('[Gasoline] Failed to log entry:', postErr);\n      }\n    });\n\n    // Call original if exists\n    if (originalOnerror) {\n      return originalOnerror(message, filename, lineno, colno, error);\n    }\n    return false;\n  };\n\n  // Unhandled promise rejections\n  unhandledrejectionHandler = function (event: PromiseRejectionEvent): void {\n    const error = event.reason;\n    let message = '';\n    let stack = '';\n\n    if (error instanceof Error) {\n      message = error.message;\n      stack = error.stack || '';\n    } else if (typeof error === 'string') {\n      message = error;\n    } else {\n      message = String(error);\n    }\n\n    const entry: ExceptionEntry = {\n      level: 'error',\n      type: 'exception',\n      message: `Unhandled Promise Rejection: ${message}`,\n      stack,\n    };\n\n    // Enrich with AI context then post (async, fire-and-forget)\n    void (async (): Promise<void> => {\n      try {\n        const enriched = await enrichErrorWithAiContext(entry);\n        postLog(enriched as unknown as BridgePayload);\n      } catch {\n        postLog(entry as unknown as BridgePayload);\n      }\n    })().catch((err: Error) => {\n      console.error('[Gasoline] Exception enrichment error:', err);\n      // Fallback: ensure entry is logged even if something fails\n      try {\n        postLog(entry as unknown as BridgePayload);\n      } catch (postErr) {\n        console.error('[Gasoline] Failed to log entry:', postErr);\n      }\n    });\n  };\n\n  window.addEventListener('unhandledrejection', unhandledrejectionHandler);\n}\n\n/**\n * Uninstall exception capture\n */\nexport function uninstallExceptionCapture(): void {\n  if (originalOnerror !== null) {\n    window.onerror = originalOnerror;\n    originalOnerror = null;\n  }\n\n  if (unhandledrejectionHandler) {\n    window.removeEventListener('unhandledrejection', unhandledrejectionHandler);\n    unhandledrejectionHandler = null;\n  }\n}\n", "/**\n * @fileoverview WebSocket capture.\n * Wraps the WebSocket constructor to intercept lifecycle events and messages,\n * with adaptive sampling, schema detection, and truncation.\n */\n\nimport { WS_MAX_BODY_SIZE, WS_PREVIEW_LIMIT } from './constants.js'\nimport type { WebSocketCaptureMode } from '../types/index'\n\n// Type definitions for WebSocket message data\ntype WebSocketMessageData = string | ArrayBuffer | Blob\n\n// Type for objects with a size property (like Blob)\ninterface SizedObject {\n  size: number\n}\n\n// Connection statistics\ninterface ConnectionStats {\n  incoming: {\n    count: number\n    bytes: number\n    lastPreview: string | null\n    lastAt: number | null\n  }\n  outgoing: {\n    count: number\n    bytes: number\n    lastPreview: string | null\n    lastAt: number | null\n  }\n}\n\n// Direction type\ntype MessageDirection = 'incoming' | 'outgoing'\n\n// Truncation result\ninterface TruncationResult {\n  data: string\n  truncated: boolean\n}\n\n// Sampling info\ninterface SamplingInfo {\n  rate: string\n  logged: string\n  window: string\n}\n\n// Schema info\ninterface SchemaInfo {\n  detectedKeys: string[] | null\n  consistent: boolean\n  variants?: string[]\n}\n\n// Connection tracker interface\nexport interface ConnectionTracker {\n  id: string\n  url: string\n  messageCount: number\n  _sampleCounter: number\n  _messageRate: number\n  _messageTimestamps: number[]\n  _schemaKeys: string[]\n  _schemaVariants: Map<string, number>\n  _schemaConsistent: boolean\n  _schemaDetected: boolean\n  stats: ConnectionStats\n  recordMessage(direction: MessageDirection, data: WebSocketMessageData | null): void\n  shouldSample(direction: MessageDirection): boolean\n  shouldLogLifecycle(): boolean\n  getSamplingInfo(): SamplingInfo\n  getMessageRate(): number\n  setMessageRate(rate: number): void\n  getSchema(): SchemaInfo\n  isSchemaChange(data: string | null): boolean\n}\n\n// Cached TextEncoder instance to avoid per-call allocation in getSize() hot path\nconst _textEncoder: TextEncoder | null = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null\n\n// WebSocket capture state\nlet originalWebSocket: typeof WebSocket | null = null\nlet webSocketCaptureEnabled = false\nlet webSocketCaptureMode: WebSocketCaptureMode = 'lifecycle'\n\n/**\n * Get the byte size of a WebSocket message\n */\nexport function getSize(data: WebSocketMessageData | SizedObject | null): number {\n  if (typeof data === 'string') {\n    return _textEncoder ? _textEncoder.encode(data).length : data.length\n  }\n  if (data instanceof ArrayBuffer) return data.byteLength\n  if (data && typeof data === 'object' && 'size' in data) return (data as SizedObject).size\n  return 0\n}\n\n/**\n * Format a WebSocket payload for logging\n */\nexport function formatPayload(data: WebSocketMessageData | null): string {\n  if (typeof data === 'string') return data\n\n  if (data instanceof ArrayBuffer) {\n    const bytes = new Uint8Array(data)\n    if (data.byteLength < 256) {\n      // Small binary: hex preview\n      let hex = ''\n      for (let i = 0; i < bytes.length; i++) {\n        const byte = bytes[i]\n        if (byte !== undefined) {\n          hex += byte.toString(16).padStart(2, '0')\n        }\n      }\n      return `[Binary: ${data.byteLength}B] ${hex}`\n    } else {\n      // Large binary: size + magic bytes (first 4 bytes)\n      let magic = ''\n      for (let i = 0; i < Math.min(4, bytes.length); i++) {\n        const byte = bytes[i]\n        if (byte !== undefined) {\n          magic += byte.toString(16).padStart(2, '0')\n        }\n      }\n      return `[Binary: ${data.byteLength}B, magic:${magic}]`\n    }\n  }\n\n  // Blob or Blob-like\n  if (data && typeof data === 'object' && 'size' in data) {\n    return `[Binary: ${(data as SizedObject).size}B]`\n  }\n\n  return String(data)\n}\n\n/**\n * Truncate a WebSocket message to the size limit\n */\nexport function truncateWsMessage(message: string): TruncationResult {\n  if (typeof message === 'string' && message.length > WS_MAX_BODY_SIZE) {\n    return { data: message.slice(0, WS_MAX_BODY_SIZE), truncated: true }\n  }\n  return { data: message, truncated: false }\n}\n\n/**\n * Create a connection tracker for adaptive sampling and schema detection\n */\nexport function createConnectionTracker(id: string, url: string): ConnectionTracker {\n  const tracker: ConnectionTracker = {\n    id,\n    url,\n    messageCount: 0,\n    _sampleCounter: 0,\n    _messageRate: 0,\n    _messageTimestamps: [],\n    _schemaKeys: [],\n    _schemaVariants: new Map(),\n    _schemaConsistent: true,\n    _schemaDetected: false,\n\n    stats: {\n      incoming: { count: 0, bytes: 0, lastPreview: null, lastAt: null },\n      outgoing: { count: 0, bytes: 0, lastPreview: null, lastAt: null },\n    },\n\n    /**\n     * Record a message for stats and schema detection\n     */\n    recordMessage(direction: MessageDirection, data: WebSocketMessageData | null): void {\n      this.messageCount++\n      const size = data ? (typeof data === 'string' ? data.length : getSize(data)) : 0\n      const now = Date.now()\n\n      this.stats[direction].count++\n      this.stats[direction].bytes += size\n      this.stats[direction].lastAt = now\n\n      if (data && typeof data === 'string') {\n        this.stats[direction].lastPreview = data.length > WS_PREVIEW_LIMIT ? data.slice(0, WS_PREVIEW_LIMIT) : data\n      }\n\n      // Track timestamps for rate calculation\n      this._messageTimestamps.push(now)\n      // Keep only last 5 seconds\n      const cutoff = now - 5000\n      this._messageTimestamps = this._messageTimestamps.filter((t) => t >= cutoff)\n\n      // Schema detection from first 5 incoming JSON messages\n      if (direction === 'incoming' && data && typeof data === 'string' && this._schemaKeys.length < 5) {\n        try {\n          const parsed: unknown = JSON.parse(data)\n          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n            const keys = Object.keys(parsed as object).sort()\n            const keyStr = keys.join(',')\n            this._schemaKeys.push(keyStr)\n\n            // Track variants\n            this._schemaVariants.set(keyStr, (this._schemaVariants.get(keyStr) || 0) + 1)\n\n            // Check consistency after 2+ messages\n            if (this._schemaKeys.length >= 2) {\n              const first = this._schemaKeys[0]\n              this._schemaConsistent = this._schemaKeys.every((k) => k === first)\n            }\n\n            if (this._schemaKeys.length >= 5) {\n              this._schemaDetected = true\n            }\n          }\n        } catch {\n          // Not JSON, no schema\n        }\n      }\n\n      // Track variants for messages beyond the first 5 (cap at 50 to bound memory)\n      if (direction === 'incoming' && data && typeof data === 'string' && this._schemaDetected) {\n        try {\n          const parsed: unknown = JSON.parse(data)\n          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n            const keys = Object.keys(parsed as object).sort()\n            const keyStr = keys.join(',')\n            // Only add new variants if under cap; always increment existing\n            if (this._schemaVariants.has(keyStr) || this._schemaVariants.size < 50) {\n              this._schemaVariants.set(keyStr, (this._schemaVariants.get(keyStr) || 0) + 1)\n            }\n          }\n        } catch {\n          // Not JSON\n        }\n      }\n    },\n\n    /**\n     * Determine if a message should be sampled (logged)\n     */\n    shouldSample(_direction: MessageDirection): boolean {\n      this._sampleCounter++\n\n      // Always log first 5 messages on a connection\n      if (this.messageCount > 0 && this.messageCount <= 5) return true\n\n      const rate = this._messageRate || this.getMessageRate()\n\n      if (rate < 10) return true\n      if (rate < 50) {\n        // Target ~10 msg/s\n        const n = Math.max(1, Math.round(rate / 10))\n        return this._sampleCounter % n === 0\n      }\n      if (rate < 200) {\n        // Target ~5 msg/s\n        const n = Math.max(1, Math.round(rate / 5))\n        return this._sampleCounter % n === 0\n      }\n      // > 200: target ~2 msg/s\n      const n = Math.max(1, Math.round(rate / 2))\n      return this._sampleCounter % n === 0\n    },\n\n    /**\n     * Lifecycle events should always be logged\n     */\n    shouldLogLifecycle(): boolean {\n      return true\n    },\n\n    /**\n     * Get sampling info\n     */\n    getSamplingInfo(): SamplingInfo {\n      const rate = this._messageRate || this.getMessageRate()\n      let targetRate = rate\n      if (rate >= 10 && rate < 50) targetRate = 10\n      else if (rate >= 50 && rate < 200) targetRate = 5\n      else if (rate >= 200) targetRate = 2\n\n      return {\n        rate: `${rate}/s`,\n        logged: `${targetRate}/${Math.round(rate)}`,\n        window: '5s',\n      }\n    },\n\n    /**\n     * Get the current message rate (messages per second)\n     */\n    getMessageRate(): number {\n      if (this._messageTimestamps.length < 2) return this._messageTimestamps.length\n      const lastTime = this._messageTimestamps[this._messageTimestamps.length - 1]\n      const firstTime = this._messageTimestamps[0]\n      if (lastTime === undefined || firstTime === undefined) return this._messageTimestamps.length\n      const window = (lastTime - firstTime) / 1000\n      return window > 0 ? this._messageTimestamps.length / window : this._messageTimestamps.length\n    },\n\n    /**\n     * Set the message rate manually (for testing)\n     */\n    setMessageRate(rate: number): void {\n      this._messageRate = rate\n    },\n\n    /**\n     * Get the detected schema info\n     */\n    getSchema(): SchemaInfo {\n      if (this._schemaKeys.length === 0) {\n        return { detectedKeys: null, consistent: true }\n      }\n\n      // Get union of all detected keys\n      const allKeys = new Set<string>()\n      for (const keyStr of this._schemaKeys) {\n        for (const k of keyStr.split(',')) {\n          if (k) allKeys.add(k)\n        }\n      }\n\n      // Build variants list\n      const variants: string[] = []\n      for (const [keyStr, count] of this._schemaVariants) {\n        if (count > 0) variants.push(keyStr)\n      }\n\n      return {\n        detectedKeys: allKeys.size > 0 ? Array.from(allKeys).sort() : null,\n        consistent: this._schemaConsistent,\n        variants: variants.length > 1 ? variants : undefined,\n      }\n    },\n\n    /**\n     * Check if a message represents a schema change\n     */\n    isSchemaChange(data: string | null): boolean {\n      if (!this._schemaDetected || !data || typeof data !== 'string') return false\n      try {\n        const parsed: unknown = JSON.parse(data)\n        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) return false\n        const keys = Object.keys(parsed as object).sort().join(',')\n        // It's a change if none of the first 5 schemas match\n        return !this._schemaKeys.includes(keys)\n      } catch {\n        return false\n      }\n    },\n  }\n\n  return tracker\n}\n\n// WebSocket event payload type\ninterface WsEventPayload {\n  type: 'websocket'\n  event: string\n  id: string\n  url: string\n  ts: string\n  code?: number\n  reason?: string\n  direction?: 'incoming' | 'outgoing'\n  data?: string\n  size?: number\n  truncated?: boolean\n}\n\n// PostMessage payload type\ninterface GasolineWsMessage {\n  type: 'GASOLINE_WS'\n  payload: WsEventPayload\n}\n\n/**\n * Install WebSocket capture by wrapping the WebSocket constructor\n */\nexport function installWebSocketCapture(): void {\n  if (typeof window === 'undefined') return\n  if (!window.WebSocket) return // No WebSocket support\n  if (originalWebSocket) return // Already installed\n\n  originalWebSocket = window.WebSocket\n\n  const OriginalWS = window.WebSocket\n\n  function GasolineWebSocket(this: WebSocket, url: string | URL, protocols?: string | string[]): WebSocket {\n    const ws = new OriginalWS(url, protocols)\n    const connectionId = crypto.randomUUID()\n    const urlString = url.toString()\n\n    ws.addEventListener('open', () => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: { type: 'websocket', event: 'open', id: connectionId, url: urlString, ts: new Date().toISOString() },\n        } as GasolineWsMessage,\n        '*',\n      )\n    })\n\n    ws.addEventListener('close', (event: CloseEvent) => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'close',\n            id: connectionId,\n            url: urlString,\n            code: event.code,\n            reason: event.reason,\n            ts: new Date().toISOString(),\n          },\n        } as GasolineWsMessage,\n        '*',\n      )\n    })\n\n    ws.addEventListener('error', () => {\n      if (!webSocketCaptureEnabled) return\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: { type: 'websocket', event: 'error', id: connectionId, url: urlString, ts: new Date().toISOString() },\n        } as GasolineWsMessage,\n        '*',\n      )\n    })\n\n    ws.addEventListener('message', (event: MessageEvent<WebSocketMessageData>) => {\n      if (!webSocketCaptureEnabled) return\n      if (webSocketCaptureMode !== 'messages') return\n\n      const data = event.data\n      const size = getSize(data)\n      const formatted = formatPayload(data)\n      const { data: truncatedData, truncated } = truncateWsMessage(formatted)\n\n      window.postMessage(\n        {\n          type: 'GASOLINE_WS',\n          payload: {\n            type: 'websocket',\n            event: 'message',\n            id: connectionId,\n            url: urlString,\n            direction: 'incoming',\n            data: truncatedData,\n            size,\n            truncated: truncated || undefined,\n            ts: new Date().toISOString(),\n          },\n        } as GasolineWsMessage,\n        '*',\n      )\n    })\n\n    // Wrap send() to capture outgoing messages\n    const originalSend = ws.send.bind(ws)\n    ws.send = function (data: string | ArrayBufferLike | Blob | ArrayBufferView): void {\n      if (webSocketCaptureEnabled && webSocketCaptureMode === 'messages') {\n        const size = getSize(data as WebSocketMessageData)\n        const formatted = formatPayload(data as WebSocketMessageData)\n        const { data: truncatedData, truncated } = truncateWsMessage(formatted)\n\n        window.postMessage(\n          {\n            type: 'GASOLINE_WS',\n            payload: {\n              type: 'websocket',\n              event: 'message',\n              id: connectionId,\n              url: urlString,\n              direction: 'outgoing',\n              data: truncatedData,\n              size,\n              truncated: truncated || undefined,\n              ts: new Date().toISOString(),\n            },\n          } as GasolineWsMessage,\n          '*',\n        )\n      }\n\n      return originalSend(data)\n    }\n\n    return ws\n  }\n\n  // Set up prototype chain and static properties\n  GasolineWebSocket.prototype = OriginalWS.prototype\n  Object.defineProperty(GasolineWebSocket, 'CONNECTING', { value: OriginalWS.CONNECTING, writable: false })\n  Object.defineProperty(GasolineWebSocket, 'OPEN', { value: OriginalWS.OPEN, writable: false })\n  Object.defineProperty(GasolineWebSocket, 'CLOSING', { value: OriginalWS.CLOSING, writable: false })\n  Object.defineProperty(GasolineWebSocket, 'CLOSED', { value: OriginalWS.CLOSED, writable: false })\n\n  window.WebSocket = GasolineWebSocket as unknown as typeof WebSocket\n}\n\n/**\n * Set the WebSocket capture mode\n */\nexport function setWebSocketCaptureMode(mode: WebSocketCaptureMode): void {\n  webSocketCaptureMode = mode\n}\n\n/**\n * Set WebSocket capture enabled state\n */\nexport function setWebSocketCaptureEnabled(enabled: boolean): void {\n  webSocketCaptureEnabled = enabled\n}\n\n/**\n * Get the current WebSocket capture mode\n */\nexport function getWebSocketCaptureMode(): WebSocketCaptureMode {\n  return webSocketCaptureMode\n}\n\n/**\n * Uninstall WebSocket capture, restoring the original constructor\n */\nexport function uninstallWebSocketCapture(): void {\n  if (typeof window === 'undefined') return\n  if (originalWebSocket) {\n    window.WebSocket = originalWebSocket\n    originalWebSocket = null\n  }\n}\n\n/**\n * Reset all module state for testing purposes\n * Restores original WebSocket if installed, resets capture settings to defaults.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting(): void {\n  uninstallWebSocketCapture()\n  webSocketCaptureEnabled = false\n  webSocketCaptureMode = 'lifecycle'\n  originalWebSocket = null\n}\n", "/**\n * @fileoverview On-demand DOM queries.\n * Provides structured DOM querying, page info extraction, and\n * accessibility auditing via axe-core.\n */\n\nimport {\n  DOM_QUERY_MAX_ELEMENTS,\n  DOM_QUERY_MAX_TEXT,\n  DOM_QUERY_MAX_DEPTH,\n  DOM_QUERY_MAX_HTML,\n  A11Y_MAX_NODES_PER_VIOLATION,\n  A11Y_AUDIT_TIMEOUT_MS,\n} from './constants.js'\n\n// DOM query parameters\nexport interface DOMQueryParams {\n  selector: string\n  include_styles?: boolean\n  properties?: string[]\n  include_children?: boolean\n  max_depth?: number\n}\n\n// Bounding box type\ninterface BoundingBox {\n  x: number\n  y: number\n  width: number\n  height: number\n}\n\n// Serialized DOM element entry\ninterface DOMElementEntry {\n  tag: string\n  text: string\n  visible: boolean\n  attributes?: Record<string, string>\n  boundingBox?: BoundingBox\n  styles?: Record<string, string>\n  children?: DOMElementEntry[]\n}\n\n// DOM query result\ninterface DOMQueryResult {\n  url: string\n  title: string\n  matchCount: number\n  returnedCount: number\n  matches: DOMElementEntry[]\n}\n\n// Page info result\ninterface PageInfoResult {\n  url: string\n  title: string\n  viewport: { width: number; height: number }\n  scroll: { x: number; y: number }\n  documentHeight: number\n  headings: string[]\n  links: number\n  images: number\n  interactiveElements: number\n  forms: FormInfo[]\n}\n\n// Form info\ninterface FormInfo {\n  id?: string\n  action?: string\n  fields: string[]\n}\n\n// Axe audit parameters\ninterface AxeAuditParams {\n  scope?: string\n  tags?: string[]\n  include_passes?: boolean\n}\n\n// Formatted axe node\ninterface FormattedAxeNode {\n  selector: string\n  html: string\n  failureSummary?: string\n}\n\n// Formatted axe violation\ninterface FormattedAxeViolation {\n  id: string\n  impact?: string\n  description: string\n  helpUrl: string\n  wcag?: string[]\n  nodes: FormattedAxeNode[]\n  nodeCount?: number\n}\n\n// Formatted axe results\ninterface FormattedAxeResults {\n  violations: FormattedAxeViolation[]\n  summary: {\n    violations: number\n    passes: number\n    incomplete: number\n    inapplicable: number\n  }\n  error?: string\n}\n\n// Axe-core types (minimal for our usage)\ninterface AxeNode {\n  target: string[] | string\n  html?: string\n  failureSummary?: string\n}\n\ninterface AxeViolation {\n  id: string\n  impact?: string\n  description: string\n  helpUrl: string\n  tags?: string[]\n  nodes?: AxeNode[]\n}\n\ninterface AxeResults {\n  violations?: AxeViolation[]\n  passes?: AxeViolation[]\n  incomplete?: AxeViolation[]\n  inapplicable?: AxeViolation[]\n}\n\ninterface AxeRunConfig {\n  runOnly?: string[]\n  resultTypes?: string[]\n}\n\n// Declare axe on window\ndeclare global {\n  interface Window {\n    axe?: {\n      run(context: Element | Document | { include: string[] }, config?: AxeRunConfig): Promise<AxeResults>\n    }\n  }\n}\n\n/**\n * Execute a DOM query and return structured results\n */\nexport async function executeDOMQuery(params: DOMQueryParams): Promise<DOMQueryResult> {\n  const { selector, include_styles, properties, include_children, max_depth } = params\n\n  const elements = document.querySelectorAll(selector)\n  const matchCount = elements.length\n  const cappedDepth = Math.min(max_depth || 3, DOM_QUERY_MAX_DEPTH)\n\n  const matches: DOMElementEntry[] = []\n  for (let i = 0; i < Math.min(elements.length, DOM_QUERY_MAX_ELEMENTS); i++) {\n    const el = elements[i]\n    if (!el) continue\n    const entry = serializeDOMElement(el, include_styles, properties, include_children, cappedDepth, 0)\n    matches.push(entry)\n  }\n\n  return {\n    url: window.location.href,\n    title: document.title,\n    matchCount,\n    returnedCount: matches.length,\n    matches,\n  }\n}\n\n/**\n * Serialize a DOM element to a plain object\n */\nfunction serializeDOMElement(\n  el: Element,\n  includeStyles: boolean | undefined,\n  styleProps: string[] | undefined,\n  includeChildren: boolean | undefined,\n  maxDepth: number,\n  currentDepth: number\n): DOMElementEntry {\n  const entry: DOMElementEntry = {\n    tag: el.tagName ? el.tagName.toLowerCase() : '',\n    text: (el.textContent || '').slice(0, DOM_QUERY_MAX_TEXT),\n    visible: (el as HTMLElement).offsetParent !== null || (el.getBoundingClientRect && el.getBoundingClientRect().width > 0),\n  }\n\n  // Attributes\n  if (el.attributes && el.attributes.length > 0) {\n    entry.attributes = {}\n    for (const attr of el.attributes) {\n      entry.attributes[attr.name] = attr.value\n    }\n  }\n\n  // Bounding box\n  if (el.getBoundingClientRect) {\n    const rect = el.getBoundingClientRect()\n    entry.boundingBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height }\n  }\n\n  // Computed styles\n  if (includeStyles && typeof window.getComputedStyle === 'function') {\n    const computed = window.getComputedStyle(el)\n    entry.styles = {}\n    if (styleProps && styleProps.length > 0) {\n      for (const prop of styleProps) {\n        entry.styles[prop] = computed.getPropertyValue(prop)\n      }\n    } else {\n      entry.styles = { display: computed.display, color: computed.color, position: computed.position }\n    }\n  }\n\n  // Children (capped to avoid unbounded serialization)\n  if (includeChildren && currentDepth < maxDepth && el.children && el.children.length > 0) {\n    entry.children = []\n    const maxChildren = Math.min(el.children.length, DOM_QUERY_MAX_ELEMENTS)\n    for (let i = 0; i < maxChildren; i++) {\n      const child = el.children[i]\n      if (child) {\n        entry.children.push(serializeDOMElement(child, false, undefined, true, maxDepth, currentDepth + 1))\n      }\n    }\n  }\n\n  return entry\n}\n\n/**\n * Get comprehensive page info\n */\nexport async function getPageInfo(): Promise<PageInfoResult> {\n  const headings: string[] = []\n  const headingEls = document.querySelectorAll('h1,h2,h3,h4,h5,h6')\n  for (const h of headingEls) {\n    headings.push((h.textContent || '').slice(0, DOM_QUERY_MAX_TEXT))\n  }\n\n  const forms: FormInfo[] = []\n  const formEls = document.querySelectorAll('form')\n  for (const form of formEls) {\n    const fields: string[] = []\n    const inputs = form.querySelectorAll('input,select,textarea')\n    for (const input of inputs) {\n      const inputEl = input as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n      if (inputEl.name) fields.push(inputEl.name)\n    }\n    forms.push({\n      id: form.id || undefined,\n      action: form.action || undefined,\n      fields,\n    })\n  }\n\n  return {\n    url: window.location.href,\n    title: document.title,\n    viewport: { width: window.innerWidth, height: window.innerHeight },\n    scroll: { x: window.scrollX, y: window.scrollY },\n    documentHeight: document.documentElement.scrollHeight,\n    headings,\n    links: document.querySelectorAll('a').length,\n    images: document.querySelectorAll('img').length,\n    interactiveElements: document.querySelectorAll('button,input,select,textarea,a[href]').length,\n    forms,\n  }\n}\n\n/**\n * Load axe-core dynamically if not already present.\n *\n * IMPORTANT: axe-core MUST be loaded from the bundled local copy (lib/axe.min.js).\n * Chrome Web Store policy prohibits loading remotely hosted code. All third-party\n * libraries must be bundled with the extension package.\n */\nfunction loadAxeCore(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (window.axe) {\n      resolve()\n      return\n    }\n\n    // Wait for axe-core to be injected by content script (which has chrome.runtime API access)\n    // Note: This function runs in page context (inject script), so we can't call chrome.runtime.getURL()\n    const checkInterval = setInterval(() => {\n      if (window.axe) {\n        clearInterval(checkInterval)\n        resolve()\n      }\n    }, 100)\n\n    // Timeout after 5 seconds\n    setTimeout(() => {\n      clearInterval(checkInterval)\n      reject(new Error('axe-core not available - content script may not have loaded it'))\n    }, 5000)\n  })\n}\n\n/**\n * Run an accessibility audit using axe-core\n */\nexport async function runAxeAudit(params: AxeAuditParams): Promise<FormattedAxeResults> {\n  await loadAxeCore()\n\n  const context: Element | Document | { include: string[] } = params.scope ? { include: [params.scope] } : document\n  const config: AxeRunConfig = {}\n\n  if (params.tags && params.tags.length > 0) {\n    config.runOnly = params.tags\n  }\n\n  if (params.include_passes) {\n    config.resultTypes = ['violations', 'passes', 'incomplete', 'inapplicable']\n  } else {\n    config.resultTypes = ['violations', 'incomplete']\n  }\n\n  const results = await window.axe!.run(context, config)\n  return formatAxeResults(results)\n}\n\n/**\n * Run axe audit with a timeout\n */\nexport async function runAxeAuditWithTimeout(params: AxeAuditParams, timeoutMs: number = A11Y_AUDIT_TIMEOUT_MS): Promise<FormattedAxeResults> {\n  return Promise.race([\n    runAxeAudit(params),\n    new Promise<FormattedAxeResults>((resolve) => {\n      setTimeout(() => resolve({ violations: [], summary: { violations: 0, passes: 0, incomplete: 0, inapplicable: 0 }, error: 'Accessibility audit timeout' }), timeoutMs)\n    }),\n  ])\n}\n\n/**\n * Format axe-core results into a compact representation\n */\nexport function formatAxeResults(axeResult: AxeResults): FormattedAxeResults {\n  const formatViolation = (v: AxeViolation): FormattedAxeViolation => {\n    const formatted: FormattedAxeViolation = {\n      id: v.id,\n      impact: v.impact,\n      description: v.description,\n      helpUrl: v.helpUrl,\n      nodes: [],\n    }\n\n    // Extract WCAG tags\n    if (v.tags) {\n      formatted.wcag = v.tags.filter((t) => t.startsWith('wcag'))\n    }\n\n    // Format nodes (cap at 10)\n    formatted.nodes = (v.nodes || []).slice(0, A11Y_MAX_NODES_PER_VIOLATION).map((node) => {\n      const selector = Array.isArray(node.target) ? node.target[0] : node.target\n      return {\n        selector: selector || '',\n        html: (node.html || '').slice(0, DOM_QUERY_MAX_HTML),\n        ...(node.failureSummary ? { failureSummary: node.failureSummary } : {}),\n      }\n    })\n\n    if (v.nodes && v.nodes.length > A11Y_MAX_NODES_PER_VIOLATION) {\n      formatted.nodeCount = v.nodes.length\n    }\n\n    return formatted\n  }\n\n  return {\n    violations: (axeResult.violations || []).map(formatViolation),\n    summary: {\n      violations: (axeResult.violations || []).length,\n      passes: (axeResult.passes || []).length,\n      incomplete: (axeResult.incomplete || []).length,\n      inapplicable: (axeResult.inapplicable || []).length,\n    },\n  }\n}\n", "/**\n * @fileoverview Performance snapshot capture.\n * Observes web vitals (FCP, LCP, CLS, INP), long tasks, and resource timing\n * to build comprehensive performance snapshots.\n */\n\nimport { MAX_LONG_TASKS, MAX_SLOWEST_REQUESTS, MAX_URL_LENGTH } from './constants';\n\ninterface ResourceByType {\n  count: number;\n  size: number;\n}\n\ninterface SlowRequest {\n  url: string;\n  duration: number;\n  size: number;\n}\n\ninterface ResourceTimingSummary {\n  requestCount: number;\n  transferSize: number;\n  decodedSize: number;\n  byType: Record<string, ResourceByType>;\n  slowestRequests: SlowRequest[];\n}\n\ninterface LongTaskMetrics {\n  count: number;\n  totalBlockingTime: number;\n  longest: number;\n}\n\ninterface NetworkTiming {\n  domContentLoaded: number;\n  load: number;\n  firstContentfulPaint: number | null;\n  largestContentfulPaint: number | null;\n  interactionToNextPaint: number | null;\n  timeToFirstByte: number;\n  domInteractive: number;\n}\n\ninterface PerformanceSnapshotData {\n  url: string;\n  timestamp: string;\n  timing: NetworkTiming;\n  network: ResourceTimingSummary;\n  longTasks: LongTaskMetrics;\n  cumulativeLayoutShift: number;\n}\n\n// Performance snapshot state\nlet perfSnapshotEnabled = true;\nlet longTaskEntries: PerformanceEntry[] = [];\nlet longTaskObserver: PerformanceObserver | null = null;\nlet paintObserver: PerformanceObserver | null = null;\nlet lcpObserver: PerformanceObserver | null = null;\nlet clsObserver: PerformanceObserver | null = null;\nlet inpObserver: PerformanceObserver | null = null;\nlet fcpValue: number | null = null;\nlet lcpValue: number | null = null;\nlet clsValue = 0;\nlet inpValue: number | null = null;\n\n/**\n * Map resource initiator types to standard categories\n */\nexport function mapInitiatorType(type: string): string {\n  switch (type) {\n    case 'script':\n      return 'script';\n    case 'link':\n    case 'css':\n      return 'style';\n    case 'img':\n      return 'image';\n    case 'fetch':\n    case 'xmlhttprequest':\n      return 'fetch';\n    case 'font':\n      return 'font';\n    default:\n      return 'other';\n  }\n}\n\n/**\n * Aggregate resource timing entries into a network summary\n */\nexport function aggregateResourceTiming(): ResourceTimingSummary {\n  const resources = (performance.getEntriesByType('resource') as PerformanceResourceTiming[]) || [];\n  const byType: Record<string, ResourceByType> = {};\n  let transferSize = 0;\n  let decodedSize = 0;\n\n  for (const entry of resources) {\n    const category = mapInitiatorType(entry.initiatorType);\n    // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n    if (!byType[category]) {\n      // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n      byType[category] = { count: 0, size: 0 };\n    }\n    // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n    byType[category].count++;\n    // eslint-disable-next-line security/detect-object-injection -- category from mapInitiatorType returns known resource type strings\n    byType[category].size += entry.transferSize || 0;\n    transferSize += entry.transferSize || 0;\n    decodedSize += entry.decodedBodySize || 0;\n  }\n\n  // Top N slowest requests\n  const sorted = [...resources].sort((a, b) => b.duration - a.duration);\n  const slowestRequests: SlowRequest[] = sorted.slice(0, MAX_SLOWEST_REQUESTS).map((r) => ({\n    url: r.name.length > MAX_URL_LENGTH ? r.name.slice(0, MAX_URL_LENGTH) : r.name,\n    duration: r.duration,\n    size: r.transferSize || 0,\n  }));\n\n  return {\n    requestCount: resources.length,\n    transferSize,\n    decodedSize,\n    byType,\n    slowestRequests,\n  };\n}\n\n/**\n * Capture a performance snapshot with navigation timing and network summary\n */\nexport function capturePerformanceSnapshot(): PerformanceSnapshotData | null {\n  const navEntries = (performance.getEntriesByType('navigation') as PerformanceNavigationTiming[]) || [];\n  if (!navEntries || navEntries.length === 0) return null;\n\n  const nav = navEntries[0];\n  if (!nav) return null;\n\n  const timing: NetworkTiming = {\n    domContentLoaded: nav.domContentLoadedEventEnd,\n    load: nav.loadEventEnd,\n    firstContentfulPaint: getFCP(),\n    largestContentfulPaint: getLCP(),\n    interactionToNextPaint: getINP(),\n    timeToFirstByte: nav.responseStart - nav.requestStart,\n    domInteractive: nav.domInteractive,\n  };\n\n  const network = aggregateResourceTiming();\n  const longTasks = getLongTaskMetrics();\n\n  return {\n    url: window.location.pathname,\n    timestamp: new Date().toISOString(),\n    timing,\n    network,\n    longTasks,\n    cumulativeLayoutShift: getCLS(),\n  };\n}\n\n/**\n * Install performance observers for long tasks, paint, LCP, and CLS\n */\nexport function installPerfObservers(): void {\n  longTaskEntries = [];\n  fcpValue = null;\n  lcpValue = null;\n  clsValue = 0;\n  inpValue = null;\n\n  // Long task observer\n  longTaskObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    const entries = list.getEntries();\n    for (const entry of entries) {\n      if (longTaskEntries.length < MAX_LONG_TASKS) {\n        longTaskEntries.push(entry);\n      }\n    }\n  });\n  longTaskObserver.observe({ type: 'longtask' });\n\n  // Paint observer (FCP)\n  paintObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    for (const entry of list.getEntries()) {\n      if (entry.name === 'first-contentful-paint') {\n        fcpValue = entry.startTime;\n      }\n    }\n  });\n  paintObserver.observe({ type: 'paint' });\n\n  // LCP observer\n  lcpObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    const entries = list.getEntries();\n    if (entries.length > 0) {\n      const lastEntry = entries[entries.length - 1];\n      if (lastEntry) {\n        lcpValue = lastEntry.startTime;\n      }\n    }\n  });\n  lcpObserver.observe({ type: 'largest-contentful-paint' });\n\n  // CLS observer\n  clsObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    for (const entry of list.getEntries()) {\n      const clsEntry = entry as any;\n      if (!clsEntry.hadRecentInput) {\n        clsValue += clsEntry.value;\n      }\n    }\n  });\n  clsObserver.observe({ type: 'layout-shift' });\n\n  // INP observer (Interaction to Next Paint)\n  inpObserver = new PerformanceObserver((list: PerformanceObserverEntryList): void => {\n    for (const entry of list.getEntries()) {\n      const inpEntry = entry as any;\n      if (inpEntry.interactionId) {\n        if (inpValue === null || inpEntry.duration > inpValue) {\n          inpValue = inpEntry.duration;\n        }\n      }\n    }\n  });\n  inpObserver.observe({ type: 'event', durationThreshold: 40 } as PerformanceObserverInit);\n}\n\n/**\n * Disconnect all performance observers\n */\nexport function uninstallPerfObservers(): void {\n  if (longTaskObserver) {\n    longTaskObserver.disconnect();\n    longTaskObserver = null;\n  }\n  if (paintObserver) {\n    paintObserver.disconnect();\n    paintObserver = null;\n  }\n  if (lcpObserver) {\n    lcpObserver.disconnect();\n    lcpObserver = null;\n  }\n  if (clsObserver) {\n    clsObserver.disconnect();\n    clsObserver = null;\n  }\n  if (inpObserver) {\n    inpObserver.disconnect();\n    inpObserver = null;\n  }\n  longTaskEntries = [];\n}\n\n/**\n * Get accumulated long task metrics\n */\nexport function getLongTaskMetrics(): LongTaskMetrics {\n  let totalBlockingTime = 0;\n  let longest = 0;\n\n  for (const entry of longTaskEntries) {\n    const blocking = entry.duration - 50;\n    if (blocking > 0) totalBlockingTime += blocking;\n    if (entry.duration > longest) longest = entry.duration;\n  }\n\n  return {\n    count: longTaskEntries.length,\n    totalBlockingTime,\n    longest,\n  };\n}\n\n/**\n * Get First Contentful Paint value\n */\nexport function getFCP(): number | null {\n  return fcpValue;\n}\n\n/**\n * Get Largest Contentful Paint value\n */\nexport function getLCP(): number | null {\n  return lcpValue;\n}\n\n/**\n * Get Cumulative Layout Shift value\n */\nexport function getCLS(): number {\n  return clsValue;\n}\n\n/**\n * Get Interaction to Next Paint value\n */\nexport function getINP(): number | null {\n  return inpValue;\n}\n\n/**\n * Send performance snapshot via postMessage to content script\n */\nexport function sendPerformanceSnapshot(): void {\n  if (!perfSnapshotEnabled) return;\n\n  const snapshot = capturePerformanceSnapshot();\n  if (!snapshot) return;\n\n  window.postMessage({ type: 'GASOLINE_PERFORMANCE_SNAPSHOT', payload: snapshot }, window.location.origin);\n}\n\n/**\n * Check if performance snapshot capture is enabled\n */\nexport function isPerformanceSnapshotEnabled(): boolean {\n  return perfSnapshotEnabled;\n}\n\n/**\n * Enable or disable performance snapshot capture\n */\nexport function setPerformanceSnapshotEnabled(enabled: boolean): void {\n  perfSnapshotEnabled = enabled;\n}\n", "/**\n * @fileoverview Gasoline API - Exposes window.__gasoline interface for developers\n * to interact with Gasoline capture capabilities.\n */\n\nimport type {\n  LogEntry,\n  ActionEntry,\n  EnhancedAction,\n  SelectorStrategies,\n  WaterfallEntry,\n  PerformanceMark,\n  PerformanceMeasure,\n} from '../types/index';\n\nimport {\n  setContextAnnotation,\n  removeContextAnnotation,\n  clearContextAnnotations,\n  getContextAnnotations,\n} from '../lib/context';\nimport {\n  computeSelectors,\n  recordEnhancedAction,\n  getEnhancedActionBuffer,\n  clearEnhancedActionBuffer,\n  generatePlaywrightScript,\n} from '../lib/reproduction';\nimport {\n  getActionBuffer,\n  clearActionBuffer,\n  setActionCaptureEnabled,\n} from '../lib/actions';\nimport {\n  getNetworkWaterfall,\n  setNetworkWaterfallEnabled,\n} from '../lib/network';\nimport {\n  getPerformanceMarks,\n  getPerformanceMeasures,\n  setPerformanceMarksEnabled,\n} from '../lib/performance';\nimport { enrichErrorWithAiContext, setAiContextEnabled, setAiContextStateSnapshot } from '../lib/ai-context';\n\n/**\n * GasolineAPI interface exposed on window.__gasoline\n */\nexport interface GasolineAPI {\n  annotate(key: string, value: unknown): void;\n  removeAnnotation(key: string): void;\n  clearAnnotations(): void;\n  getContext(): Record<string, unknown> | null;\n  getActions(): ActionEntry[];\n  clearActions(): void;\n  setActionCapture(enabled: boolean): void;\n  setNetworkWaterfall(enabled: boolean): void;\n  getNetworkWaterfall(options?: { since?: number; initiatorTypes?: string[] }): WaterfallEntry[];\n  setPerformanceMarks(enabled: boolean): void;\n  getMarks(options?: { since?: number }): PerformanceMark[];\n  getMeasures(options?: { since?: number }): PerformanceMeasure[];\n  enrichError(error: LogEntry): Promise<LogEntry>;\n  setAiContext(enabled: boolean): void;\n  setStateSnapshot(enabled: boolean): void;\n  recordAction(type: string, element: Element, opts?: Record<string, unknown>): void;\n  getEnhancedActions(): EnhancedAction[];\n  clearEnhancedActions(): void;\n  generateScript(actions?: EnhancedAction[], opts?: Record<string, unknown>): string;\n  getSelectors(element: Element): SelectorStrategies;\n  version: string;\n}\n\n// Extend Window interface for __gasoline\ndeclare global {\n  interface Window {\n    __gasoline?: GasolineAPI;\n  }\n}\n\n/**\n * Install the window.__gasoline API for developers to interact with Gasoline\n */\nexport function installGasolineAPI(): void {\n  if (typeof window === 'undefined') return;\n\n  window.__gasoline = {\n    /**\n     * Add a context annotation that will be included with errors\n     * @param key - Annotation key (e.g., 'checkout-flow', 'user')\n     * @param value - Annotation value\n     * @example\n     * window.__gasoline.annotate('checkout-flow', { step: 'payment', items: 3 })\n     */\n    annotate(key: string, value: unknown): boolean {\n      return setContextAnnotation(key, value);\n    },\n\n    /**\n     * Remove a context annotation\n     * @param key - Annotation key to remove\n     */\n    removeAnnotation(key: string): boolean {\n      return removeContextAnnotation(key);\n    },\n\n    /**\n     * Clear all context annotations\n     */\n    clearAnnotations(): void {\n      clearContextAnnotations();\n    },\n\n    /**\n     * Get current context annotations\n     * @returns Current annotations or null if none\n     */\n    getContext(): Record<string, unknown> | null {\n      return getContextAnnotations();\n    },\n\n    /**\n     * Get the user action replay buffer\n     * @returns Recent user actions\n     */\n    getActions(): ActionEntry[] {\n      return getActionBuffer() as unknown as ActionEntry[];\n    },\n\n    /**\n     * Clear the user action replay buffer\n     */\n    clearActions(): void {\n      clearActionBuffer();\n    },\n\n    /**\n     * Enable or disable action capture\n     * @param enabled - Whether to capture user actions\n     */\n    setActionCapture(enabled: boolean): void {\n      setActionCaptureEnabled(enabled);\n    },\n\n    /**\n     * Enable or disable network waterfall capture\n     * @param enabled - Whether to capture network waterfall\n     */\n    setNetworkWaterfall(enabled: boolean): void {\n      setNetworkWaterfallEnabled(enabled);\n    },\n\n    /**\n     * Get current network waterfall\n     * @param options - Filter options\n     * @returns Network waterfall entries\n     */\n    getNetworkWaterfall(options?: { since?: number; initiatorTypes?: string[] }): WaterfallEntry[] {\n      return getNetworkWaterfall(options);\n    },\n\n    /**\n     * Enable or disable performance marks capture\n     * @param enabled - Whether to capture performance marks\n     */\n    setPerformanceMarks(enabled: boolean): void {\n      setPerformanceMarksEnabled(enabled);\n    },\n\n    /**\n     * Get performance marks\n     * @param options - Filter options\n     * @returns Performance mark entries\n     */\n    getMarks(options?: { since?: number }): PerformanceMark[] {\n      return getPerformanceMarks(options) as unknown as PerformanceMark[];\n    },\n\n    /**\n     * Get performance measures\n     * @param options - Filter options\n     * @returns Performance measure entries\n     */\n    getMeasures(options?: { since?: number }): PerformanceMeasure[] {\n      return getPerformanceMeasures(options) as unknown as PerformanceMeasure[];\n    },\n\n    // === AI Context ===\n\n    /**\n     * Enrich an error entry with AI context\n     * @param error - Error entry to enrich\n     * @returns Enriched error entry\n     */\n    enrichError(error: LogEntry): Promise<LogEntry> {\n      return enrichErrorWithAiContext(error as unknown as any) as unknown as Promise<LogEntry>;\n    },\n\n    /**\n     * Enable or disable AI context enrichment\n     * @param enabled\n     */\n    setAiContext(enabled: boolean): void {\n      setAiContextEnabled(enabled);\n    },\n\n    /**\n     * Enable or disable state snapshot in AI context\n     * @param enabled\n     */\n    setStateSnapshot(enabled: boolean): void {\n      setAiContextStateSnapshot(enabled);\n    },\n\n    // === Reproduction Scripts ===\n\n    /**\n     * Record an enhanced action (for testing)\n     * @param type - Action type\n     * @param element - Target element\n     * @param opts - Options\n     */\n    recordAction(type: string, element: Element, opts?: Record<string, unknown>): void {\n      recordEnhancedAction(type as any, element, opts);\n    },\n\n    /**\n     * Get the enhanced action buffer\n     * @returns\n     */\n    getEnhancedActions(): EnhancedAction[] {\n      return getEnhancedActionBuffer() as unknown as EnhancedAction[];\n    },\n\n    /**\n     * Clear the enhanced action buffer\n     */\n    clearEnhancedActions(): void {\n      clearEnhancedActionBuffer();\n    },\n\n    /**\n     * Generate a Playwright reproduction script\n     * @param actions - Actions to convert\n     * @param opts - Generation options\n     * @returns Playwright test script\n     */\n    generateScript(actions?: EnhancedAction[], opts?: Record<string, unknown>): string {\n      return generatePlaywrightScript((actions || getEnhancedActionBuffer()) as any, opts);\n    },\n\n    /**\n     * Compute multi-strategy selectors for an element\n     * @param element\n     * @returns\n     */\n    getSelectors(element: Element): SelectorStrategies {\n      return computeSelectors(element) as unknown as SelectorStrategies;\n    },\n\n    /**\n     * Version of the Gasoline API\n     */\n    version: '5.2.0',\n  };\n}\n\n/**\n * Uninstall the window.__gasoline API\n */\nexport function uninstallGasolineAPI(): void {\n  if (typeof window !== 'undefined' && window.__gasoline) {\n    delete window.__gasoline;\n  }\n}\n", "/**\n * @fileoverview Observers - Observer registration and management for DOM, network,\n * performance, and WebSocket events.\n */\n\nimport {\n  installPerformanceCapture,\n  uninstallPerformanceCapture,\n  setPerformanceMarksEnabled,\n} from '../lib/performance';\nimport {\n  installWebSocketCapture,\n  setWebSocketCaptureMode,\n  setWebSocketCaptureEnabled,\n  uninstallWebSocketCapture,\n} from '../lib/websocket';\nimport {\n  setNetworkWaterfallEnabled,\n  setNetworkBodyCaptureEnabled,\n  setServerUrl,\n  wrapFetchWithBodies,\n} from '../lib/network';\nimport { installConsoleCapture, uninstallConsoleCapture } from '../lib/console';\nimport { installExceptionCapture, uninstallExceptionCapture } from '../lib/exceptions';\nimport {\n  installActionCapture,\n  uninstallActionCapture,\n  installNavigationCapture,\n  uninstallNavigationCapture,\n} from '../lib/actions';\nimport { postLog } from '../lib/bridge';\nimport { MAX_RESPONSE_LENGTH, SENSITIVE_HEADERS, MEMORY_SOFT_LIMIT_MB, MEMORY_HARD_LIMIT_MB } from '../lib/constants';\nimport { createDeferredPromise } from '../lib/timeout-utils';\n\n// Store original fetch for restoration\nlet originalFetch: typeof fetch | null = null;\n\n// Interception deferral state (Phase 1/Phase 2 split)\nlet deferralEnabled = true;\nlet phase2Installed = false;\nlet injectionTimestamp = 0;\nlet phase2Timestamp = 0;\n\n/**\n * Network error log payload\n */\ninterface NetworkErrorLog {\n  level: 'error';\n  type: 'network';\n  method: string;\n  url: string;\n  status?: number;\n  statusText?: string;\n  duration: number;\n  response?: string;\n  error?: string;\n  headers?: Record<string, string>;\n  [key: string]: unknown;\n}\n\n/**\n * Wrap fetch to capture network errors\n */\nexport function wrapFetch(originalFetchFn: typeof fetch): typeof fetch {\n  return async function (input: RequestInfo | URL, init?: RequestInit): Promise<Response> {\n    const startTime = Date.now();\n    const url = typeof input === 'string' ? input : (input as Request).url;\n    const method = init?.method || (typeof input === 'object' && 'method' in input ? (input as Request).method : 'GET') || 'GET';\n\n    try {\n      const response = await originalFetchFn(input, init);\n      const duration = Date.now() - startTime;\n\n      // Capture errors (4xx, 5xx)\n      if (!response.ok) {\n        let responseBody = '';\n        try {\n          const cloned = response.clone();\n          responseBody = await cloned.text();\n          if (responseBody.length > MAX_RESPONSE_LENGTH) {\n            responseBody = responseBody.slice(0, MAX_RESPONSE_LENGTH) + '... [truncated]';\n          }\n        } catch {\n          responseBody = '[Could not read response]';\n        }\n\n        // Filter sensitive headers (check both init.headers and Request object headers)\n        const safeHeaders: Record<string, string> = {};\n        const rawHeaders = init?.headers || (typeof input === 'object' && 'headers' in input ? (input as Request).headers : null);\n        if (rawHeaders) {\n          const headers: Record<string, string> = rawHeaders instanceof Headers ? Object.fromEntries(rawHeaders) : (rawHeaders as Record<string, string>);\n          Object.keys(headers).forEach((key) => {\n            const value = headers[key];\n            if (value && !SENSITIVE_HEADERS.includes(key.toLowerCase())) {\n              safeHeaders[key] = value;\n            }\n          });\n        }\n\n        const logPayload: NetworkErrorLog = {\n          level: 'error',\n          type: 'network',\n          method: method.toUpperCase(),\n          url,\n          status: response.status,\n          statusText: response.statusText,\n          duration,\n          response: responseBody,\n          ...(Object.keys(safeHeaders).length > 0 ? { headers: safeHeaders } : {}),\n        };\n\n        postLog(logPayload);\n      }\n\n      return response;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n\n      // Filter sensitive headers for the error path\n      const safeHeaders: Record<string, string> = {};\n      const rawHeaders = init?.headers || (typeof input === 'object' && 'headers' in input ? (input as Request).headers : null);\n      if (rawHeaders) {\n        const headers: Record<string, string> = rawHeaders instanceof Headers ? Object.fromEntries(rawHeaders) : (rawHeaders as Record<string, string>);\n        Object.keys(headers).forEach((key) => {\n          const value = headers[key];\n          if (value && !SENSITIVE_HEADERS.includes(key.toLowerCase())) {\n            safeHeaders[key] = value;\n          }\n        });\n      }\n\n      const logPayload: NetworkErrorLog = {\n        level: 'error',\n        type: 'network',\n        method: method.toUpperCase(),\n        url,\n        error: (error as Error).message,\n        duration,\n        ...(Object.keys(safeHeaders).length > 0 ? { headers: safeHeaders } : {}),\n      };\n\n      postLog(logPayload);\n\n      throw error;\n    }\n  };\n}\n\n/**\n * Install fetch capture.\n * Uses wrapFetchWithBodies to capture request/response bodies for all requests,\n * then wraps that with wrapFetch to also capture error details for 4xx/5xx responses.\n */\nexport function installFetchCapture(): void {\n  originalFetch = window.fetch;\n  // Layer 1: wrapFetchWithBodies captures request/response bodies for ALL requests\n  // Layer 2: wrapFetch captures detailed error logging for 4xx/5xx responses\n  window.fetch = wrapFetch(wrapFetchWithBodies(originalFetch));\n}\n\n/**\n * Uninstall fetch capture\n */\nexport function uninstallFetchCapture(): void {\n  if (originalFetch) {\n    window.fetch = originalFetch;\n    originalFetch = null;\n  }\n}\n\n/**\n * Install all capture hooks\n */\nexport function install(): void {\n  installConsoleCapture();\n  installFetchCapture();\n  installExceptionCapture();\n  installActionCapture();\n  installNavigationCapture();\n  installWebSocketCapture();\n  installPerformanceCapture();\n}\n\n/**\n * Uninstall all capture hooks\n */\nexport function uninstall(): void {\n  uninstallConsoleCapture();\n  uninstallFetchCapture();\n  uninstallExceptionCapture();\n  uninstallActionCapture();\n  uninstallNavigationCapture();\n  uninstallWebSocketCapture();\n  uninstallPerformanceCapture();\n}\n\n/**\n * Check if heavy intercepts should be deferred until page load\n */\nexport function shouldDeferIntercepts(): boolean {\n  if (typeof document === 'undefined') return false;\n  return document.readyState === 'loading';\n}\n\n/**\n * Memory pressure check state\n */\ninterface MemoryPressureState {\n  memoryUsageMB: number;\n  networkBodiesEnabled: boolean;\n  wsBufferCapacity: number;\n  networkBufferCapacity: number;\n}\n\n/**\n * Check memory pressure and adjust buffer capacities\n */\nexport function checkMemoryPressure(state: MemoryPressureState): MemoryPressureState {\n  const result = { ...state };\n\n  if (state.memoryUsageMB >= MEMORY_HARD_LIMIT_MB) {\n    // Hard limit: disable network bodies\n    result.networkBodiesEnabled = false;\n    result.wsBufferCapacity = Math.floor(state.wsBufferCapacity * 0.25);\n    result.networkBufferCapacity = Math.floor(state.networkBufferCapacity * 0.25);\n  } else if (state.memoryUsageMB >= MEMORY_SOFT_LIMIT_MB) {\n    // Soft limit: reduce buffers\n    result.wsBufferCapacity = Math.floor(state.wsBufferCapacity * 0.5);\n    result.networkBufferCapacity = Math.floor(state.networkBufferCapacity * 0.5);\n  }\n\n  return result;\n}\n\n/**\n * Phase 1 (Immediate): Lightweight, non-intercepting setup.\n */\nexport function installPhase1(): void {\n  console.log('[Gasoline] Phase 1 installing (lightweight API + perf observers)');\n  injectionTimestamp = performance.now();\n  phase2Installed = false;\n  phase2Timestamp = 0;\n\n  // Start PerformanceObservers (passive observers, no prototype modification)\n  installPerformanceCapture();\n\n  // Now handle Phase 2 scheduling\n  if (!deferralEnabled) {\n    // Deferral disabled: install Phase 2 immediately\n    installPhase2();\n  } else {\n    const installDeferred = (): void => {\n      if (!phase2Installed) setTimeout(installPhase2, 100);\n    };\n    if (document.readyState === 'complete') {\n      // Page already loaded, defer by 100ms\n      installDeferred();\n    } else {\n      // Wait for load event, then defer by 100ms\n      window.addEventListener('load', installDeferred, { once: true });\n      // 10-second timeout fallback\n      setTimeout(() => {\n        if (!phase2Installed) installPhase2();\n      }, 10000);\n    }\n  }\n}\n\n/**\n * Phase 2 (Deferred): Heavy interceptors.\n */\nexport function installPhase2(): void {\n  // Double-injection guard\n  if (phase2Installed) return;\n\n  // Environment guard\n  if (typeof window === 'undefined' || typeof document === 'undefined') return;\n\n  console.log('[Gasoline] Phase 2 installing (heavy interceptors: console, fetch, WS, errors, actions)');\n  phase2Timestamp = performance.now();\n  phase2Installed = true;\n\n  // Install all heavy interceptors\n  install();\n}\n\n/**\n * Get the current deferral state for diagnostics and testing.\n */\nexport interface DeferralState {\n  deferralEnabled: boolean;\n  phase2Installed: boolean;\n  injectionTimestamp: number;\n  phase2Timestamp: number;\n}\n\nexport function getDeferralState(): DeferralState {\n  return {\n    deferralEnabled,\n    phase2Installed,\n    injectionTimestamp,\n    phase2Timestamp,\n  };\n}\n\n/**\n * Set whether interception deferral is enabled.\n */\nexport function setDeferralEnabled(enabled: boolean): void {\n  deferralEnabled = enabled;\n}\n", "/**\n * @fileoverview Timeout and Promise utilities - Reusable patterns for handling timeouts,\n * promise races, and message-based async operations with cleanup.\n *\n * These utilities extract common patterns found throughout the Gasoline extension:\n * - Promise.race with timeout fallback\n * - Message-based request/response with timeout and cleanup\n * - Deferred promises for storing resolvers/rejecters\n * - Safe timeout management with resource cleanup\n */\n\n/**\n * Deferred Promise - Holds resolve/reject callbacks for external resolution\n * Useful for resolving a promise from outside async/await context\n * @template T The type of the resolved value\n */\nexport interface DeferredPromise<T> {\n  promise: Promise<T>;\n  resolve: (value: T | PromiseLike<T>) => void;\n  reject: (reason?: unknown) => void;\n}\n\n/**\n * Create a deferred promise\n * @template T The type of the resolved value\n * @returns Deferred promise with resolve/reject methods\n *\n * @example\n * const deferred = createDeferredPromise<number>();\n * setTimeout(() => deferred.resolve(42), 100);\n * const result = await deferred.promise; // 42\n */\nexport function createDeferredPromise<T>(): DeferredPromise<T> {\n  let resolve!: (value: T | PromiseLike<T>) => void;\n  let reject!: (reason?: unknown) => void;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n\n/**\n * Wrap a promise with a timeout fallback\n * Returns the result of the promise if it resolves before timeout,\n * otherwise returns the fallback value (or rejects if no fallback)\n *\n * @template T The type of the promise value\n * @param promise The promise to wrap\n * @param timeoutMs Timeout in milliseconds\n * @param fallback Optional fallback value to return on timeout\n * @returns Promise that resolves to the result or fallback (or rejects on timeout if no fallback)\n *\n * @example\n * // With fallback value\n * const result = await withTimeout(fetch('/api'), 5000, { ok: false });\n *\n * @example\n * // Without fallback (rejects on timeout)\n * try {\n *   const result = await withTimeout(slowOperation(), 3000);\n * } catch (err) {\n *   // Handle timeout\n * }\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  fallback?: T\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      setTimeout(() => {\n        if (fallback !== undefined) {\n          reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, fallback as T));\n        } else {\n          reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n        }\n      }, timeoutMs);\n    }),\n  ]).catch((err) => {\n    if (err instanceof TimeoutError && err.fallback !== undefined) {\n      return err.fallback as T;\n    }\n    throw err;\n  });\n}\n\n/**\n * Custom error for timeout operations that optionally carries a fallback value\n */\nexport class TimeoutError extends Error {\n  constructor(\n    message: string,\n    public fallback?: unknown\n  ) {\n    super(message);\n    this.name = 'TimeoutError';\n  }\n}\n\n/**\n * Wrap a promise with a timeout that rejects on timeout\n * This is a stricter version of withTimeout - no fallback allowed\n *\n * @template T The type of the promise value\n * @param promise The promise to wrap\n * @param timeoutMs Timeout in milliseconds\n * @returns Promise that resolves to the result or rejects on timeout\n *\n * @example\n * try {\n *   const data = await promiseWithTimeout(fetchData(), 5000);\n * } catch (err) {\n *   if (err instanceof TimeoutError) {\n *     console.error('Request timed out');\n *   }\n * }\n */\nexport async function promiseWithTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) => {\n      setTimeout(() => {\n        reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n      }, timeoutMs);\n    }),\n  ]);\n}\n\n/**\n * Message-based async operation with timeout and cleanup\n * Manages request/response correlation using a Map and IDs, with automatic cleanup\n *\n * This pattern is used extensively in content.ts for:\n * - Highlight requests (30s timeout)\n * - Execute JS requests (30s timeout)\n * - A11y audit requests (30s timeout)\n * - DOM query requests (30s timeout)\n * - Network waterfall requests (5s timeout)\n *\n * @template T The type of the response value\n * @param sender Function that sends the message/request\n * @param timeoutMs Timeout in milliseconds\n * @param cleanup Optional cleanup function called on timeout (e.g., to remove event listeners)\n * @returns Promise that resolves to the response or rejects on timeout\n *\n * @example\n * // Simple message send with timeout\n * const response = await messageWithTimeout(\n *   async () => chrome.runtime.sendMessage({ type: 'PING' }),\n *   5000\n * );\n *\n * @example\n * // With event listener cleanup\n * const response = await messageWithTimeout(\n *   async () => {\n *     const requestId = ++requestIdCounter;\n *     pendingRequests.set(requestId, (result) => deferred.resolve(result));\n *     window.postMessage({ type: 'REQUEST', requestId }, origin);\n *     return deferred.promise;\n *   },\n *   30000,\n *   () => {\n *     pendingRequests.delete(requestId);\n *     window.removeEventListener('message', handler);\n *   }\n * );\n */\nexport async function messageWithTimeout<T>(\n  sender: () => Promise<T>,\n  timeoutMs: number,\n  cleanup?: () => void\n): Promise<T> {\n  const timeoutHandle = setTimeout(() => {\n    cleanup?.();\n  }, timeoutMs);\n\n  try {\n    return await promiseWithTimeout(sender(), timeoutMs);\n  } finally {\n    clearTimeout(timeoutHandle);\n  }\n}\n\n/**\n * Race a promise against a timeout, calling a cleanup function if timeout wins\n * Used for operations that set up listeners or other resources that need cleanup\n *\n * @template T The type of the promise value\n * @param promise The promise to race against timeout\n * @param timeoutMs Timeout in milliseconds\n * @param timeoutFallback Value to return on timeout (if provided, doesn't throw)\n * @param cleanup Function to call if timeout occurs\n * @returns Promise that resolves to result, fallback (if provided), or rejects\n *\n * @example\n * const result = await promiseRaceWithCleanup(\n *   waitForResponse(),\n *   5000,\n *   { entries: [] }, // fallback for timeout\n *   () => removeEventListener('message', handler) // cleanup\n * );\n */\nexport async function promiseRaceWithCleanup<T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  timeoutFallback: T | undefined,\n  cleanup?: () => void\n): Promise<T> {\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((_, reject) => {\n        setTimeout(() => {\n          cleanup?.();\n          if (timeoutFallback !== undefined) {\n            reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, timeoutFallback));\n          } else {\n            reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n          }\n        }, timeoutMs);\n      }),\n    ]);\n  } catch (err) {\n    if (err instanceof TimeoutError && err.fallback !== undefined) {\n      return err.fallback as T;\n    }\n    throw err;\n  }\n}\n\n/**\n * Execute a callback with automatic timeout and fallback\n * The callback should return a promise that resolves with the result\n *\n * @template T The type of the result\n * @param callback Function that returns a promise\n * @param timeoutMs Timeout in milliseconds\n * @param fallback Optional fallback value to return on timeout\n * @returns Promise that resolves to the result, fallback, or rejects\n *\n * @example\n * const result = await executeWithTimeout(\n *   () => fetch('/api/data'),\n *   5000,\n *   { ok: false, status: 408 } // fallback\n * );\n */\nexport async function executeWithTimeout<T>(\n  callback: () => Promise<T>,\n  timeoutMs: number,\n  fallback?: T\n): Promise<T> {\n  return withTimeout(callback(), timeoutMs, fallback);\n}\n\n/**\n * Create a promise that resolves after a delay\n * Useful for retry logic or deferring operations\n *\n * @param delayMs Delay in milliseconds\n * @returns Promise that resolves after the delay\n *\n * @example\n * await delay(1000); // Wait 1 second\n */\nexport function delay(delayMs: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, delayMs);\n  });\n}\n\n/**\n * Retry a promise-returning function with exponential backoff\n * Useful for flaky operations like network requests\n *\n * @template T The type of the result\n * @param fn Function that returns a promise\n * @param maxAttempts Maximum number of attempts\n * @param initialDelayMs Initial delay before first retry (doubles each attempt)\n * @returns Promise that resolves if any attempt succeeds, or rejects if all fail\n *\n * @example\n * const result = await retryWithBackoff(\n *   () => fetch('/api/data'),\n *   3,\n *   100\n * );\n */\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxAttempts: number = 3,\n  initialDelayMs: number = 100\n): Promise<T> {\n  let lastError: unknown;\n\n  for (let attempt = 0; attempt < maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (err) {\n      lastError = err;\n      if (attempt < maxAttempts - 1) {\n        const delayMs = initialDelayMs * Math.pow(2, attempt);\n        await delay(delayMs);\n      }\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Create a cancellable promise that can be aborted\n * @template T The type of the result\n * @param promise The promise to wrap\n * @returns Object with the promise and a cancel function\n *\n * @example\n * const { promise, cancel } = makeCancellable(fetch('/api/data'));\n * setTimeout(() => cancel(), 5000);\n * try {\n *   const result = await promise;\n * } catch (err) {\n *   if (err.message === 'cancelled') {\n *     console.log('Operation was cancelled');\n *   }\n * }\n */\nexport function makeCancellable<T>(promise: Promise<T>): {\n  promise: Promise<T>;\n  cancel: () => void;\n} {\n  let cancelled = false;\n  let rejectFn: (reason?: unknown) => void;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    rejectFn = reject;\n    promise\n      .then((value) => {\n        if (!cancelled) {\n          resolve(value);\n        }\n      })\n      .catch((err) => {\n        if (!cancelled) {\n          reject(err);\n        }\n      });\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      cancelled = true;\n      rejectFn(new Error('cancelled'));\n    },\n  };\n}\n\n/**\n * Wait for a condition to become true or timeout\n * Polls at regular intervals until condition is true or timeout occurs\n *\n * @param condition Function that returns true when condition is met\n * @param timeoutMs Maximum time to wait in milliseconds\n * @param pollIntervalMs How often to check the condition (default 100ms)\n * @returns Promise that resolves if condition becomes true, rejects on timeout\n *\n * @example\n * await waitFor(() => element.classList.contains('visible'), 5000);\n */\nexport async function waitFor(\n  condition: () => boolean,\n  timeoutMs: number,\n  pollIntervalMs: number = 100\n): Promise<void> {\n  const startTime = Date.now();\n\n  return new Promise((resolve, reject) => {\n    const check = (): void => {\n      if (condition()) {\n        resolve();\n      } else if (Date.now() - startTime > timeoutMs) {\n        reject(new TimeoutError(`Condition not met within ${timeoutMs}ms`));\n      } else {\n        setTimeout(check, pollIntervalMs);\n      }\n    };\n\n    check();\n  });\n}\n\n/**\n * Race multiple promises and return the result of the first one that settles\n * (resolves or rejects). This differs from Promise.race in that it includes\n * rejection reasons.\n *\n * @template T The type of the result\n * @param promises Promises to race\n * @returns Promise that settles with the result of the first settling promise\n *\n * @example\n * const result = await racePromises([\n *   fetch('/api/data'),\n *   delay(5000).then(() => { throw new TimeoutError('Too slow'); })\n * ]);\n */\nexport async function racePromises<T>(promises: Promise<T>[]): Promise<T> {\n  if (promises.length === 0) {\n    throw new Error('racePromises requires at least one promise');\n  }\n\n  return Promise.race(promises);\n}\n\n/**\n * Combine multiple timeout utilities: execute a callback with timeout,\n * automatic cleanup on timeout, and optional fallback\n *\n * @template T The type of the result\n * @param callback Callback that returns a promise\n * @param timeoutMs Timeout in milliseconds\n * @param fallback Optional fallback value on timeout\n * @param cleanup Optional cleanup function called on timeout\n * @returns Promise that resolves to result, fallback, or rejects\n *\n * @example\n * const result = await executeWithTimeoutAndCleanup(\n *   async () => {\n *     const requestId = generateId();\n *     window.addEventListener('message', handler);\n *     window.postMessage({ type: 'REQUEST', requestId });\n *     return deferred.promise;\n *   },\n *   5000,\n *   { success: false },\n *   () => window.removeEventListener('message', handler)\n * );\n */\nexport async function executeWithTimeoutAndCleanup<T>(\n  callback: () => Promise<T>,\n  timeoutMs: number,\n  fallback?: T,\n  cleanup?: () => void\n): Promise<T> {\n  let timeoutHandle: ReturnType<typeof setTimeout> | null = null;\n\n  try {\n    return await new Promise<T>((resolve, reject) => {\n      timeoutHandle = setTimeout(() => {\n        cleanup?.();\n        if (fallback !== undefined) {\n          resolve(fallback);\n        } else {\n          reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n        }\n      }, timeoutMs);\n\n      callback()\n        .then((result) => {\n          if (timeoutHandle !== null) {\n            clearTimeout(timeoutHandle);\n          }\n          resolve(result);\n        })\n        .catch((err) => {\n          if (timeoutHandle !== null) {\n            clearTimeout(timeoutHandle);\n          }\n          reject(err);\n        });\n    });\n  } catch (err) {\n    if (timeoutHandle !== null) {\n      clearTimeout(timeoutHandle);\n    }\n    throw err;\n  }\n}\n", "/**\n * @fileoverview Message Handlers - Handles messages from content script including\n * settings, state management, JavaScript execution, and DOM/accessibility queries.\n */\n\nimport type { BrowserStateSnapshot, StateAction, ExecuteJsResult, WebSocketCaptureMode } from '../types/index';\n\nimport { createDeferredPromise, TimeoutError } from '../lib/timeout-utils';\nimport { executeDOMQuery, runAxeAuditWithTimeout, type DOMQueryParams } from '../lib/dom-queries';\nimport { getNetworkWaterfall, setNetworkWaterfallEnabled, setNetworkBodyCaptureEnabled, setServerUrl } from '../lib/network';\nimport { setPerformanceMarksEnabled, installPerformanceCapture, uninstallPerformanceCapture } from '../lib/performance';\nimport { setActionCaptureEnabled } from '../lib/actions';\nimport { setWebSocketCaptureEnabled, setWebSocketCaptureMode, installWebSocketCapture, uninstallWebSocketCapture } from '../lib/websocket';\nimport { setPerformanceSnapshotEnabled } from '../lib/perf-snapshot';\nimport { setDeferralEnabled } from './observers';\n\n/**\n * Valid setting names from content script\n */\nconst VALID_SETTINGS = new Set([\n  'setNetworkWaterfallEnabled',\n  'setPerformanceMarksEnabled',\n  'setActionReplayEnabled',\n  'setWebSocketCaptureEnabled',\n  'setWebSocketCaptureMode',\n  'setPerformanceSnapshotEnabled',\n  'setDeferralEnabled',\n  'setNetworkBodyCaptureEnabled',\n  'setServerUrl',\n]);\n\nconst VALID_STATE_ACTIONS = new Set<StateAction>(['capture', 'restore']);\n\n/**\n * Setting message from content script\n */\ninterface SettingMessageData {\n  type: 'GASOLINE_SETTING';\n  setting: string;\n  enabled?: boolean;\n  mode?: string;\n  url?: string;\n}\n\n/**\n * State command message from content script\n */\ninterface StateCommandMessageData {\n  type: 'GASOLINE_STATE_COMMAND';\n  messageId: string;\n  action: StateAction;\n  state?: BrowserStateSnapshot;\n  include_url?: boolean;\n}\n\n/**\n * Execute JS request message from content script\n */\ninterface ExecuteJsRequestMessageData {\n  type: 'GASOLINE_EXECUTE_JS';\n  requestId: number | string;\n  script: string;\n  timeoutMs?: number;\n}\n\n/**\n * A11y query request message from content script\n */\ninterface A11yQueryRequestMessageData {\n  type: 'GASOLINE_A11Y_QUERY';\n  requestId: number | string;\n  params?: Record<string, unknown>;\n}\n\n/**\n * DOM query request message from content script\n */\ninterface DomQueryRequestMessageData {\n  type: 'GASOLINE_DOM_QUERY';\n  requestId: number | string;\n  params?: Record<string, unknown>;\n}\n\n/**\n * Highlight request message from content script\n */\ninterface HighlightRequestMessageData {\n  type: 'GASOLINE_HIGHLIGHT_REQUEST';\n  requestId: number | string;\n  params?: {\n    selector: string;\n    duration_ms?: number;\n  };\n}\n\n/**\n * Get waterfall request message from content script\n */\ninterface GetWaterfallRequestMessageData {\n  type: 'GASOLINE_GET_WATERFALL';\n  requestId: number | string;\n}\n\n/**\n * Union of all page message data types\n */\ntype PageMessageData =\n  | SettingMessageData\n  | StateCommandMessageData\n  | ExecuteJsRequestMessageData\n  | A11yQueryRequestMessageData\n  | DomQueryRequestMessageData\n  | HighlightRequestMessageData\n  | GetWaterfallRequestMessageData;\n\n/**\n * Safe serialization for complex objects returned from executeJavaScript.\n */\nexport function safeSerializeForExecute(value: unknown, depth: number = 0, seen: WeakSet<object> = new WeakSet()): unknown {\n  if (depth > 10) return '[max depth exceeded]';\n  if (value === null) return null;\n  if (value === undefined) return undefined;\n\n  const type = typeof value;\n  if (type === 'string' || type === 'number' || type === 'boolean') {\n    return value;\n  }\n\n  if (type === 'function') {\n    return `[Function: ${(value as (...args: unknown[]) => unknown).name || 'anonymous'}]`;\n  }\n\n  if (type === 'symbol') {\n    return (value as symbol).toString();\n  }\n\n  if (type === 'object') {\n    const obj = value as object;\n    if (seen.has(obj)) return '[Circular]';\n    seen.add(obj);\n\n    if (Array.isArray(obj)) {\n      return obj.slice(0, 100).map((v) => safeSerializeForExecute(v, depth + 1, seen));\n    }\n\n    if (obj instanceof Error) {\n      return { error: obj.message, stack: obj.stack };\n    }\n\n    if (obj instanceof Date) {\n      return obj.toISOString();\n    }\n\n    if (obj instanceof RegExp) {\n      return obj.toString();\n    }\n\n    // DOM nodes\n    if (typeof Node !== 'undefined' && obj instanceof Node) {\n      const node = obj as Node & { id?: string };\n      return `[${node.nodeName}${node.id ? '#' + node.id : ''}]`;\n    }\n\n    // Plain objects\n    const result: Record<string, unknown> = {};\n    const keys = Object.keys(obj).slice(0, 50);\n    for (const key of keys) {\n      try {\n        result[key] = safeSerializeForExecute((obj as Record<string, unknown>)[key], depth + 1, seen);\n      } catch {\n        result[key] = '[unserializable]';\n      }\n    }\n    if (Object.keys(obj).length > 50) {\n      result['...'] = `[${Object.keys(obj).length - 50} more keys]`;\n    }\n    return result;\n  }\n\n  return String(value);\n}\n\n/**\n * Execute arbitrary JavaScript in the page context with timeout handling.\n */\nexport function executeJavaScript(script: string, timeoutMs: number = 5000): Promise<ExecuteJsResult> {\n  const deferred = createDeferredPromise<ExecuteJsResult>();\n\n  const executeWithTimeoutProtection = async (): Promise<void> => {\n    const timeoutHandle = setTimeout(() => {\n      deferred.resolve({\n        success: false,\n        error: 'execution_timeout',\n        message: `Script exceeded ${timeoutMs}ms timeout. RECOMMENDED ACTIONS:\n\n1. Check for infinite loops or blocking operations in your script\n2. Break the task into smaller pieces (< 2s execution time works best)\n3. Verify the script logic - test with simpler operations first\n\nTip: Run small test scripts to isolate the issue, then build up complexity.`,\n      });\n    }, timeoutMs);\n\n    try {\n      const cleanScript = script.trim();\n\n      const hasMultipleStatements = cleanScript.includes(';');\n      const hasExplicitReturn = /\\breturn\\b/.test(cleanScript);\n\n      let fnBody: string;\n      if (hasMultipleStatements || hasExplicitReturn) {\n        fnBody = `\"use strict\"; ${cleanScript}`;\n      } else {\n        fnBody = `\"use strict\"; return (${cleanScript});`;\n      }\n\n      // eslint-disable-next-line no-new-func\n      const fn = new Function(fnBody) as () => unknown;\n\n      const result = fn();\n\n      // Handle promises\n      if (result && typeof (result as Promise<unknown>).then === 'function') {\n        (result as Promise<unknown>)\n          .then((value) => {\n            clearTimeout(timeoutHandle);\n            deferred.resolve({ success: true, result: safeSerializeForExecute(value) });\n          })\n          .catch((err: Error) => {\n            clearTimeout(timeoutHandle);\n            deferred.resolve({\n              success: false,\n              error: 'promise_rejected',\n              message: err.message,\n              stack: err.stack,\n            });\n          });\n      } else {\n        clearTimeout(timeoutHandle);\n        deferred.resolve({ success: true, result: safeSerializeForExecute(result) });\n      }\n    } catch (err) {\n      clearTimeout(timeoutHandle);\n\n      const error = err as Error;\n      if (error.message && (error.message.includes('Content Security Policy') || error.message.includes('unsafe-eval'))) {\n        deferred.resolve({\n          success: false,\n          error: 'csp_blocked',\n          message:\n            'This page has a Content Security Policy that blocks script execution. Try on a different page (e.g., localhost, about:blank, or a page without strict CSP).',\n        });\n      } else {\n        deferred.resolve({\n          success: false,\n          error: 'execution_error',\n          message: error.message,\n          stack: error.stack,\n        });\n      }\n    }\n  };\n\n  executeWithTimeoutProtection().catch((err) => {\n    console.error('[Gasoline] Unexpected error in executeJavaScript:', err);\n    deferred.resolve({\n      success: false,\n      error: 'execution_error',\n      message: 'Unexpected error during script execution',\n    });\n  });\n\n  return deferred.promise;\n}\n\n/**\n * Install message listener for handling content script messages\n */\nexport function installMessageListener(\n  captureStateFn: () => BrowserStateSnapshot,\n  restoreStateFn: (state: BrowserStateSnapshot, includeUrl: boolean) => unknown\n): void {\n  if (typeof window === 'undefined') return;\n\n  window.addEventListener('message', (event: MessageEvent<PageMessageData>) => {\n    // Only accept messages from this window\n    if (event.source !== window) return;\n\n    // Handle settings messages from content script\n    if (event.data?.type === 'GASOLINE_SETTING') {\n      const data = event.data as SettingMessageData;\n      // Validate setting name\n      if (!VALID_SETTINGS.has(data.setting)) {\n        console.warn('[Gasoline] Invalid setting:', data.setting);\n        return;\n      }\n\n      // Validate parameter types based on setting\n      if (data.setting === 'setWebSocketCaptureMode') {\n        if (typeof data.mode !== 'string') {\n          console.warn('[Gasoline] Invalid mode type for setWebSocketCaptureMode');\n          return;\n        }\n      } else if (data.setting === 'setServerUrl') {\n        if (typeof data.url !== 'string') {\n          console.warn('[Gasoline] Invalid url type for setServerUrl');\n          return;\n        }\n      } else {\n        // Boolean settings\n        if (typeof data.enabled !== 'boolean') {\n          console.warn('[Gasoline] Invalid enabled value type');\n          return;\n        }\n      }\n\n      handleSetting(data);\n    }\n\n    // Handle state management commands from content script\n    if (event.data?.type === 'GASOLINE_STATE_COMMAND') {\n      const data = event.data as StateCommandMessageData;\n      handleStateCommand(data, captureStateFn, restoreStateFn);\n    }\n\n    // Handle GASOLINE_EXECUTE_JS from content script\n    if (event.data?.type === 'GASOLINE_EXECUTE_JS') {\n      handleExecuteJs(event.data as ExecuteJsRequestMessageData);\n    }\n\n    // Handle GASOLINE_A11Y_QUERY from content script\n    if (event.data?.type === 'GASOLINE_A11Y_QUERY') {\n      handleA11yQuery(event.data as A11yQueryRequestMessageData);\n    }\n\n    // Handle GASOLINE_DOM_QUERY from content script\n    if (event.data?.type === 'GASOLINE_DOM_QUERY') {\n      handleDomQuery(event.data as DomQueryRequestMessageData);\n    }\n\n    // Handle GASOLINE_GET_WATERFALL from content script\n    if (event.data?.type === 'GASOLINE_GET_WATERFALL') {\n      handleGetWaterfall(event.data as GetWaterfallRequestMessageData);\n    }\n  });\n}\n\nfunction handleSetting(data: SettingMessageData): void {\n  switch (data.setting) {\n    case 'setNetworkWaterfallEnabled':\n      setNetworkWaterfallEnabled(data.enabled!);\n      break;\n    case 'setPerformanceMarksEnabled':\n      setPerformanceMarksEnabled(data.enabled!);\n      if (data.enabled) {\n        installPerformanceCapture();\n      } else {\n        uninstallPerformanceCapture();\n      }\n      break;\n    case 'setActionReplayEnabled':\n      setActionCaptureEnabled(data.enabled!);\n      break;\n    case 'setWebSocketCaptureEnabled':\n      setWebSocketCaptureEnabled(data.enabled!);\n      if (data.enabled) {\n        installWebSocketCapture();\n      } else {\n        uninstallWebSocketCapture();\n      }\n      break;\n    case 'setWebSocketCaptureMode':\n      setWebSocketCaptureMode((data.mode || 'lifecycle') as WebSocketCaptureMode);\n      break;\n    case 'setPerformanceSnapshotEnabled':\n      setPerformanceSnapshotEnabled(data.enabled!);\n      break;\n    case 'setDeferralEnabled':\n      setDeferralEnabled(data.enabled!);\n      break;\n    case 'setNetworkBodyCaptureEnabled':\n      setNetworkBodyCaptureEnabled(data.enabled!);\n      break;\n    case 'setServerUrl':\n      setServerUrl(data.url!);\n      break;\n  }\n}\n\nfunction handleStateCommand(\n  data: StateCommandMessageData,\n  captureStateFn: () => BrowserStateSnapshot,\n  restoreStateFn: (state: BrowserStateSnapshot, includeUrl: boolean) => unknown\n): void {\n  const { messageId, action, state } = data;\n\n  // Validate action\n  if (!VALID_STATE_ACTIONS.has(action)) {\n    console.warn('[Gasoline] Invalid state action:', action);\n    window.postMessage(\n      {\n        type: 'GASOLINE_STATE_RESPONSE',\n        messageId,\n        result: { error: `Invalid action: ${action}` },\n      },\n      window.location.origin,\n    );\n    return;\n  }\n\n  // Validate state object for restore action\n  if (action === 'restore' && (!state || typeof state !== 'object')) {\n    console.warn('[Gasoline] Invalid state object for restore');\n    window.postMessage(\n      {\n        type: 'GASOLINE_STATE_RESPONSE',\n        messageId,\n        result: { error: 'Invalid state object' },\n      },\n      window.location.origin,\n    );\n    return;\n  }\n\n  let result: BrowserStateSnapshot | unknown;\n\n  try {\n    if (action === 'capture') {\n      result = captureStateFn();\n    } else if (action === 'restore') {\n      const includeUrl = data.include_url !== false;\n      result = restoreStateFn(state!, includeUrl);\n    } else {\n      result = { error: `Unknown action: ${action}` };\n    }\n  } catch (err) {\n    result = { error: (err as Error).message };\n  }\n\n  // Send response back to content script\n  window.postMessage(\n    {\n      type: 'GASOLINE_STATE_RESPONSE',\n      messageId,\n      result,\n    },\n    window.location.origin,\n  );\n}\n\nfunction handleExecuteJs(data: ExecuteJsRequestMessageData): void {\n  const { requestId, script, timeoutMs } = data;\n\n  // Validate parameters\n  if (typeof script !== 'string') {\n    console.warn('[Gasoline] Script must be a string');\n    window.postMessage(\n      {\n        type: 'GASOLINE_EXECUTE_JS_RESULT',\n        requestId,\n        result: { success: false, error: 'invalid_script', message: 'Script must be a string' },\n      },\n      window.location.origin,\n    );\n    return;\n  }\n\n  if (typeof requestId !== 'number' && typeof requestId !== 'string') {\n    console.warn('[Gasoline] Invalid requestId type');\n    return;\n  }\n\n  executeJavaScript(script, timeoutMs)\n    .then((result) => {\n      window.postMessage(\n        {\n          type: 'GASOLINE_EXECUTE_JS_RESULT',\n          requestId,\n          result,\n        },\n        window.location.origin,\n      );\n    })\n    .catch((err: Error) => {\n      console.error('[Gasoline] Failed to execute JS:', err);\n      window.postMessage(\n        {\n          type: 'GASOLINE_EXECUTE_JS_RESULT',\n          requestId,\n          result: { success: false, error: 'execution_failed', message: err.message },\n        },\n        window.location.origin,\n      );\n    });\n}\n\nfunction handleA11yQuery(data: A11yQueryRequestMessageData): void {\n  const { requestId, params } = data;\n\n  if (typeof runAxeAuditWithTimeout !== 'function') {\n    window.postMessage(\n      {\n        type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n        requestId,\n        result: {\n          error: 'runAxeAuditWithTimeout not available - try reloading the extension',\n        },\n      },\n      window.location.origin,\n    );\n    return;\n  }\n\n  try {\n    runAxeAuditWithTimeout(params || {})\n      .then((result) => {\n        window.postMessage(\n          {\n            type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n            requestId,\n            result,\n          },\n          window.location.origin,\n        );\n      })\n      .catch((err: Error) => {\n        console.error('[Gasoline] Accessibility audit error:', err);\n        window.postMessage(\n          {\n            type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n            requestId,\n            result: { error: err.message || 'Accessibility audit failed' },\n          },\n          window.location.origin,\n        );\n      });\n  } catch (err) {\n    console.error('[Gasoline] Failed to run accessibility audit:', err);\n    window.postMessage(\n      {\n        type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n        requestId,\n        result: { error: (err as Error).message || 'Failed to run accessibility audit' },\n      },\n      window.location.origin,\n    );\n  }\n}\n\nfunction handleDomQuery(data: DomQueryRequestMessageData): void {\n  const { requestId, params } = data;\n\n  if (typeof executeDOMQuery !== 'function') {\n    window.postMessage(\n      {\n        type: 'GASOLINE_DOM_QUERY_RESPONSE',\n        requestId,\n        result: {\n          error: 'executeDOMQuery not available - try reloading the extension',\n        },\n      },\n      window.location.origin,\n    );\n    return;\n  }\n\n  try {\n    executeDOMQuery((params || {}) as unknown as DOMQueryParams)\n      .then((result) => {\n        window.postMessage(\n          {\n            type: 'GASOLINE_DOM_QUERY_RESPONSE',\n            requestId,\n            result,\n          },\n          window.location.origin,\n        );\n      })\n      .catch((err: Error) => {\n        console.error('[Gasoline] DOM query error:', err);\n        window.postMessage(\n          {\n            type: 'GASOLINE_DOM_QUERY_RESPONSE',\n            requestId,\n            result: { error: err.message || 'DOM query failed' },\n          },\n          window.location.origin,\n        );\n      });\n  } catch (err) {\n    console.error('[Gasoline] Failed to run DOM query:', err);\n    window.postMessage(\n      {\n        type: 'GASOLINE_DOM_QUERY_RESPONSE',\n        requestId,\n        result: { error: (err as Error).message || 'Failed to run DOM query' },\n      },\n      window.location.origin,\n    );\n  }\n}\n\nfunction handleGetWaterfall(data: GetWaterfallRequestMessageData): void {\n  const { requestId } = data;\n\n  try {\n    const entries = getNetworkWaterfall({});\n\n    window.postMessage(\n      {\n        type: 'GASOLINE_WATERFALL_RESPONSE',\n        requestId,\n        entries: entries || [],\n      },\n      window.location.origin,\n    );\n  } catch (err) {\n    console.error('[Gasoline] Failed to get network waterfall:', err);\n    window.postMessage(\n      {\n        type: 'GASOLINE_WATERFALL_RESPONSE',\n        requestId,\n        entries: [],\n      },\n      window.location.origin,\n    );\n  }\n}\n", "/**\n * @fileoverview State Management - Handles browser state capture/restore and\n * element highlighting for the AI Web Pilot.\n */\n\nimport type { BrowserStateSnapshot } from '../types/index';\nimport { sendPerformanceSnapshot } from '../lib/perf-snapshot';\n\nlet gasolineHighlighter: HTMLDivElement | null = null;\n\n/**\n * Highlight result\n */\nexport interface HighlightResult {\n  success: boolean;\n  selector?: string;\n  bounds?: { x: number; y: number; width: number; height: number };\n  error?: string;\n}\n\n/**\n * Restored state counts\n */\nexport interface RestoredCounts {\n  localStorage: number;\n  sessionStorage: number;\n  cookies: number;\n  skipped: number;\n}\n\n/**\n * Restore state result\n */\nexport interface RestoreStateResult {\n  success: boolean;\n  restored?: RestoredCounts;\n  error?: string;\n}\n\n/**\n * Capture browser state (localStorage, sessionStorage, cookies).\n * Returns a snapshot that can be restored later.\n */\nexport function captureState(): BrowserStateSnapshot {\n  const state: BrowserStateSnapshot = {\n    url: window.location.href,\n    timestamp: Date.now(),\n    localStorage: {},\n    sessionStorage: {},\n    cookies: document.cookie,\n  };\n\n  const localStorageData: Record<string, string> = {};\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    if (key) {\n      localStorageData[key] = localStorage.getItem(key) || '';\n    }\n  }\n  (state as { localStorage: Record<string, string> }).localStorage = localStorageData;\n\n  const sessionStorageData: Record<string, string> = {};\n  for (let i = 0; i < sessionStorage.length; i++) {\n    const key = sessionStorage.key(i);\n    if (key) {\n      sessionStorageData[key] = sessionStorage.getItem(key) || '';\n    }\n  }\n  (state as { sessionStorage: Record<string, string> }).sessionStorage = sessionStorageData;\n\n  return state;\n}\n\n/**\n * Validates a storage key to prevent prototype pollution and other attacks\n */\nfunction isValidStorageKey(key: string): boolean {\n  if (typeof key !== 'string') return false;\n  if (key.length === 0 || key.length > 256) return false;\n\n  // Reject prototype pollution vectors\n  const dangerous = ['__proto__', 'constructor', 'prototype'];\n  const lowerKey = key.toLowerCase();\n  for (const pattern of dangerous) {\n    if (lowerKey.includes(pattern)) return false;\n  }\n\n  return true;\n}\n\n/**\n * Restore browser state from a snapshot.\n * Clears existing state before restoring.\n */\nexport function restoreState(state: BrowserStateSnapshot, includeUrl: boolean = true): RestoreStateResult {\n  // Validate state object\n  if (!state || typeof state !== 'object') {\n    return { success: false, error: 'Invalid state object' };\n  }\n\n  // Clear existing\n  localStorage.clear();\n  sessionStorage.clear();\n\n  // Restore localStorage with validation\n  let skipped = 0;\n  for (const [key, value] of Object.entries(state.localStorage || {})) {\n    if (!isValidStorageKey(key)) {\n      skipped++;\n      console.warn('[gasoline] Skipped localStorage key with invalid pattern:', key);\n      continue;\n    }\n    // Limit value size (10MB max per item)\n    if (typeof value === 'string' && value.length > 10 * 1024 * 1024) {\n      skipped++;\n      console.warn('[gasoline] Skipped localStorage value exceeding 10MB:', key);\n      continue;\n    }\n    localStorage.setItem(key, value);\n  }\n\n  // Restore sessionStorage with validation\n  for (const [key, value] of Object.entries(state.sessionStorage || {})) {\n    if (!isValidStorageKey(key)) {\n      skipped++;\n      console.warn('[gasoline] Skipped sessionStorage key with invalid pattern:', key);\n      continue;\n    }\n    if (typeof value === 'string' && value.length > 10 * 1024 * 1024) {\n      skipped++;\n      console.warn('[gasoline] Skipped sessionStorage value exceeding 10MB:', key);\n      continue;\n    }\n    sessionStorage.setItem(key, value);\n  }\n\n  // Restore cookies (clear then set)\n  document.cookie.split(';').forEach((c) => {\n    const namePart = c.split('=')[0];\n    if (namePart) {\n      const name = namePart.trim();\n      if (name) {\n        document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;\n      }\n    }\n  });\n\n  if (state.cookies) {\n    state.cookies.split(';').forEach((c) => {\n      document.cookie = c.trim();\n    });\n  }\n\n  const restored: RestoredCounts = {\n    localStorage: Object.keys(state.localStorage || {}).length - skipped,\n    sessionStorage: Object.keys(state.sessionStorage || {}).length,\n    cookies: (state.cookies || '').split(';').filter((c) => c.trim()).length,\n    skipped,\n  };\n\n  // Navigate if requested (with basic URL validation)\n  if (includeUrl && state.url && state.url !== window.location.href) {\n    // Basic URL validation: must be http/https\n    try {\n      const url = new URL(state.url);\n      if (url.protocol === 'http:' || url.protocol === 'https:') {\n        window.location.href = state.url;\n      } else {\n        console.warn('[gasoline] Skipped navigation to non-HTTP(S) URL:', state.url);\n      }\n    } catch (e) {\n      console.warn('[gasoline] Invalid URL for navigation:', state.url, e);\n    }\n  }\n\n  if (skipped > 0) {\n    console.warn(`[gasoline] restoreState completed with ${skipped} skipped item(s)`);\n  }\n\n  return { success: true, restored };\n}\n\n/**\n * Highlight a DOM element by injecting a red overlay div.\n */\nexport function highlightElement(selector: string, durationMs: number = 5000): HighlightResult | undefined {\n  // Remove existing highlight\n  if (gasolineHighlighter) {\n    gasolineHighlighter.remove();\n    gasolineHighlighter = null;\n  }\n\n  const element = document.querySelector(selector);\n  if (!element) {\n    return { success: false, error: 'element_not_found', selector };\n  }\n\n  const rect = element.getBoundingClientRect();\n\n  gasolineHighlighter = document.createElement('div');\n  gasolineHighlighter.id = 'gasoline-highlighter';\n  gasolineHighlighter.dataset.selector = selector;\n  Object.assign(gasolineHighlighter.style, {\n    position: 'fixed',\n    top: `${rect.top}px`,\n    left: `${rect.left}px`,\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    border: '4px solid red',\n    borderRadius: '4px',\n    backgroundColor: 'rgba(255, 0, 0, 0.1)',\n    zIndex: '2147483647',\n    pointerEvents: 'none',\n    boxSizing: 'border-box',\n  });\n\n  const targetElement = document.body || document.documentElement;\n  if (targetElement) {\n    targetElement.appendChild(gasolineHighlighter);\n  } else {\n    console.warn('[Gasoline] No document body available for highlighter injection');\n    return;\n  }\n\n  setTimeout(() => {\n    if (gasolineHighlighter) {\n      gasolineHighlighter.remove();\n      gasolineHighlighter = null;\n    }\n  }, durationMs);\n\n  return {\n    success: true,\n    selector,\n    bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n  };\n}\n\n/**\n * Clear any existing highlight\n */\nexport function clearHighlight(): void {\n  if (gasolineHighlighter) {\n    gasolineHighlighter.remove();\n    gasolineHighlighter = null;\n  }\n}\n\n/**\n * Handle scroll - update highlight position\n */\nif (typeof window !== 'undefined') {\n  window.addEventListener(\n    'scroll',\n    () => {\n      if (gasolineHighlighter) {\n        const selector = gasolineHighlighter.dataset.selector;\n        if (selector) {\n          const el = document.querySelector(selector);\n          if (el) {\n            const rect = el.getBoundingClientRect();\n            gasolineHighlighter.style.top = `${rect.top}px`;\n            gasolineHighlighter.style.left = `${rect.left}px`;\n          }\n        }\n      }\n    },\n    { passive: true },\n  );\n}\n\n/**\n * Handle GASOLINE_HIGHLIGHT_REQUEST messages from content script\n */\nif (typeof window !== 'undefined') {\n  window.addEventListener('message', (event: MessageEvent) => {\n    if (event.source !== window) return;\n    if (event.data?.type === 'GASOLINE_HIGHLIGHT_REQUEST') {\n      const { requestId, params } = event.data;\n      const { selector, duration_ms } = params || { selector: '' };\n      const result = highlightElement(selector, duration_ms);\n      window.postMessage(\n        {\n          type: 'GASOLINE_HIGHLIGHT_RESPONSE',\n          requestId,\n          result,\n        },\n        window.location.origin,\n      );\n    }\n  });\n}\n\n/**\n * Wrapper for sending performance snapshot (exported for compatibility)\n */\nexport function sendPerformanceSnapshotWrapper(): void {\n  sendPerformanceSnapshot();\n}\n", "/**\n * @fileoverview inject/index.ts - Main orchestration and barrel exports\n * Combines API, observers, and message handlers for page-level capture.\n */\n\n// Re-export barrel pattern for tests and consumers\nexport { safeSerialize, getElementSelector, isSensitiveInput } from '../lib/serialize';\nexport {\n  getContextAnnotations,\n  setContextAnnotation,\n  removeContextAnnotation,\n  clearContextAnnotations,\n} from '../lib/context';\nexport {\n  getImplicitRole,\n  isDynamicClass,\n  computeCssPath,\n  computeSelectors,\n  recordEnhancedAction,\n  getEnhancedActionBuffer,\n  clearEnhancedActionBuffer,\n  generatePlaywrightScript,\n} from '../lib/reproduction';\nexport {\n  recordAction,\n  getActionBuffer,\n  clearActionBuffer,\n  handleClick,\n  handleInput,\n  handleScroll,\n  handleKeydown,\n  handleChange,\n  installActionCapture,\n  uninstallActionCapture,\n  setActionCaptureEnabled,\n  installNavigationCapture,\n  uninstallNavigationCapture,\n} from '../lib/actions';\nexport {\n  parseResourceTiming,\n  getNetworkWaterfall,\n  trackPendingRequest,\n  completePendingRequest,\n  getPendingRequests,\n  clearPendingRequests,\n  getNetworkWaterfallForError,\n  setNetworkWaterfallEnabled,\n  isNetworkWaterfallEnabled,\n  setNetworkBodyCaptureEnabled,\n  isNetworkBodyCaptureEnabled,\n  shouldCaptureUrl,\n  setServerUrl,\n  sanitizeHeaders,\n  truncateRequestBody,\n  truncateResponseBody,\n  readResponseBody,\n  readResponseBodyWithTimeout,\n  wrapFetchWithBodies,\n} from '../lib/network';\nexport {\n  getPerformanceMarks,\n  getPerformanceMeasures,\n  getCapturedMarks,\n  getCapturedMeasures,\n  installPerformanceCapture,\n  uninstallPerformanceCapture,\n  isPerformanceCaptureActive,\n  getPerformanceSnapshotForError,\n  setPerformanceMarksEnabled,\n  isPerformanceMarksEnabled,\n} from '../lib/performance';\nexport { postLog } from '../lib/bridge';\nexport { installConsoleCapture, uninstallConsoleCapture } from '../lib/console';\nexport {\n  parseStackFrames,\n  parseSourceMap,\n  extractSnippet,\n  extractSourceSnippets,\n  detectFramework,\n  getReactComponentAncestry,\n  captureStateSnapshot,\n  generateAiSummary,\n  enrichErrorWithAiContext,\n  setAiContextEnabled,\n  setAiContextStateSnapshot,\n  setSourceMapCache,\n  getSourceMapCache,\n  getSourceMapCacheSize,\n} from '../lib/ai-context';\nexport { installExceptionCapture, uninstallExceptionCapture } from '../lib/exceptions';\nexport {\n  getSize,\n  formatPayload,\n  truncateWsMessage,\n  createConnectionTracker,\n  installWebSocketCapture,\n  setWebSocketCaptureMode,\n  setWebSocketCaptureEnabled,\n  getWebSocketCaptureMode,\n  uninstallWebSocketCapture,\n} from '../lib/websocket';\nexport {\n  executeDOMQuery,\n  getPageInfo,\n  runAxeAudit,\n  runAxeAuditWithTimeout,\n  formatAxeResults,\n} from '../lib/dom-queries';\nexport {\n  mapInitiatorType,\n  aggregateResourceTiming,\n  capturePerformanceSnapshot,\n  installPerfObservers,\n  uninstallPerfObservers,\n  getLongTaskMetrics,\n  getFCP,\n  getLCP,\n  getCLS,\n  getINP,\n  sendPerformanceSnapshot,\n  isPerformanceSnapshotEnabled,\n  setPerformanceSnapshotEnabled,\n} from '../lib/perf-snapshot';\n\n// Re-export constants that tests import from inject.js\nexport { MAX_WATERFALL_ENTRIES, MAX_PERFORMANCE_ENTRIES, SENSITIVE_HEADERS } from '../lib/constants';\n\n// Export API module\nexport { installGasolineAPI, uninstallGasolineAPI, type GasolineAPI } from './api';\n\n// Export observer module\nexport {\n  install,\n  uninstall,\n  installFetchCapture,\n  uninstallFetchCapture,\n  installPhase1,\n  installPhase2,\n  getDeferralState,\n  setDeferralEnabled,\n  shouldDeferIntercepts,\n  checkMemoryPressure,\n  type DeferralState,\n} from './observers';\n\n// Export message handlers module\nexport {\n  installMessageListener,\n  executeJavaScript,\n  safeSerializeForExecute,\n} from './message-handlers';\n\n// Export state management functions\nexport {\n  captureState,\n  restoreState,\n  highlightElement,\n  clearHighlight,\n  type RestoreStateResult,\n  type RestoredCounts,\n  type HighlightResult,\n} from './state';\n\nimport { installGasolineAPI } from './api';\nimport { installPhase1 } from './observers';\nimport { installMessageListener } from './message-handlers';\nimport { captureState, restoreState, sendPerformanceSnapshotWrapper } from './state';\nimport { sendPerformanceSnapshot } from '../lib/perf-snapshot';\n\n/**\n * Auto-install when loaded in browser\n */\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  // Install Phase 1 (lightweight API + observers)\n  installPhase1();\n\n  // Install message listener with state functions\n  installMessageListener(captureState, restoreState);\n\n  // Install Gasoline API\n  installGasolineAPI();\n\n  // Send performance snapshot after page load + 2s settling time\n  window.addEventListener('load', () => {\n    setTimeout(() => {\n      sendPerformanceSnapshot();\n    }, 2000);\n  });\n}\n"],
  "mappings": "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",
  "names": ["n", "window"]
}
