{
  "version": 3,
  "sources": ["../src/offscreen/recording-worker.ts"],
  "sourcesContent": ["// recording-worker.ts \u2014 Offscreen document recording engine.\n// Receives a tab media stream ID from the service worker, captures video/audio\n// via MediaRecorder, and POSTs the final blob to the Go server on stop.\n// Standalone: imports nothing from src/background/ to avoid circular deps.\n\nimport type { OffscreenStartRecordingMessage, OffscreenStopRecordingMessage } from '../types/runtime-messages'\n\n/** Maximum recording size in bytes before auto-stop (1GB). */\nconst MAX_RECORDING_BYTES = 1024 * 1024 * 1024\n\ninterface RecordingState {\n  active: boolean\n  name: string\n  startTime: number\n  serverUrl: string\n  fps: number\n  audioMode: string\n  tabId: number\n  url: string\n  recorder: MediaRecorder | null\n  stream: MediaStream | null\n  chunks: Blob[]\n  totalBytes: number\n}\n\nconst defaultState: RecordingState = {\n  active: false,\n  name: '',\n  startTime: 0,\n  serverUrl: '',\n  fps: 15,\n  audioMode: '',\n  tabId: 0,\n  url: '',\n  recorder: null,\n  stream: null,\n  chunks: [],\n  totalBytes: 0\n}\n\nlet state: RecordingState = { ...defaultState }\n\nconst LOG = '[Gasoline REC offscreen]'\n\n/**\n * Start recording using a tab capture stream ID.\n * Called when the service worker sends OFFSCREEN_START_RECORDING.\n */\n// #lizard forgives\nasync function handleStartRecording(msg: OffscreenStartRecordingMessage): Promise<void> {\n  console.log(LOG, 'handleStartRecording', {\n    name: msg.name,\n    audioMode: msg.audioMode,\n    fps: msg.fps,\n    tabId: msg.tabId,\n    streamId: msg.streamId?.substring(0, 20) + '...',\n    currentlyActive: state.active\n  })\n  if (state.active) {\n    console.warn(LOG, 'START BLOCKED: already recording')\n    chrome.runtime.sendMessage({\n      target: 'background',\n      type: 'OFFSCREEN_RECORDING_STARTED',\n      success: false,\n      error: 'RECORD_START: Already recording in offscreen document.'\n    })\n    return\n  }\n\n  state.active = true // eslint-disable-line require-atomic-updates\n\n  // Track all acquired streams for cleanup on failure\n  const acquiredStreams: MediaStream[] = []\n\n  try {\n    const fps = Math.max(5, Math.min(60, msg.fps))\n    const hasTabAudio = msg.audioMode === 'tab' || msg.audioMode === 'both'\n    const hasMicAudio = msg.audioMode === 'mic' || msg.audioMode === 'both'\n    const hasAnyAudio = hasTabAudio || hasMicAudio\n\n    // Get tab video (+ tab audio if requested)\n    const tabConstraints: MediaStreamConstraints = {\n      video: {\n        // @ts-expect-error -- Chrome-specific mandatory constraints for tab capture\n        mandatory: {\n          chromeMediaSource: 'tab',\n          chromeMediaSourceId: msg.streamId,\n          minWidth: 1280,\n          minHeight: 720,\n          maxWidth: 1920,\n          maxHeight: 1080,\n          maxFrameRate: fps\n        }\n      },\n      audio: hasTabAudio\n        ? {\n            // @ts-expect-error -- Chrome-specific mandatory constraints for tab audio\n            mandatory: {\n              chromeMediaSource: 'tab',\n              chromeMediaSourceId: msg.streamId\n            }\n          }\n        : false\n    }\n\n    console.log(LOG, 'Calling getUserMedia for tab stream', { hasTabAudio, hasMicAudio })\n    const tabStream = await navigator.mediaDevices.getUserMedia(tabConstraints)\n    acquiredStreams.push(tabStream)\n    console.log(LOG, 'Got tab stream', {\n      videoTracks: tabStream.getVideoTracks().length,\n      audioTracks: tabStream.getAudioTracks().length\n    })\n\n    // Build the final stream: start with tab video\n    let stream: MediaStream\n\n    if (hasMicAudio && hasTabAudio) {\n      // Both: mix tab audio + mic audio via AudioContext\n      // Tab audio is captured digitally so disable echo cancellation to avoid degrading mic quality\n      const micStream = await navigator.mediaDevices.getUserMedia({\n        audio: { echoCancellation: false, noiseSuppression: true, autoGainControl: true }\n      })\n      acquiredStreams.push(micStream)\n      const audioCtx = new AudioContext()\n      const tabSource = audioCtx.createMediaStreamSource(new MediaStream(tabStream.getAudioTracks()))\n      const micSource = audioCtx.createMediaStreamSource(micStream)\n      const dest = audioCtx.createMediaStreamDestination()\n      tabSource.connect(dest)\n      micSource.connect(dest)\n      stream = new MediaStream([...tabStream.getVideoTracks(), ...dest.stream.getAudioTracks()])\n    } else if (hasMicAudio) {\n      // Mic only: no tab audio playing, keep default processing\n      const micStream = await navigator.mediaDevices.getUserMedia({\n        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }\n      })\n      acquiredStreams.push(micStream)\n      stream = new MediaStream([...tabStream.getVideoTracks(), ...micStream.getAudioTracks()])\n    } else {\n      // Tab audio or no audio: use tabStream as-is\n      stream = tabStream\n    }\n\n    // Scale bitrate proportionally: 500kbps at 15fps baseline\n    const bitrate = Math.round((fps / 15) * 500_000)\n    const mimeType = hasAnyAudio ? 'video/webm;codecs=vp8,opus' : 'video/webm;codecs=vp8'\n\n    const recorderOptions: MediaRecorderOptions = {\n      mimeType,\n      videoBitsPerSecond: bitrate\n    }\n    if (hasAnyAudio) {\n      recorderOptions.audioBitsPerSecond = 128_000 // 128kbps Opus for clear audio\n    }\n    const recorder = new MediaRecorder(stream, recorderOptions)\n\n    const chunks: Blob[] = []\n    let totalBytes = 0\n    let autoStopping = false\n\n    recorder.ondataavailable = (e: BlobEvent) => {\n      if (e.data.size > 0) {\n        chunks.push(e.data)\n        totalBytes += e.data.size\n        state.totalBytes = totalBytes\n\n        // Memory guard: auto-stop if approaching limit\n        if (totalBytes >= MAX_RECORDING_BYTES && !autoStopping) {\n          autoStopping = true\n          handleStopRecording(true)\n        }\n      }\n    }\n\n    // Listen for stream ending (tab closed)\n    const videoTrack = stream.getVideoTracks()[0]\n    if (videoTrack) {\n      videoTrack.onended = () => {\n        if (state.active && !autoStopping) {\n          autoStopping = true\n          handleStopRecording(true)\n        }\n      }\n    }\n\n    console.log(LOG, 'Starting MediaRecorder', { mimeType, videoBps: bitrate, audioBps: hasAnyAudio ? 128000 : 0 })\n    recorder.start(1000) // Collect chunks every 1s\n\n    state = {\n      active: true,\n      name: msg.name,\n      startTime: Date.now(),\n      serverUrl: msg.serverUrl,\n      fps,\n      audioMode: msg.audioMode,\n      tabId: msg.tabId,\n      url: msg.url,\n      recorder,\n      stream,\n      chunks,\n      totalBytes: 0\n    }\n\n    console.log(LOG, 'Recording STARTED, sending confirmation to background')\n    chrome.runtime.sendMessage({\n      target: 'background',\n      type: 'OFFSCREEN_RECORDING_STARTED',\n      success: true\n    })\n  } catch (err) {\n    console.error(LOG, 'START EXCEPTION:', (err as Error).message, (err as Error).stack)\n    // Clean up any acquired streams to release the tab capture\n    for (const s of acquiredStreams) {\n      console.log(LOG, 'Cleaning up leaked stream, stopping', s.getTracks().length, 'tracks')\n      s.getTracks().forEach((t) => t.stop())\n    }\n    state = { ...defaultState } // eslint-disable-line require-atomic-updates\n    chrome.runtime.sendMessage({\n      target: 'background',\n      type: 'OFFSCREEN_RECORDING_STARTED',\n      success: false,\n      error: `RECORD_START: ${(err as Error).message || 'Failed to start recording in offscreen document.'}`\n    })\n  }\n}\n\n/**\n * Stop recording, assemble the blob, and POST to the Go server.\n * @param truncated \u2014 true if auto-stopped due to memory guard or tab close\n */\nfunction handleStopRecording(truncated: boolean = false): void {\n  console.log(LOG, 'handleStopRecording', {\n    active: state.active,\n    name: state.name,\n    truncated,\n    chunks: state.chunks.length,\n    totalBytes: state.totalBytes,\n    recorderState: state.recorder?.state\n  })\n  if (!state.active) {\n    console.warn(LOG, 'STOP: not active')\n    chrome.runtime.sendMessage({\n      target: 'background',\n      type: 'OFFSCREEN_RECORDING_STOPPED',\n      status: 'error',\n      name: '',\n      error: 'RECORD_STOP: No active recording in offscreen document.'\n    })\n    return\n  }\n\n  const { name, startTime, recorder, stream, chunks, serverUrl } = state\n  state.active = false\n\n  if (!recorder || recorder.state === 'inactive') {\n    console.warn(LOG, 'STOP: recorder null or inactive', { recorder: !!recorder, state: recorder?.state })\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop())\n    }\n    state = { ...defaultState }\n    chrome.runtime.sendMessage({\n      target: 'background',\n      type: 'OFFSCREEN_RECORDING_STOPPED',\n      status: 'error',\n      name: '',\n      error: 'RECORD_STOP: Recorder already inactive.'\n    })\n    return\n  }\n\n  console.log(LOG, 'Stopping recorder, waiting for onstop callback')\n  // #lizard forgives\n  recorder.onstop = async () => {\n    try {\n      const blob = new Blob(chunks, { type: 'video/webm' })\n      const duration = Math.round((Date.now() - startTime) / 1000)\n      console.log(LOG, 'Recorder stopped, assembling blob', { chunks: chunks.length, size: blob.size, duration })\n\n      // Stop media stream tracks\n      if (stream) {\n        stream.getTracks().forEach((t) => t.stop())\n      }\n\n      // Build display name from the slug\n      const displayName = name.replace(/--\\d{4}-\\d{2}-\\d{2}-\\d{4}(-\\d+)?$/, '').replace(/-/g, ' ')\n\n      // POST to Go server\n      const hasAudio = state.audioMode === 'tab' || state.audioMode === 'both' || state.audioMode === 'mic'\n      const format = hasAudio ? 'video/webm;codecs=vp8,opus' : 'video/webm;codecs=vp8'\n      const formData = new FormData()\n      formData.append('video', blob, `${name}.webm`)\n      formData.append(\n        'metadata',\n        JSON.stringify({\n          name,\n          display_name: displayName,\n          created_at: new Date(startTime).toISOString(),\n          duration_seconds: duration,\n          size_bytes: blob.size,\n          url: state.url,\n          tab_id: state.tabId,\n          resolution: '1920x1080',\n          format,\n          fps: state.fps,\n          has_audio: hasAudio,\n          audio_mode: state.audioMode || undefined,\n          truncated\n        })\n      )\n\n      console.log(LOG, 'POSTing to', `${serverUrl}/recordings/save`, { size: blob.size, hasAudio })\n      const response = await fetch(`${serverUrl}/recordings/save`, {\n        method: 'POST',\n        headers: { 'X-Gasoline-Client': 'gasoline-extension-offscreen' },\n        body: formData\n      })\n      console.log(LOG, 'Server response:', response.status)\n\n      state = { ...defaultState }\n\n      if (!response.ok) {\n        console.error(LOG, 'Server returned error:', response.status)\n        chrome.runtime.sendMessage({\n          target: 'background',\n          type: 'OFFSCREEN_RECORDING_STOPPED',\n          status: 'error',\n          name,\n          error: `RECORD_STOP: Server returned ${response.status}.`\n        })\n        return\n      }\n\n      let savePath: string | undefined\n      try {\n        const body = (await response.json()) as { path?: string }\n        savePath = body.path\n      } catch {\n        /* path is optional */\n      }\n\n      console.log(LOG, 'Recording SAVED', { name, duration, size: blob.size, path: savePath })\n      chrome.runtime.sendMessage({\n        target: 'background',\n        type: 'OFFSCREEN_RECORDING_STOPPED',\n        status: 'saved',\n        name,\n        duration_seconds: duration,\n        size_bytes: blob.size,\n        truncated: truncated || undefined,\n        path: savePath\n      })\n    } catch (err) {\n      console.error(LOG, 'SAVE EXCEPTION:', (err as Error).message, (err as Error).stack)\n      state = { ...defaultState }\n      chrome.runtime.sendMessage({\n        target: 'background',\n        type: 'OFFSCREEN_RECORDING_STOPPED',\n        status: 'error',\n        name,\n        error: `RECORD_STOP: ${(err as Error).message || 'Save failed.'}`\n      })\n    }\n  }\n\n  recorder.stop()\n}\n\n// Listen for messages from the service worker\nconsole.log(LOG, 'Offscreen recording worker loaded')\nchrome.runtime.onMessage.addListener(\n  (message: OffscreenStartRecordingMessage | OffscreenStopRecordingMessage, sender: chrome.runtime.MessageSender) => {\n    // Only handle messages from the extension itself\n    if (sender.id !== chrome.runtime.id) return\n    // Only handle messages targeted at offscreen\n    if ((message as { target?: string }).target !== 'offscreen') return\n\n    console.log(LOG, 'Received message:', message.type)\n    if (message.type === 'OFFSCREEN_START_RECORDING') {\n      handleStartRecording(message as OffscreenStartRecordingMessage)\n    } else if (message.type === 'OFFSCREEN_STOP_RECORDING') {\n      handleStopRecording()\n    }\n  }\n)\n"],
  "mappings": "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",
  "names": []
}
