// boundary_test.go â€” Test boundaries for concurrent test correlation.
// Tests test_boundary_start/end actions, tagging, filtering, and concurrent boundaries.
package capture

import (
	"encoding/json"
	"testing"
)

// TestBoundaryStart verifies that test_boundary_start action works
func TestBoundaryStart(t *testing.T) {
	capture := NewCapture()

	// Start a test boundary
	capture.mu.Lock()
	capture.activeTestIDs["test-1"] = true
	capture.mu.Unlock()

	// Verify the test ID is active
	capture.mu.RLock()
	isActive := capture.activeTestIDs["test-1"]
	capture.mu.RUnlock()

	if !isActive {
		t.Error("Test ID should be active after start")
	}
}

// TestBoundaryEnd verifies that test_boundary_end action works
func TestBoundaryEnd(t *testing.T) {
	capture := NewCapture()

	// Start and then end a test boundary
	capture.mu.Lock()
	capture.activeTestIDs["test-1"] = true
	capture.mu.Unlock()

	capture.mu.Lock()
	delete(capture.activeTestIDs, "test-1")
	capture.mu.Unlock()

	// Verify the test ID is no longer active
	capture.mu.RLock()
	isActive := capture.activeTestIDs["test-1"]
	capture.mu.RUnlock()

	if isActive {
		t.Error("Test ID should be inactive after end")
	}
}

// TestConcurrentBoundaries verifies that multiple test boundaries can be active simultaneously
func TestConcurrentBoundaries(t *testing.T) {
	capture := NewCapture()

	// Start multiple test boundaries
	capture.mu.Lock()
	capture.activeTestIDs["test-1"] = true
	capture.activeTestIDs["test-2"] = true
	capture.activeTestIDs["test-3"] = true
	capture.mu.Unlock()

	// Verify all are active
	capture.mu.RLock()
	count := len(capture.activeTestIDs)
	test1Active := capture.activeTestIDs["test-1"]
	test2Active := capture.activeTestIDs["test-2"]
	test3Active := capture.activeTestIDs["test-3"]
	capture.mu.RUnlock()

	if count != 3 {
		t.Errorf("Expected 3 active test IDs, got %d", count)
	}
	if !test1Active || !test2Active || !test3Active {
		t.Error("All test IDs should be active")
	}

	// End one boundary while others remain
	capture.mu.Lock()
	delete(capture.activeTestIDs, "test-2")
	capture.mu.Unlock()

	capture.mu.RLock()
	count = len(capture.activeTestIDs)
	test2Active = capture.activeTestIDs["test-2"]
	capture.mu.RUnlock()

	if count != 2 {
		t.Errorf("Expected 2 active test IDs after deleting one, got %d", count)
	}
	if test2Active {
		t.Error("Deleted test ID should not be active")
	}
}

// TestNetworkBodyTagging verifies that network bodies are tagged with active test IDs
func TestNetworkBodyTagging(t *testing.T) {
	capture := NewCapture()

	// Start two test boundaries
	capture.mu.Lock()
	capture.activeTestIDs["test-a"] = true
	capture.activeTestIDs["test-b"] = true
	capture.mu.Unlock()

	// Add a network body
	bodies := []NetworkBody{
		{
			Method:  "GET",
			URL:     "https://example.com/api",
			Status:  200,
			TabId:   1,
			TestIDs: []string{}, // Will be populated by AddNetworkBodies
		},
	}
	capture.AddNetworkBodies(bodies)

	// Retrieve and verify tagging
	capture.mu.RLock()
	if len(capture.networkBodies) != 1 {
		t.Errorf("Expected 1 network body, got %d", len(capture.networkBodies))
	}
	body := capture.networkBodies[0]
	testIDs := body.TestIDs
	capture.mu.RUnlock()

	if len(testIDs) != 2 {
		t.Errorf("Expected 2 test IDs on network body, got %d", len(testIDs))
	}

	// Verify both test IDs are present (order doesn't matter)
	testIDMap := make(map[string]bool)
	for _, tid := range testIDs {
		testIDMap[tid] = true
	}
	if !testIDMap["test-a"] || !testIDMap["test-b"] {
		t.Errorf("Expected test IDs 'test-a' and 'test-b', got %v", testIDs)
	}
}

// TestNetworkBodyFiltering verifies that network bodies can be filtered by test ID
func TestNetworkBodyFiltering(t *testing.T) {
	capture := NewCapture()

	// Start test-a, add a body, end test-a, start test-b, add another body
	capture.mu.Lock()
	capture.activeTestIDs["test-a"] = true
	capture.mu.Unlock()

	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://example.com/api/a", Status: 200, TabId: 1},
	})

	capture.mu.Lock()
	delete(capture.activeTestIDs, "test-a")
	capture.activeTestIDs["test-b"] = true
	capture.mu.Unlock()

	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://example.com/api/b", Status: 200, TabId: 1},
	})

	// Filter by test-a
	filteredA := capture.GetNetworkBodies(NetworkBodyFilter{TestID: "test-a"})
	if len(filteredA) != 1 {
		t.Errorf("Expected 1 body for test-a, got %d", len(filteredA))
	}
	if filteredA[0].URL != "https://example.com/api/a" {
		t.Errorf("Expected URL for test-a, got %s", filteredA[0].URL)
	}

	// Filter by test-b
	filteredB := capture.GetNetworkBodies(NetworkBodyFilter{TestID: "test-b"})
	if len(filteredB) != 1 {
		t.Errorf("Expected 1 body for test-b, got %d", len(filteredB))
	}
	if filteredB[0].URL != "https://example.com/api/b" {
		t.Errorf("Expected URL for test-b, got %s", filteredB[0].URL)
	}

	// Filter with no test ID (should return all)
	allFiltered := capture.GetNetworkBodies(NetworkBodyFilter{})
	if len(allFiltered) != 2 {
		t.Errorf("Expected 2 bodies with no filter, got %d", len(allFiltered))
	}
}

// TestWebSocketEventTagging verifies that WebSocket events are tagged with active test IDs
func TestWebSocketEventTagging(t *testing.T) {
	capture := NewCapture()

	// Start a test boundary
	capture.mu.Lock()
	capture.activeTestIDs["ws-test"] = true
	capture.mu.Unlock()

	// Add a WebSocket event
	events := []WebSocketEvent{
		{
			ID:        "ws-1",
			URL:       "wss://example.com/chat",
			Direction: "outgoing",
			Event:     "message",
			Data:      "hello",
			TabId:     1,
			TestIDs:   []string{}, // Will be populated by AddWebSocketEvents
		},
	}
	capture.AddWebSocketEvents(events)

	// Retrieve and verify tagging
	capture.mu.RLock()
	if len(capture.wsEvents) != 1 {
		t.Errorf("Expected 1 WebSocket event, got %d", len(capture.wsEvents))
	}
	event := capture.wsEvents[0]
	testIDs := event.TestIDs
	capture.mu.RUnlock()

	if len(testIDs) != 1 || testIDs[0] != "ws-test" {
		t.Errorf("Expected test ID 'ws-test', got %v", testIDs)
	}
}

// TestWebSocketEventFiltering verifies that WebSocket events can be filtered by test ID
func TestWebSocketEventFiltering(t *testing.T) {
	capture := NewCapture()

	// Add events for test-x and test-y
	capture.mu.Lock()
	capture.activeTestIDs["test-x"] = true
	capture.mu.Unlock()

	capture.AddWebSocketEvents([]WebSocketEvent{
		{ID: "ws-1", URL: "wss://example.com/x", Event: "message", Data: "x", TabId: 1},
	})

	capture.mu.Lock()
	delete(capture.activeTestIDs, "test-x")
	capture.activeTestIDs["test-y"] = true
	capture.mu.Unlock()

	capture.AddWebSocketEvents([]WebSocketEvent{
		{ID: "ws-2", URL: "wss://example.com/y", Event: "message", Data: "y", TabId: 1},
	})

	// Filter by test-x
	filteredX := capture.GetWebSocketEvents(WebSocketEventFilter{TestID: "test-x"})
	if len(filteredX) != 1 {
		t.Errorf("Expected 1 event for test-x, got %d", len(filteredX))
	}

	// Filter by test-y
	filteredY := capture.GetWebSocketEvents(WebSocketEventFilter{TestID: "test-y"})
	if len(filteredY) != 1 {
		t.Errorf("Expected 1 event for test-y, got %d", len(filteredY))
	}
}

// TestEnhancedActionTagging verifies that enhanced actions are tagged with active test IDs
func TestEnhancedActionTagging(t *testing.T) {
	capture := NewCapture()

	// Start test boundary
	capture.mu.Lock()
	capture.activeTestIDs["action-test"] = true
	capture.mu.Unlock()

	// Add an action
	actions := []EnhancedAction{
		{
			Type:      "click",
			Timestamp: 1000,
			URL:       "https://example.com",
			TabId:     1,
			TestIDs:   []string{}, // Will be populated by AddEnhancedActions
		},
	}
	capture.AddEnhancedActions(actions)

	// Verify tagging
	capture.mu.RLock()
	if len(capture.enhancedActions) != 1 {
		t.Errorf("Expected 1 action, got %d", len(capture.enhancedActions))
	}
	action := capture.enhancedActions[0]
	testIDs := action.TestIDs
	capture.mu.RUnlock()

	if len(testIDs) != 1 || testIDs[0] != "action-test" {
		t.Errorf("Expected test ID 'action-test', got %v", testIDs)
	}
}

// TestEnhancedActionFiltering verifies that actions can be filtered by test ID
func TestEnhancedActionFiltering(t *testing.T) {
	capture := NewCapture()

	// Add actions for test-1 and test-2
	capture.mu.Lock()
	capture.activeTestIDs["test-1"] = true
	capture.mu.Unlock()

	capture.AddEnhancedActions([]EnhancedAction{
		{Type: "click", Timestamp: 1000, URL: "https://example.com/1", TabId: 1},
	})

	capture.mu.Lock()
	delete(capture.activeTestIDs, "test-1")
	capture.activeTestIDs["test-2"] = true
	capture.mu.Unlock()

	capture.AddEnhancedActions([]EnhancedAction{
		{Type: "input", Timestamp: 2000, URL: "https://example.com/2", TabId: 1},
	})

	// Filter by test-1
	filtered1 := capture.GetEnhancedActions(EnhancedActionFilter{TestID: "test-1"})
	if len(filtered1) != 1 {
		t.Errorf("Expected 1 action for test-1, got %d", len(filtered1))
	}

	// Filter by test-2
	filtered2 := capture.GetEnhancedActions(EnhancedActionFilter{TestID: "test-2"})
	if len(filtered2) != 1 {
		t.Errorf("Expected 1 action for test-2, got %d", len(filtered2))
	}
}

// TestConcurrentBoundaryTagging verifies that entries capture all active boundaries at tagging time
func TestConcurrentBoundaryTagging(t *testing.T) {
	capture := NewCapture()

	// Start performance test
	capture.mu.Lock()
	capture.activeTestIDs["perf"] = true
	capture.mu.Unlock()

	// Add entry (should be tagged with perf)
	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://example.com/1", Status: 200, TabId: 1},
	})

	// Start feature test while perf is running
	capture.mu.Lock()
	capture.activeTestIDs["feature"] = true
	capture.mu.Unlock()

	// Add entry (should be tagged with both perf and feature)
	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://example.com/2", Status: 200, TabId: 1},
	})

	// End feature test, perf still running
	capture.mu.Lock()
	delete(capture.activeTestIDs, "feature")
	capture.mu.Unlock()

	// Add entry (should be tagged with perf only)
	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://example.com/3", Status: 200, TabId: 1},
	})

	// Verify tagging
	capture.mu.RLock()
	bodies := capture.networkBodies
	capture.mu.RUnlock()

	if len(bodies) != 3 {
		t.Errorf("Expected 3 bodies, got %d", len(bodies))
	}

	// Body 1 should have perf only
	if len(bodies[0].TestIDs) != 1 || bodies[0].TestIDs[0] != "perf" {
		t.Errorf("Body 1 should have perf only, got %v", bodies[0].TestIDs)
	}

	// Body 2 should have both perf and feature
	if len(bodies[1].TestIDs) != 2 {
		t.Errorf("Body 2 should have 2 test IDs, got %d", len(bodies[1].TestIDs))
	}
	testIDMap := make(map[string]bool)
	for _, tid := range bodies[1].TestIDs {
		testIDMap[tid] = true
	}
	if !testIDMap["perf"] || !testIDMap["feature"] {
		t.Errorf("Body 2 should have perf and feature, got %v", bodies[1].TestIDs)
	}

	// Body 3 should have perf only
	if len(bodies[2].TestIDs) != 1 || bodies[2].TestIDs[0] != "perf" {
		t.Errorf("Body 3 should have perf only, got %v", bodies[2].TestIDs)
	}
}

// TestBoundaryWithJSON verifies JSON serialization of tagged entries
func TestBoundaryWithJSON(t *testing.T) {
	capture := NewCapture()

	// Start a test
	capture.mu.Lock()
	capture.activeTestIDs["json-test"] = true
	capture.mu.Unlock()

	// Add a body
	capture.AddNetworkBodies([]NetworkBody{
		{
			Method:       "POST",
			URL:          "https://api.example.com/data",
			Status:       201,
			RequestBody:  `{"key":"value"}`,
			ResponseBody: `{"result":"ok"}`,
			TabId:        1,
		},
	})

	// Serialize to JSON
	capture.mu.RLock()
	body := capture.networkBodies[0]
	capture.mu.RUnlock()

	jsonBytes, err := json.Marshal(body)
	if err != nil {
		t.Fatalf("Failed to marshal body: %v", err)
	}

	// Deserialize and verify
	var deserialized NetworkBody
	if err := json.Unmarshal(jsonBytes, &deserialized); err != nil {
		t.Fatalf("Failed to unmarshal body: %v", err)
	}

	if len(deserialized.TestIDs) != 1 || deserialized.TestIDs[0] != "json-test" {
		t.Errorf("Expected test ID in deserialized body, got %v", deserialized.TestIDs)
	}
}

// TestFilteringWithMultipleCriteria verifies that test_id filters work with other filters
func TestFilteringWithMultipleCriteria(t *testing.T) {
	capture := NewCapture()

	// Add entries with test-a
	capture.mu.Lock()
	capture.activeTestIDs["test-a"] = true
	capture.mu.Unlock()

	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://api.example.com/users", Status: 200, TabId: 1},
		{Method: "POST", URL: "https://api.example.com/users", Status: 201, TabId: 1},
		{Method: "GET", URL: "https://api.example.com/posts", Status: 200, TabId: 1},
	})

	// Add entries with test-b
	capture.mu.Lock()
	delete(capture.activeTestIDs, "test-a")
	capture.activeTestIDs["test-b"] = true
	capture.mu.Unlock()

	capture.AddNetworkBodies([]NetworkBody{
		{Method: "GET", URL: "https://api.example.com/users", Status: 200, TabId: 1},
	})

	// Filter by test-a AND URL containing "users"
	filtered := capture.GetNetworkBodies(NetworkBodyFilter{
		TestID:    "test-a",
		URLFilter: "users",
	})

	if len(filtered) != 2 {
		t.Errorf("Expected 2 bodies for test-a with 'users' in URL, got %d", len(filtered))
	}

	// Filter by test-a AND POST method
	filtered = capture.GetNetworkBodies(NetworkBodyFilter{
		TestID: "test-a",
		Method: "POST",
	})

	if len(filtered) != 1 {
		t.Errorf("Expected 1 POST body for test-a, got %d", len(filtered))
	}

	// Filter by test-b (should only get one result)
	filtered = capture.GetNetworkBodies(NetworkBodyFilter{TestID: "test-b"})

	if len(filtered) != 1 {
		t.Errorf("Expected 1 body for test-b, got %d", len(filtered))
	}
}
