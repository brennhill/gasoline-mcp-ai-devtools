
> lint
> eslint . --format json

[{"filePath":"/Users/brenn/dev/gasoline/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/batchers.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":39,"column":16,"nodeType":"MemberExpression","endLine":39,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Batchers - Batcher creation and circuit breaker integration for\n * debounced batching of server requests.\n */\nimport { createCircuitBreaker } from './circuit-breaker.js';\nimport { MAX_PENDING_BUFFER } from './state-manager.js';\nconst DEFAULT_DEBOUNCE_MS = 100;\nconst DEFAULT_MAX_BATCH_SIZE = 50;\n/** Rate limit configuration */\nexport const RATE_LIMIT_CONFIG = {\n    maxFailures: 5,\n    resetTimeout: 30000,\n    backoffSchedule: [100, 500, 2000],\n    retryBudget: 3,\n};\n/**\n * Creates a batcher wired with circuit breaker logic for rate limiting.\n */\nexport function createBatcherWithCircuitBreaker(sendFn, options = {}) {\n    const debounceMs = options.debounceMs ?? DEFAULT_DEBOUNCE_MS;\n    const maxBatchSize = options.maxBatchSize ?? DEFAULT_MAX_BATCH_SIZE;\n    const retryBudget = options.retryBudget ?? RATE_LIMIT_CONFIG.retryBudget;\n    const maxFailures = options.maxFailures ?? RATE_LIMIT_CONFIG.maxFailures;\n    const resetTimeout = options.resetTimeout ?? RATE_LIMIT_CONFIG.resetTimeout;\n    const backoffSchedule = RATE_LIMIT_CONFIG.backoffSchedule;\n    const localConnectionStatus = { connected: true };\n    const isSharedCB = !!options.sharedCircuitBreaker;\n    const cb = options.sharedCircuitBreaker ||\n        createCircuitBreaker(sendFn, {\n            maxFailures,\n            resetTimeout,\n            initialBackoff: 0,\n            maxBackoff: 0,\n        });\n    function getScheduledBackoff(failures) {\n        if (failures <= 0)\n            return 0;\n        const idx = Math.min(failures - 1, backoffSchedule.length - 1);\n        return backoffSchedule[idx];\n    }\n    const wrappedCircuitBreaker = {\n        getState: () => cb.getState(),\n        getStats: () => {\n            const stats = cb.getStats();\n            return {\n                ...stats,\n                currentBackoff: getScheduledBackoff(stats.consecutiveFailures),\n            };\n        },\n        reset: () => cb.reset(),\n    };\n    async function attemptSend(entries) {\n        if (!isSharedCB) {\n            return await cb.execute(entries);\n        }\n        const state = cb.getState();\n        if (state === 'open') {\n            const stats = cb.getStats();\n            throw new Error(`Cannot send batch: circuit breaker is open after ${stats.consecutiveFailures} consecutive failures. Will retry automatically.`);\n        }\n        try {\n            const result = await sendFn(entries);\n            cb.reset();\n            return result;\n        }\n        catch (err) {\n            cb.recordFailure();\n            throw err;\n        }\n    }\n    let pending = [];\n    let timeoutId = null;\n    async function flushWithCircuitBreaker() {\n        if (pending.length === 0)\n            return;\n        const entries = pending;\n        pending = [];\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n        const currentState = cb.getState();\n        if (currentState === 'open') {\n            pending = entries.concat(pending).slice(0, MAX_PENDING_BUFFER);\n            return;\n        }\n        try {\n            await attemptSend(entries);\n            localConnectionStatus.connected = true;\n        }\n        catch {\n            localConnectionStatus.connected = false;\n            if (cb.getState() === 'open') {\n                pending = entries.concat(pending).slice(0, MAX_PENDING_BUFFER);\n                return;\n            }\n            let retriesLeft = retryBudget - 1;\n            while (retriesLeft > 0) {\n                retriesLeft--;\n                const stats = cb.getStats();\n                const backoff = getScheduledBackoff(stats.consecutiveFailures);\n                if (backoff > 0) {\n                    await new Promise((r) => {\n                        setTimeout(r, backoff);\n                    });\n                }\n                try {\n                    await attemptSend(entries);\n                    localConnectionStatus.connected = true;\n                    return;\n                }\n                catch {\n                    localConnectionStatus.connected = false;\n                    if (cb.getState() === 'open') {\n                        pending = entries.concat(pending).slice(0, MAX_PENDING_BUFFER);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n    const scheduleFlush = () => {\n        if (timeoutId)\n            return;\n        timeoutId = setTimeout(() => {\n            timeoutId = null;\n            flushWithCircuitBreaker();\n        }, debounceMs);\n    };\n    const batcher = {\n        add(entry) {\n            if (pending.length >= MAX_PENDING_BUFFER)\n                return;\n            pending.push(entry);\n            if (pending.length >= maxBatchSize) {\n                flushWithCircuitBreaker();\n            }\n            else {\n                scheduleFlush();\n            }\n        },\n        async flush() {\n            await flushWithCircuitBreaker();\n        },\n        clear() {\n            pending = [];\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n        },\n        getPending() {\n            return [...pending];\n        },\n    };\n    return {\n        batcher,\n        circuitBreaker: wrappedCircuitBreaker,\n        getConnectionStatus: () => ({ ...localConnectionStatus }),\n    };\n}\n/**\n * Create a simple log batcher without circuit breaker\n */\nexport function createLogBatcher(flushFn, options = {}) {\n    const debounceMs = options.debounceMs ?? DEFAULT_DEBOUNCE_MS;\n    const maxBatchSize = options.maxBatchSize ?? DEFAULT_MAX_BATCH_SIZE;\n    const memoryPressureGetter = options.memoryPressureGetter ?? null;\n    let pending = [];\n    let timeoutId = null;\n    const getEffectiveMaxBatchSize = () => {\n        if (memoryPressureGetter) {\n            const state = memoryPressureGetter();\n            if (state.reducedCapacities) {\n                return Math.floor(maxBatchSize / 2);\n            }\n        }\n        return maxBatchSize;\n    };\n    const flush = () => {\n        if (pending.length === 0)\n            return;\n        const entries = pending;\n        pending = [];\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n            timeoutId = null;\n        }\n        flushFn(entries);\n    };\n    const scheduleFlush = () => {\n        if (timeoutId)\n            return;\n        timeoutId = setTimeout(() => {\n            timeoutId = null;\n            flush();\n        }, debounceMs);\n    };\n    return {\n        add(entry) {\n            if (pending.length >= MAX_PENDING_BUFFER)\n                return;\n            pending.push(entry);\n            const effectiveMax = getEffectiveMaxBatchSize();\n            if (pending.length >= effectiveMax) {\n                flush();\n            }\n            else {\n                scheduleFlush();\n            }\n        },\n        flush() {\n            flush();\n        },\n        clear() {\n            pending = [];\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                timeoutId = null;\n            }\n        },\n    };\n}\n//# sourceMappingURL=batchers.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/cache-limits.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/circuit-breaker.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/communication.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/connection-state.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/debug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/dom-primitives.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":330,"column":28,"nodeType":"MemberExpression","endLine":330,"endColumn":39},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":494,"column":38,"nodeType":"CallExpression","messageId":"returnsValue","endLine":494,"endColumn":75,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[22793,22830],"text":"{setTimeout(r, MIN_TOAST_MS - elapsed)}"},"desc":"Wrap the expression in `{}`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// dom-primitives.ts — Pre-compiled DOM interaction functions for chrome.scripting.executeScript.\n// These bypass CSP restrictions because they use the `func` parameter (no eval/new Function).\n// Each function MUST be self-contained — no closures over external variables.\n/**\n * Single self-contained function for all DOM primitives.\n * Passed to chrome.scripting.executeScript({ func: domPrimitive, args: [...] }).\n * MUST NOT reference any module-level variables — Chrome serializes the function source only.\n */\nexport function domPrimitive(action, selector, options) {\n    // ---------------------------------------------------------------\n    // Selector resolver: CSS or semantic (text=, role=, placeholder=, label=, aria-label=)\n    // All semantic selectors prefer visible elements over hidden ones.\n    // ---------------------------------------------------------------\n    // Visibility check: skip display:none, visibility:hidden, zero-size elements\n    function isVisible(el) {\n        if (!(el instanceof HTMLElement))\n            return true;\n        if (el.offsetParent === null && el.style.position !== 'fixed' && el.style.position !== 'sticky')\n            return false;\n        const style = getComputedStyle(el);\n        if (style.visibility === 'hidden' || style.display === 'none')\n            return false;\n        return true;\n    }\n    // Return first visible match from a NodeList, falling back to first match\n    function firstVisible(els) {\n        let fallback = null;\n        for (const el of els) {\n            if (!fallback)\n                fallback = el;\n            if (isVisible(el))\n                return el;\n        }\n        return fallback;\n    }\n    function resolveElement(sel) {\n        if (!sel)\n            return null;\n        // text=Submit → find visible element whose textContent contains the text\n        if (sel.startsWith('text=')) {\n            const searchText = sel.slice(5);\n            const walker = document.createTreeWalker(document.body || document.documentElement, NodeFilter.SHOW_TEXT);\n            let fallback = null;\n            while (walker.nextNode()) {\n                const node = walker.currentNode;\n                if (node.textContent && node.textContent.trim().includes(searchText)) {\n                    const parent = node.parentElement;\n                    if (!parent)\n                        continue;\n                    const interactive = parent.closest('a, button, [role=\"button\"], [role=\"link\"], label, summary');\n                    const target = interactive || parent;\n                    if (!fallback)\n                        fallback = target;\n                    if (isVisible(target))\n                        return target;\n                }\n            }\n            return fallback;\n        }\n        // role=button → [role=\"button\"], prefer visible\n        if (sel.startsWith('role=')) {\n            const role = sel.slice(5);\n            return firstVisible(document.querySelectorAll(`[role=\"${role}\"]`));\n        }\n        // placeholder=Email → [placeholder=\"Email\"], prefer visible\n        if (sel.startsWith('placeholder=')) {\n            const ph = sel.slice(12);\n            return firstVisible(document.querySelectorAll(`[placeholder=\"${ph}\"]`));\n        }\n        // label=Email → find label, follow `for` attribute\n        if (sel.startsWith('label=')) {\n            const labelText = sel.slice(6);\n            const labels = document.querySelectorAll('label');\n            for (const label of labels) {\n                if (label.textContent && label.textContent.trim().includes(labelText)) {\n                    const forAttr = label.getAttribute('for');\n                    if (forAttr) {\n                        const target = document.getElementById(forAttr);\n                        if (target)\n                            return target;\n                    }\n                    const nested = label.querySelector('input, select, textarea');\n                    if (nested)\n                        return nested;\n                    return label;\n                }\n            }\n            return null;\n        }\n        // aria-label=Close → starts-with match, prefer visible\n        // Handles cases like Gmail's \"Send ‪(⌘Enter)‬\" matching \"aria-label=Send\"\n        if (sel.startsWith('aria-label=')) {\n            const al = sel.slice(11);\n            // Try exact match first\n            const exact = document.querySelectorAll(`[aria-label=\"${al}\"]`);\n            if (exact.length > 0)\n                return firstVisible(exact);\n            // Starts-with match: find all [aria-label] and check prefix\n            const all = document.querySelectorAll('[aria-label]');\n            let fallback = null;\n            for (const el of all) {\n                const label = el.getAttribute('aria-label') || '';\n                if (label.startsWith(al)) {\n                    if (!fallback)\n                        fallback = el;\n                    if (isVisible(el))\n                        return el;\n                }\n            }\n            return fallback;\n        }\n        // Default: CSS selector\n        return document.querySelector(sel);\n    }\n    // ---------------------------------------------------------------\n    // list_interactive: scan the page for interactive elements\n    // ---------------------------------------------------------------\n    if (action === 'list_interactive') {\n        const interactiveSelectors = [\n            'a[href]',\n            'button',\n            'input',\n            'select',\n            'textarea',\n            '[role=\"button\"]',\n            '[role=\"link\"]',\n            '[role=\"tab\"]',\n            '[role=\"menuitem\"]',\n            '[contenteditable=\"true\"]',\n            '[onclick]',\n            '[tabindex]',\n        ];\n        const seen = new Set();\n        const elements = [];\n        for (const cssSelector of interactiveSelectors) {\n            const matches = document.querySelectorAll(cssSelector);\n            for (const el of matches) {\n                if (seen.has(el))\n                    continue;\n                seen.add(el);\n                const htmlEl = el;\n                const rect = htmlEl.getBoundingClientRect();\n                const visible = rect.width > 0 && rect.height > 0 && htmlEl.offsetParent !== null;\n                // Build a unique selector for this element\n                let uniqueSelector = '';\n                if (el.id) {\n                    uniqueSelector = `#${el.id}`;\n                }\n                else if (el instanceof HTMLInputElement && el.name) {\n                    uniqueSelector = `input[name=\"${el.name}\"]`;\n                }\n                else {\n                    // Use aria-label, placeholder, or text content as selector hint\n                    const ariaLabel = el.getAttribute('aria-label');\n                    const placeholder = el.getAttribute('placeholder');\n                    if (ariaLabel) {\n                        uniqueSelector = `aria-label=${ariaLabel}`;\n                    }\n                    else if (placeholder) {\n                        uniqueSelector = `placeholder=${placeholder}`;\n                    }\n                    else {\n                        const text = (htmlEl.textContent || '').trim().slice(0, 40);\n                        if (text) {\n                            uniqueSelector = `text=${text}`;\n                        }\n                        else {\n                            uniqueSelector = cssSelector;\n                        }\n                    }\n                }\n                // Build human-readable label\n                const label = el.getAttribute('aria-label') ||\n                    el.getAttribute('title') ||\n                    el.getAttribute('placeholder') ||\n                    (htmlEl.textContent || '').trim().slice(0, 60) ||\n                    el.tagName.toLowerCase();\n                elements.push({\n                    tag: el.tagName.toLowerCase(),\n                    type: el instanceof HTMLInputElement ? el.type : undefined,\n                    selector: uniqueSelector,\n                    label,\n                    role: el.getAttribute('role') || undefined,\n                    placeholder: el.getAttribute('placeholder') || undefined,\n                    visible,\n                });\n                if (elements.length >= 100)\n                    break; // Cap at 100 elements\n            }\n            if (elements.length >= 100)\n                break;\n        }\n        return { success: true, elements };\n    }\n    // ---------------------------------------------------------------\n    // Resolve element for all other actions\n    // ---------------------------------------------------------------\n    const el = resolveElement(selector);\n    if (!el) {\n        return {\n            success: false,\n            action,\n            selector,\n            error: 'element_not_found',\n            message: `No element matches selector: ${selector}`,\n        };\n    }\n    // ---------------------------------------------------------------\n    // Action dispatch\n    // ---------------------------------------------------------------\n    switch (action) {\n        case 'click': {\n            if (!(el instanceof HTMLElement)) {\n                return { success: false, action, selector, error: 'not_interactive', message: `Element is not an HTMLElement: ${el.tagName}` };\n            }\n            el.click();\n            return { success: true, action, selector };\n        }\n        case 'type': {\n            const text = options.text || '';\n            // Contenteditable elements (Gmail compose body, rich text editors)\n            // Use execCommand('insertText') — fires beforeinput/input events properly,\n            // integrates with undo/redo, and works with Gmail's editor framework.\n            if (el instanceof HTMLElement && el.isContentEditable) {\n                el.focus();\n                if (options.clear) {\n                    // Select all then replace\n                    const selection = document.getSelection();\n                    if (selection) {\n                        selection.selectAllChildren(el);\n                        selection.deleteFromDocument();\n                    }\n                }\n                document.execCommand('insertText', false, text);\n                return { success: true, action, selector, value: el.textContent };\n            }\n            if (!(el instanceof HTMLInputElement) && !(el instanceof HTMLTextAreaElement)) {\n                return { success: false, action, selector, error: 'not_typeable', message: `Element is not an input, textarea, or contenteditable: ${el.tagName}` };\n            }\n            // Use native prototype setter to trigger React/Vue/Angular state updates\n            const proto = el instanceof HTMLTextAreaElement ? HTMLTextAreaElement : HTMLInputElement;\n            const nativeSetter = Object.getOwnPropertyDescriptor(proto.prototype, 'value')?.set;\n            if (nativeSetter) {\n                const newValue = options.clear ? text : el.value + text;\n                nativeSetter.call(el, newValue);\n            }\n            else {\n                el.value = options.clear ? text : el.value + text;\n            }\n            el.dispatchEvent(new InputEvent('input', { bubbles: true, data: text, inputType: 'insertText' }));\n            el.dispatchEvent(new Event('change', { bubbles: true }));\n            return { success: true, action, selector, value: el.value };\n        }\n        case 'select': {\n            if (!(el instanceof HTMLSelectElement)) {\n                return { success: false, action, selector, error: 'not_select', message: `Element is not a <select>: ${el.tagName}` };\n            }\n            const nativeSelectSetter = Object.getOwnPropertyDescriptor(HTMLSelectElement.prototype, 'value')?.set;\n            if (nativeSelectSetter) {\n                nativeSelectSetter.call(el, options.value || '');\n            }\n            else {\n                el.value = options.value || '';\n            }\n            el.dispatchEvent(new Event('change', { bubbles: true }));\n            return { success: true, action, selector, value: el.value };\n        }\n        case 'check': {\n            if (!(el instanceof HTMLInputElement) || (el.type !== 'checkbox' && el.type !== 'radio')) {\n                return {\n                    success: false,\n                    action,\n                    selector,\n                    error: 'not_checkable',\n                    message: `Element is not a checkbox or radio: ${el.tagName} type=${el.type || 'N/A'}`,\n                };\n            }\n            const desired = options.checked !== undefined ? options.checked : true;\n            // Use .click() for React compatibility — toggles checked and fires all events\n            if (el.checked !== desired) {\n                el.click();\n            }\n            return { success: true, action, selector, value: el.checked };\n        }\n        case 'get_text': {\n            return { success: true, action, selector, value: el.textContent };\n        }\n        case 'get_value': {\n            if (!('value' in el)) {\n                return { success: false, action, selector, error: 'no_value_property', message: `Element has no value property: ${el.tagName}` };\n            }\n            return { success: true, action, selector, value: el.value };\n        }\n        case 'get_attribute': {\n            return { success: true, action, selector, value: el.getAttribute(options.name || '') };\n        }\n        case 'set_attribute': {\n            el.setAttribute(options.name || '', options.value || '');\n            return { success: true, action, selector, value: el.getAttribute(options.name || '') };\n        }\n        case 'focus': {\n            if (!(el instanceof HTMLElement)) {\n                return { success: false, action, selector, error: 'not_focusable', message: `Element is not an HTMLElement: ${el.tagName}` };\n            }\n            el.focus();\n            return { success: true, action, selector };\n        }\n        case 'scroll_to': {\n            el.scrollIntoView({ behavior: 'smooth', block: 'center' });\n            return { success: true, action, selector };\n        }\n        case 'wait_for': {\n            // Already found — return immediately\n            return { success: true, action, selector, value: el.tagName.toLowerCase() };\n        }\n        case 'key_press': {\n            if (!(el instanceof HTMLElement)) {\n                return { success: false, action, selector, error: 'not_interactive', message: `Element is not an HTMLElement: ${el.tagName}` };\n            }\n            const key = options.text || 'Enter';\n            const keyMap = {\n                Enter: { key: 'Enter', code: 'Enter', keyCode: 13 },\n                Tab: { key: 'Tab', code: 'Tab', keyCode: 9 },\n                Escape: { key: 'Escape', code: 'Escape', keyCode: 27 },\n                Backspace: { key: 'Backspace', code: 'Backspace', keyCode: 8 },\n                ArrowDown: { key: 'ArrowDown', code: 'ArrowDown', keyCode: 40 },\n                ArrowUp: { key: 'ArrowUp', code: 'ArrowUp', keyCode: 38 },\n                Space: { key: ' ', code: 'Space', keyCode: 32 },\n            };\n            const mapped = keyMap[key] || { key, code: key, keyCode: 0 };\n            el.dispatchEvent(new KeyboardEvent('keydown', { key: mapped.key, code: mapped.code, keyCode: mapped.keyCode, bubbles: true }));\n            el.dispatchEvent(new KeyboardEvent('keypress', { key: mapped.key, code: mapped.code, keyCode: mapped.keyCode, bubbles: true }));\n            el.dispatchEvent(new KeyboardEvent('keyup', { key: mapped.key, code: mapped.code, keyCode: mapped.keyCode, bubbles: true }));\n            return { success: true, action, selector, value: key };\n        }\n        default:\n            return { success: false, action, selector, error: 'unknown_action', message: `Unknown DOM action: ${action}` };\n    }\n}\n/**\n * wait_for variant that polls with MutationObserver (used when element not found initially).\n * Separate function because it returns a Promise.\n */\nexport function domWaitFor(selector, timeoutMs) {\n    // ---------------------------------------------------------------\n    // Inline selector resolver (must be self-contained for chrome.scripting)\n    // ---------------------------------------------------------------\n    function resolveElement(sel) {\n        if (!sel)\n            return null;\n        if (sel.startsWith('text=')) {\n            const searchText = sel.slice(5);\n            const walker = document.createTreeWalker(document.body || document.documentElement, NodeFilter.SHOW_TEXT);\n            while (walker.nextNode()) {\n                const node = walker.currentNode;\n                if (node.textContent && node.textContent.trim().includes(searchText)) {\n                    const parent = node.parentElement;\n                    if (!parent)\n                        continue;\n                    return parent.closest('a, button, [role=\"button\"], [role=\"link\"], label, summary') || parent;\n                }\n            }\n            return null;\n        }\n        if (sel.startsWith('role='))\n            return document.querySelector(`[role=\"${sel.slice(5)}\"]`);\n        if (sel.startsWith('placeholder='))\n            return document.querySelector(`[placeholder=\"${sel.slice(12)}\"]`);\n        if (sel.startsWith('aria-label='))\n            return document.querySelector(`[aria-label=\"${sel.slice(11)}\"]`);\n        if (sel.startsWith('label=')) {\n            const labelText = sel.slice(6);\n            for (const label of document.querySelectorAll('label')) {\n                if (label.textContent && label.textContent.trim().includes(labelText)) {\n                    const forAttr = label.getAttribute('for');\n                    if (forAttr) {\n                        const t = document.getElementById(forAttr);\n                        if (t)\n                            return t;\n                    }\n                    return label.querySelector('input, select, textarea') || label;\n                }\n            }\n            return null;\n        }\n        return document.querySelector(sel);\n    }\n    return new Promise((resolve) => {\n        // Check immediately\n        const existing = resolveElement(selector);\n        if (existing) {\n            resolve({ success: true, action: 'wait_for', selector, value: existing.tagName.toLowerCase() });\n            return;\n        }\n        let resolved = false;\n        const timer = setTimeout(() => {\n            if (!resolved) {\n                resolved = true;\n                observer.disconnect();\n                resolve({\n                    success: false,\n                    action: 'wait_for',\n                    selector,\n                    error: 'timeout',\n                    message: `Element not found within ${timeoutMs}ms: ${selector}`,\n                });\n            }\n        }, timeoutMs);\n        const observer = new MutationObserver(() => {\n            const el = resolveElement(selector);\n            if (el && !resolved) {\n                resolved = true;\n                clearTimeout(timer);\n                observer.disconnect();\n                resolve({ success: true, action: 'wait_for', selector, value: el.tagName.toLowerCase() });\n            }\n        });\n        observer.observe(document.documentElement, { childList: true, subtree: true });\n    });\n}\n// =============================================================================\n// Dispatcher: routes dom_action queries to pre-compiled functions\n// =============================================================================\nexport async function executeDOMAction(query, tabId, syncClient, sendAsyncResult, actionToast) {\n    let params;\n    try {\n        params = typeof query.params === 'string' ? JSON.parse(query.params) : query.params;\n    }\n    catch {\n        sendAsyncResult(syncClient, query.id, query.correlation_id, 'error', null, 'invalid_params');\n        return;\n    }\n    const { action, selector, reason } = params;\n    if (!action) {\n        sendAsyncResult(syncClient, query.id, query.correlation_id, 'error', null, 'missing_action');\n        return;\n    }\n    // Toast detail: show reason if provided, otherwise selector\n    const toastDetail = reason || selector || 'page';\n    try {\n        let results;\n        if (action === 'wait_for' && !selector) {\n            sendAsyncResult(syncClient, query.id, query.correlation_id, 'error', null, 'missing_selector');\n            return;\n        }\n        // Show \"trying\" toast (skipped for list_interactive and read-only gets)\n        const readOnly = action === 'list_interactive' || action.startsWith('get_');\n        const tryingShownAt = Date.now();\n        if (!readOnly) {\n            actionToast(tabId, action, toastDetail, 'trying', 10000);\n        }\n        // For wait_for: check if element exists first with domPrimitive.\n        // If not found, use the async domWaitFor with MutationObserver.\n        if (action === 'wait_for') {\n            const quickCheck = await chrome.scripting.executeScript({\n                target: { tabId },\n                world: 'MAIN',\n                func: domPrimitive,\n                args: [action, selector || '', { timeout_ms: params.timeout_ms }],\n            });\n            const quickResult = quickCheck?.[0]?.result;\n            if (quickResult && quickResult.success) {\n                actionToast(tabId, 'wait_for', toastDetail, 'success');\n                sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', quickResult);\n                return;\n            }\n            // Element not found — use async MutationObserver version\n            results = await chrome.scripting.executeScript({\n                target: { tabId },\n                world: 'MAIN',\n                func: domWaitFor,\n                args: [selector || '', params.timeout_ms || 5000],\n            });\n        }\n        else {\n            results = await chrome.scripting.executeScript({\n                target: { tabId },\n                world: 'MAIN',\n                func: domPrimitive,\n                args: [action, selector || '', {\n                        text: params.text,\n                        value: params.value,\n                        clear: params.clear,\n                        checked: params.checked,\n                        name: params.name,\n                        timeout_ms: params.timeout_ms,\n                    }],\n            });\n        }\n        // Ensure the \"trying\" toast is visible for at least 500ms before replacing\n        const MIN_TOAST_MS = 500;\n        const elapsed = Date.now() - tryingShownAt;\n        if (!readOnly && elapsed < MIN_TOAST_MS) {\n            await new Promise((r) => setTimeout(r, MIN_TOAST_MS - elapsed));\n        }\n        const firstResult = results?.[0]?.result;\n        if (firstResult && typeof firstResult === 'object') {\n            const result = firstResult;\n            if (!readOnly) {\n                if (result.success) {\n                    actionToast(tabId, action, toastDetail, 'success');\n                }\n                else {\n                    actionToast(tabId, action, result.error || 'failed', 'error');\n                }\n            }\n            sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', firstResult);\n        }\n        else {\n            if (!readOnly) {\n                actionToast(tabId, action, 'no result', 'error');\n            }\n            sendAsyncResult(syncClient, query.id, query.correlation_id, 'error', null, 'no_result');\n        }\n    }\n    catch (err) {\n        actionToast(tabId, action, err.message, 'error');\n        sendAsyncResult(syncClient, query.id, query.correlation_id, 'error', null, err.message);\n    }\n}\n//# sourceMappingURL=dom-primitives.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/error-groups.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/event-listeners.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":143,"column":9,"nodeType":"MemberExpression","endLine":143,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":147,"column":17,"nodeType":"MemberExpression","endLine":147,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Event Listeners - Handles Chrome alarms, tab listeners,\n * storage change listeners, and other Chrome extension events.\n */\n// =============================================================================\n// CONSTANTS - Rate Limiting & DoS Protection\n// =============================================================================\n/**\n * Reconnect interval: 5 seconds\n * DoS Protection: If MCP server is down, we check every 5s (circuit breaker\n * will back off exponentially if failures continue).\n * Ensures connection restored quickly when server comes back up.\n */\nconst RECONNECT_INTERVAL_MINUTES = 5 / 60; // 5 seconds in minutes\n/**\n * Error group flush interval: 30 seconds\n * DoS Protection: Deduplicates identical errors within a 5-second window\n * before sending to server. Reduces network traffic and API quota usage.\n * Flushed every 30 seconds to keep errors reasonably fresh.\n */\nconst ERROR_GROUP_FLUSH_INTERVAL_MINUTES = 0.5; // 30 seconds\n/**\n * Memory check interval: 30 seconds\n * DoS Protection: Monitors estimated buffer memory and triggers circuit breaker\n * if soft limit (20MB) or hard limit (50MB) is exceeded.\n * Prevents memory exhaustion from unbounded capture buffer growth.\n */\nconst MEMORY_CHECK_INTERVAL_MINUTES = 0.5; // 30 seconds\n/**\n * Error group cleanup interval: 10 minutes\n * DoS Protection: Removes stale error group deduplication state that is >5min old.\n * Prevents unbounded growth of error group metadata.\n */\nconst ERROR_GROUP_CLEANUP_INTERVAL_MINUTES = 10;\n// =============================================================================\n// ALARM NAMES\n// =============================================================================\nexport const ALARM_NAMES = {\n    RECONNECT: 'reconnect',\n    ERROR_GROUP_FLUSH: 'errorGroupFlush',\n    MEMORY_CHECK: 'memoryCheck',\n    ERROR_GROUP_CLEANUP: 'errorGroupCleanup',\n};\n// =============================================================================\n// CHROME ALARMS\n// =============================================================================\n/**\n * Setup Chrome alarms for periodic tasks\n *\n * RATE LIMITING & DoS PROTECTION:\n * 1. RECONNECT (5s): Maintains MCP connection with exponential backoff\n * 2. ERROR_GROUP_FLUSH (30s): Deduplicates errors, reduces server load\n * 3. MEMORY_CHECK (30s): Monitors buffer memory, prevents exhaustion\n * 4. ERROR_GROUP_CLEANUP (10min): Removes stale deduplication state\n *\n * Note: Alarms are re-created on service worker startup (not persistent)\n * If service worker restarts, alarms must be recreated by this function\n */\nexport function setupChromeAlarms() {\n    if (typeof chrome === 'undefined' || !chrome.alarms)\n        return;\n    chrome.alarms.create(ALARM_NAMES.RECONNECT, { periodInMinutes: RECONNECT_INTERVAL_MINUTES });\n    chrome.alarms.create(ALARM_NAMES.ERROR_GROUP_FLUSH, { periodInMinutes: ERROR_GROUP_FLUSH_INTERVAL_MINUTES });\n    chrome.alarms.create(ALARM_NAMES.MEMORY_CHECK, { periodInMinutes: MEMORY_CHECK_INTERVAL_MINUTES });\n    chrome.alarms.create(ALARM_NAMES.ERROR_GROUP_CLEANUP, { periodInMinutes: ERROR_GROUP_CLEANUP_INTERVAL_MINUTES });\n}\n/**\n * Install Chrome alarm listener\n */\nexport function installAlarmListener(handlers) {\n    if (typeof chrome === 'undefined' || !chrome.alarms)\n        return;\n    chrome.alarms.onAlarm.addListener((alarm) => {\n        switch (alarm.name) {\n            case ALARM_NAMES.RECONNECT:\n                handlers.onReconnect();\n                break;\n            case ALARM_NAMES.ERROR_GROUP_FLUSH:\n                handlers.onErrorGroupFlush();\n                break;\n            case ALARM_NAMES.MEMORY_CHECK:\n                handlers.onMemoryCheck();\n                break;\n            case ALARM_NAMES.ERROR_GROUP_CLEANUP:\n                handlers.onErrorGroupCleanup();\n                break;\n        }\n    });\n}\n// =============================================================================\n// TAB LISTENERS\n// =============================================================================\n/**\n * Install tab removed listener\n */\nexport function installTabRemovedListener(onTabRemoved) {\n    if (typeof chrome === 'undefined' || !chrome.tabs || !chrome.tabs.onRemoved)\n        return;\n    chrome.tabs.onRemoved.addListener((tabId) => {\n        onTabRemoved(tabId);\n    });\n}\n/**\n * Install tab updated listener to track URL changes\n */\nexport function installTabUpdatedListener(onTabUpdated) {\n    if (typeof chrome === 'undefined' || !chrome.tabs || !chrome.tabs.onUpdated)\n        return;\n    chrome.tabs.onUpdated.addListener((tabId, changeInfo) => {\n        // Only care about URL changes\n        if (changeInfo.url) {\n            onTabUpdated(tabId, changeInfo.url);\n        }\n    });\n}\n/**\n * Handle tracked tab URL change\n * Updates the stored URL when the tracked tab navigates\n */\nexport function handleTrackedTabUrlChange(updatedTabId, newUrl, logFn) {\n    if (typeof chrome === 'undefined' || !chrome.storage)\n        return;\n    chrome.storage.local.get(['trackedTabId'], (result) => {\n        if (result.trackedTabId === updatedTabId) {\n            chrome.storage.local.set({ trackedTabUrl: newUrl }, () => {\n                if (logFn) {\n                    logFn('[Gasoline] Tracked tab URL updated: ' + newUrl);\n                }\n            });\n        }\n    });\n}\n/**\n * Handle tracked tab being closed\n * SECURITY: Clears ephemeral tracking state when tab closes\n * Uses session storage for ephemeral tab tracking data\n */\nexport function handleTrackedTabClosed(closedTabId, logFn) {\n    if (typeof chrome === 'undefined' || !chrome.storage)\n        return;\n    // Check both session and local storage for backward compatibility\n    const checkStorageArea = (area) => {\n        chrome.storage[area].get(['trackedTabId'], (result) => {\n            if (result.trackedTabId === closedTabId) {\n                if (logFn)\n                    logFn('[Gasoline] Tracked tab closed (id:', closedTabId);\n                chrome.storage[area].remove(['trackedTabId', 'trackedTabUrl']);\n            }\n        });\n    };\n    // Check local storage (legacy)\n    checkStorageArea('local');\n    // Check session storage (modern, Chrome 102+)\n    // Type-safe check: cast to Record to access potential session property\n    const storageWithSession = chrome.storage;\n    if (storageWithSession.session) {\n        checkStorageArea('session');\n    }\n}\n// =============================================================================\n// STORAGE LISTENERS\n// =============================================================================\n/**\n * Install storage change listener\n */\nexport function installStorageChangeListener(handlers) {\n    if (typeof chrome === 'undefined' || !chrome.storage)\n        return;\n    chrome.storage.onChanged.addListener((changes, areaName) => {\n        if (areaName === 'local') {\n            if (changes.aiWebPilotEnabled && handlers.onAiWebPilotChanged) {\n                handlers.onAiWebPilotChanged(changes.aiWebPilotEnabled.newValue === true);\n            }\n            if (changes.trackedTabId && handlers.onTrackedTabChanged) {\n                const newTabId = changes.trackedTabId.newValue ?? null;\n                const oldTabId = changes.trackedTabId.oldValue ?? null;\n                handlers.onTrackedTabChanged(newTabId, oldTabId);\n            }\n        }\n    });\n}\n// =============================================================================\n// RUNTIME LISTENERS\n// =============================================================================\n/**\n * Install browser startup listener (clears tracking state)\n */\nexport function installStartupListener(logFn) {\n    if (typeof chrome === 'undefined' || !chrome.runtime || !chrome.runtime.onStartup)\n        return;\n    chrome.runtime.onStartup.addListener(() => {\n        if (logFn)\n            logFn('[Gasoline] Browser restarted - clearing tracking state');\n        chrome.storage.local.remove(['trackedTabId', 'trackedTabUrl']);\n    });\n}\n// =============================================================================\n// CONTENT SCRIPT HELPERS\n// =============================================================================\n/**\n * Ping content script to check if it's loaded\n */\nexport async function pingContentScript(tabId, timeoutMs = 500) {\n    try {\n        const response = (await Promise.race([\n            chrome.tabs.sendMessage(tabId, { type: 'GASOLINE_PING' }),\n            new Promise((_, reject) => {\n                setTimeout(() => reject(new Error(`Content script ping timeout after ${timeoutMs}ms on tab ${tabId}`)), timeoutMs);\n            }),\n        ]));\n        return response?.status === 'alive';\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Wait for tab to finish loading\n */\nexport async function waitForTabLoad(tabId, timeoutMs = 5000) {\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeoutMs) {\n        try {\n            const tab = await chrome.tabs.get(tabId);\n            if (tab.status === 'complete')\n                return true;\n        }\n        catch {\n            return false;\n        }\n        await new Promise((r) => {\n            setTimeout(r, 100);\n        });\n    }\n    return false;\n}\n/**\n * Forward a message to all content scripts\n */\nexport function forwardToAllContentScripts(message, debugLogFn) {\n    if (typeof chrome === 'undefined' || !chrome.tabs)\n        return;\n    chrome.tabs.query({}, (tabs) => {\n        for (const tab of tabs) {\n            if (tab.id) {\n                chrome.tabs.sendMessage(tab.id, message).catch((err) => {\n                    if (!err.message?.includes('Receiving end does not exist') &&\n                        !err.message?.includes('Could not establish connection')) {\n                        if (debugLogFn) {\n                            debugLogFn('error', 'Unexpected error forwarding setting to tab', {\n                                tabId: tab.id,\n                                error: err.message,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n    });\n}\n// =============================================================================\n// SETTINGS LOADING\n// =============================================================================\n/**\n * Load saved settings from chrome.storage.local\n */\nexport function loadSavedSettings(callback) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        callback({});\n        return;\n    }\n    chrome.storage.local.get(['serverUrl', 'logLevel', 'screenshotOnError', 'sourceMapEnabled', 'debugMode'], (result) => {\n        if (chrome.runtime.lastError) {\n            console.warn('[Gasoline] Could not load saved settings:', chrome.runtime.lastError.message, '- using defaults');\n            callback({});\n            return;\n        }\n        callback(result);\n    });\n}\n/**\n * Load AI Web Pilot enabled state from storage\n */\nexport function loadAiWebPilotState(callback, logFn) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        callback(false);\n        return;\n    }\n    const startTime = performance.now();\n    chrome.storage.local.get(['aiWebPilotEnabled'], (result) => {\n        const wasLoaded = result.aiWebPilotEnabled !== false;\n        const loadTime = performance.now() - startTime;\n        if (logFn) {\n            logFn(`[Gasoline] AI Web Pilot loaded on startup: ${wasLoaded} (took ${loadTime.toFixed(1)}ms)`);\n        }\n        callback(wasLoaded);\n    });\n}\n/**\n * Load debug mode state from storage\n */\nexport function loadDebugModeState(callback) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        callback(false);\n        return;\n    }\n    chrome.storage.local.get(['debugMode'], (result) => {\n        callback(result.debugMode === true);\n    });\n}\n/**\n * Save setting to chrome.storage.local\n */\nexport function saveSetting(key, value) {\n    if (typeof chrome === 'undefined' || !chrome.storage)\n        return;\n    chrome.storage.local.set({ [key]: value });\n}\n// Implementation\nexport function getTrackedTabInfo(callback) {\n    if (!callback) {\n        // Promise-based version\n        return new Promise((resolve) => {\n            getTrackedTabInfo((info) => resolve(info));\n        });\n    }\n    // Callback-based version\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        callback({ trackedTabId: null, trackedTabUrl: null, trackedTabTitle: null });\n        return;\n    }\n    chrome.storage.local.get(['trackedTabId', 'trackedTabUrl', 'trackedTabTitle'], (result) => {\n        callback({\n            trackedTabId: result.trackedTabId || null,\n            trackedTabUrl: result.trackedTabUrl || null,\n            trackedTabTitle: result.trackedTabTitle || null,\n        });\n    });\n}\n/**\n * Clear tracked tab state\n */\nexport function clearTrackedTab() {\n    if (typeof chrome === 'undefined' || !chrome.storage)\n        return;\n    chrome.storage.local.remove(['trackedTabId', 'trackedTabUrl', 'trackedTabTitle']);\n}\n// Implementation\nexport function getAllConfigSettings(callback) {\n    if (!callback) {\n        // Promise-based version\n        return new Promise((resolve) => {\n            getAllConfigSettings((settings) => resolve(settings));\n        });\n    }\n    // Callback-based version\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        callback({});\n        return;\n    }\n    chrome.storage.local.get([\n        'aiWebPilotEnabled',\n        'webSocketCaptureEnabled',\n        'networkWaterfallEnabled',\n        'performanceMarksEnabled',\n        'actionReplayEnabled',\n        'screenshotOnError',\n        'sourceMapEnabled',\n        'networkBodyCaptureEnabled',\n    ], (result) => {\n        callback(result);\n    });\n}\n//# sourceMappingURL=event-listeners.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/icon-manager.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":84,"column":19,"nodeType":"MemberExpression","endLine":84,"endColumn":39,"suppressions":[{"kind":"directive","justification":"Safe: currentFrame is bounded by animation frame modulo"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/index.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/init.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/message-handlers.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'validateMessageType' is defined but never used. Allowed unused vars must match /^_/u.","line":47,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":47,"endColumn":29,"suggestions":[{"messageId":"removeVar","data":{"varName":"validateMessageType"},"fix":{"range":[1880,2339],"text":""},"desc":"Remove unused variable 'validateMessageType'."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":332,"column":31,"nodeType":"MemberExpression","endLine":332,"endColumn":51},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":334,"column":13,"nodeType":"MemberExpression","endLine":334,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":355,"column":31,"nodeType":"MemberExpression","endLine":355,"endColumn":51},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":356,"column":21,"nodeType":"MemberExpression","endLine":356,"endColumn":36},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":366,"column":31,"nodeType":"MemberExpression","endLine":366,"endColumn":51},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":383,"column":31,"nodeType":"MemberExpression","endLine":383,"endColumn":51},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":384,"column":20,"nodeType":"MemberExpression","endLine":384,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Message Handlers - Handles all chrome.runtime.onMessage routing\n * with type-safe message discrimination.\n */\n// =============================================================================\n// MESSAGE HANDLER\n// =============================================================================\n/**\n * Security: Validate that sender is from extension or content script\n * Prevents messages from untrusted sources\n */\nfunction isValidMessageSender(sender) {\n    // Content scripts have sender.tab with tabId and url\n    // Background/popup scripts have sender.id === chrome.runtime.id\n    // Extension pages (popup, options) have sender.tab?.url starting with 'chrome-extension://'\n    if (sender.tab?.id !== undefined && sender.tab?.url) {\n        // Content script: has tab context\n        return true;\n    }\n    if (typeof chrome !== 'undefined' && chrome.runtime && sender.id === chrome.runtime.id) {\n        // Internal extension message\n        return true;\n    }\n    // Reject messages from web pages\n    return false;\n}\n/**\n * Install the main message listener\n * All messages are validated for sender origin to ensure they come from trusted extension contexts\n */\nexport function installMessageListener(deps) {\n    if (typeof chrome === 'undefined' || !chrome.runtime)\n        return;\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        // SECURITY: Validate sender before processing any message\n        if (!isValidMessageSender(sender)) {\n            deps.debugLog('error', 'Rejected message from untrusted sender', { senderId: sender.id, senderUrl: sender.url });\n            return false;\n        }\n        return handleMessage(message, sender, sendResponse, deps);\n    });\n}\n/**\n * Type guard to validate message structure before processing\n * Returns true if message passes validation, logs rejection otherwise\n */\nfunction validateMessageType(message, expectedType, deps) {\n    if (typeof message !== 'object' || message === null) {\n        deps.debugLog('error', `Invalid message: not an object`, { messageType: typeof message });\n        return false;\n    }\n    const msg = message;\n    if (msg.type !== expectedType) {\n        deps.debugLog('error', `Message type mismatch`, { expected: expectedType, received: msg.type });\n        return false;\n    }\n    return true;\n}\n/**\n * Handle incoming message\n * Returns true if response will be sent asynchronously\n * Security: All messages are type-validated using discriminated unions\n */\nfunction handleMessage(message, sender, sendResponse, deps) {\n    const messageType = message.type;\n    // Type validation: ensure message conforms to expected discriminated union\n    // TypeScript's type system ensures exhaustiveness, but add logging for debugging\n    switch (messageType) {\n        case 'GET_TAB_ID':\n            sendResponse({ tabId: sender.tab?.id });\n            return true;\n        case 'ws_event':\n            deps.addToWsBatcher(message.payload);\n            return false;\n        case 'enhanced_action':\n            deps.addToEnhancedActionBatcher(message.payload);\n            return false;\n        case 'network_body':\n            if (deps.isNetworkBodyCaptureDisabled()) {\n                deps.debugLog('capture', 'Network body dropped: capture disabled');\n                return true;\n            }\n            // Attach tabId to payload before batching (v5.3+)\n            deps.addToNetworkBodyBatcher({ ...message.payload, tabId: message.tabId });\n            return false;\n        case 'performance_snapshot':\n            deps.addToPerfBatcher(message.payload);\n            return false;\n        case 'log':\n            handleLogMessageAsync(message, sender, deps);\n            return true;\n        case 'getStatus':\n            sendResponse({\n                ...deps.getConnectionStatus(),\n                serverUrl: deps.getServerUrl(),\n                screenshotOnError: deps.getScreenshotOnError(),\n                sourceMapEnabled: deps.getSourceMapEnabled(),\n                debugMode: deps.getDebugMode(),\n                contextWarning: deps.getContextWarning(),\n                circuitBreakerState: deps.getCircuitBreakerState(),\n                memoryPressure: deps.getMemoryPressureState(),\n            });\n            return false;\n        case 'clearLogs':\n            handleClearLogsAsync(sendResponse, deps);\n            return true;\n        case 'setLogLevel':\n            deps.setCurrentLogLevel(message.level);\n            deps.saveSetting('logLevel', message.level);\n            return false;\n        case 'setScreenshotOnError':\n            deps.setScreenshotOnError(message.enabled);\n            deps.saveSetting('screenshotOnError', message.enabled);\n            sendResponse({ success: true });\n            return false;\n        case 'setAiWebPilotEnabled':\n            handleSetAiWebPilotEnabled(message.enabled, sendResponse, deps);\n            return false;\n        case 'getAiWebPilotEnabled':\n            sendResponse({ enabled: deps.getAiWebPilotEnabled() });\n            return false;\n        case 'getTrackingState':\n            handleGetTrackingState(sendResponse, deps);\n            return true;\n        case 'getDiagnosticState':\n            handleGetDiagnosticState(sendResponse, deps);\n            return true;\n        case 'captureScreenshot':\n            handleCaptureScreenshot(sendResponse, deps);\n            return true;\n        case 'setSourceMapEnabled':\n            deps.setSourceMapEnabled(message.enabled);\n            deps.saveSetting('sourceMapEnabled', message.enabled);\n            if (!message.enabled) {\n                deps.clearSourceMapCache();\n            }\n            sendResponse({ success: true });\n            return false;\n        case 'setNetworkWaterfallEnabled':\n        case 'setPerformanceMarksEnabled':\n        case 'setActionReplayEnabled':\n        case 'setWebSocketCaptureEnabled':\n        case 'setWebSocketCaptureMode':\n        case 'setPerformanceSnapshotEnabled':\n        case 'setDeferralEnabled':\n        case 'setNetworkBodyCaptureEnabled':\n        case 'setActionToastsEnabled':\n        case 'setSubtitlesEnabled':\n            handleForwardedSetting(message, sendResponse, deps);\n            return false;\n        case 'setDebugMode':\n            deps.setDebugMode(message.enabled);\n            deps.saveSetting('debugMode', message.enabled);\n            sendResponse({ success: true });\n            return false;\n        case 'getDebugLog':\n            sendResponse({ log: deps.exportDebugLog() });\n            return false;\n        case 'clearDebugLog':\n            deps.clearDebugLog();\n            deps.debugLog('lifecycle', 'Debug log cleared');\n            sendResponse({ success: true });\n            return false;\n        case 'setServerUrl':\n            handleSetServerUrl(message.url, sendResponse, deps);\n            return false;\n        default:\n            // Unknown message type\n            return false;\n    }\n}\n// =============================================================================\n// ASYNC HANDLERS\n// =============================================================================\nasync function handleLogMessageAsync(message, sender, deps) {\n    try {\n        await deps.handleLogMessage(message.payload, sender, message.tabId);\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to handle log message:', err);\n    }\n}\nasync function handleClearLogsAsync(sendResponse, deps) {\n    try {\n        const result = await deps.handleClearLogs();\n        sendResponse(result);\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to clear logs:', err);\n        sendResponse({ error: err.message });\n    }\n}\nfunction handleSetAiWebPilotEnabled(enabled, sendResponse, deps) {\n    const newValue = enabled === true;\n    console.log(`[Gasoline] AI Web Pilot toggle: -> ${newValue}`);\n    deps.setAiWebPilotEnabled(newValue, () => {\n        console.log(`[Gasoline] AI Web Pilot persisted to storage: ${newValue}`);\n        // Settings now sent automatically via /sync\n        // Broadcast tracking state change to tracked tab (for favicon flicker)\n        broadcastTrackingState();\n    });\n    sendResponse({ success: true });\n}\n/**\n * Handle getTrackingState request from content script.\n * Returns current tracking and AI Pilot state for favicon replacer.\n */\nasync function handleGetTrackingState(sendResponse, deps) {\n    try {\n        const result = await chrome.storage.local.get(['trackedTabId']);\n        const trackedTabId = result.trackedTabId;\n        const aiPilotEnabled = deps.getAiWebPilotEnabled();\n        // Get the requesting tab ID\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        const currentTabId = tabs[0]?.id;\n        sendResponse({\n            state: {\n                isTracked: currentTabId === trackedTabId,\n                aiPilotEnabled: aiPilotEnabled,\n            },\n        });\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to get tracking state:', err);\n        sendResponse({ state: { isTracked: false, aiPilotEnabled: false } });\n    }\n}\n/**\n * Broadcast tracking state to the tracked tab.\n * Used by favicon replacer to show/hide flicker animation.\n * Exported for use in init.ts storage change handlers.\n * @param untrackedTabId - Optional tab ID that was just untracked (to notify it to stop flicker)\n */\nexport async function broadcastTrackingState(untrackedTabId) {\n    try {\n        const result = await chrome.storage.local.get(['trackedTabId', 'aiWebPilotEnabled']);\n        const trackedTabId = result.trackedTabId;\n        const aiPilotEnabled = result.aiWebPilotEnabled === true;\n        // Notify the currently tracked tab it's being tracked\n        if (trackedTabId) {\n            chrome.tabs\n                .sendMessage(trackedTabId, {\n                type: 'trackingStateChanged',\n                state: {\n                    isTracked: true,\n                    aiPilotEnabled: aiPilotEnabled,\n                },\n            })\n                .catch(() => {\n                // Tab might not have content script loaded yet, ignore\n            });\n        }\n        // Notify the previously tracked tab it's no longer tracked (to stop favicon flicker)\n        if (untrackedTabId && untrackedTabId !== trackedTabId) {\n            chrome.tabs\n                .sendMessage(untrackedTabId, {\n                type: 'trackingStateChanged',\n                state: {\n                    isTracked: false,\n                    aiPilotEnabled: false,\n                },\n            })\n                .catch(() => {\n                // Tab might not have content script loaded, ignore\n            });\n        }\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to broadcast tracking state:', err);\n    }\n}\nfunction handleGetDiagnosticState(sendResponse, deps) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        sendResponse({\n            cache: deps.getAiWebPilotEnabled(),\n            storage: undefined,\n            timestamp: new Date().toISOString(),\n        });\n        return;\n    }\n    chrome.storage.local.get(['aiWebPilotEnabled'], (result) => {\n        sendResponse({\n            cache: deps.getAiWebPilotEnabled(),\n            storage: result.aiWebPilotEnabled,\n            timestamp: new Date().toISOString(),\n        });\n    });\n}\nfunction handleCaptureScreenshot(sendResponse, deps) {\n    if (typeof chrome === 'undefined' || !chrome.tabs) {\n        sendResponse({ success: false, error: 'Chrome tabs API not available' });\n        return;\n    }\n    chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {\n        if (tabs[0]?.id) {\n            const result = await deps.captureScreenshot(tabs[0].id, null);\n            if (result.success && result.entry) {\n                deps.addToLogBatcher(result.entry);\n            }\n            sendResponse(result);\n        }\n        else {\n            sendResponse({ success: false, error: 'No active tab' });\n        }\n    });\n}\nfunction handleForwardedSetting(message, sendResponse, deps) {\n    deps.debugLog('settings', `Setting ${message.type}: ${message.enabled ?? message.mode}`);\n    deps.forwardToAllContentScripts(message);\n    sendResponse({ success: true });\n}\nfunction handleSetServerUrl(url, sendResponse, deps) {\n    deps.setServerUrl(url || 'http://localhost:7890');\n    deps.saveSetting('serverUrl', deps.getServerUrl());\n    deps.debugLog('settings', `Server URL changed to: ${deps.getServerUrl()}`);\n    // Broadcast to all content scripts\n    deps.forwardToAllContentScripts({ type: 'setServerUrl', url: deps.getServerUrl() });\n    // Re-check connection with new URL\n    deps.checkConnectionAndUpdate();\n    sendResponse({ success: true });\n}\n// =============================================================================\n// STATE SNAPSHOT STORAGE\n// =============================================================================\nconst SNAPSHOT_KEY = 'gasoline_state_snapshots';\n/**\n * Save a state snapshot to chrome.storage.local\n */\nexport async function saveStateSnapshot(name, state) {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(SNAPSHOT_KEY, (result) => {\n            const snapshots = result[SNAPSHOT_KEY] || {};\n            const sizeBytes = JSON.stringify(state).length;\n            snapshots[name] = {\n                ...state,\n                name,\n                size_bytes: sizeBytes,\n            };\n            chrome.storage.local.set({ [SNAPSHOT_KEY]: snapshots }, () => {\n                resolve({\n                    success: true,\n                    snapshot_name: name,\n                    size_bytes: sizeBytes,\n                });\n            });\n        });\n    });\n}\n/**\n * Load a state snapshot from chrome.storage.local\n */\nexport async function loadStateSnapshot(name) {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(SNAPSHOT_KEY, (result) => {\n            const snapshots = result[SNAPSHOT_KEY] || {};\n            resolve(snapshots[name] || null);\n        });\n    });\n}\n/**\n * List all state snapshots with metadata\n */\nexport async function listStateSnapshots() {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(SNAPSHOT_KEY, (result) => {\n            const snapshots = result[SNAPSHOT_KEY] || {};\n            const list = Object.values(snapshots).map((s) => ({\n                name: s.name,\n                url: s.url,\n                timestamp: s.timestamp,\n                size_bytes: s.size_bytes,\n            }));\n            resolve(list);\n        });\n    });\n}\n/**\n * Delete a state snapshot from chrome.storage.local\n */\nexport async function deleteStateSnapshot(name) {\n    return new Promise((resolve) => {\n        chrome.storage.local.get(SNAPSHOT_KEY, (result) => {\n            const snapshots = result[SNAPSHOT_KEY] || {};\n            delete snapshots[name];\n            chrome.storage.local.set({ [SNAPSHOT_KEY]: snapshots }, () => {\n                resolve({ success: true, deleted: name });\n            });\n        });\n    });\n}\n//# sourceMappingURL=message-handlers.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/pending-queries.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":149,"column":29,"nodeType":"MemberExpression","endLine":149,"endColumn":40},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":149,"column":53,"nodeType":"MemberExpression","endLine":149,"endColumn":61},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":152,"column":29,"nodeType":"MemberExpression","endLine":152,"endColumn":40},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":628,"column":42,"nodeType":"CallExpression","messageId":"returnsValue","endLine":628,"endColumn":60,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[26397,26415],"text":"{setTimeout(r, 500)}"},"desc":"Wrap the expression in `{}`."}]},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":654,"column":42,"nodeType":"CallExpression","messageId":"returnsValue","endLine":654,"endColumn":61,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[27754,27773],"text":"{setTimeout(r, 1000)}"},"desc":"Wrap the expression in `{}`."}]}],"suppressedMessages":[{"ruleId":"no-new-func","severity":2,"message":"The Function constructor is eval.","line":91,"column":28,"nodeType":"NewExpression","messageId":"noFunctionConstructor","endLine":91,"endColumn":46,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Pending Query Handlers\n * Handles all query types from the server: DOM, accessibility, browser actions,\n * execute commands, and state management.\n *\n * All results are returned via syncClient.queueCommandResult() which routes them\n * through the unified /sync endpoint. No direct HTTP POSTs to legacy endpoints.\n */\nimport * as eventListeners from './event-listeners.js';\nimport * as index from './index.js';\nimport { DebugCategory } from './debug.js';\nimport { saveStateSnapshot, loadStateSnapshot, listStateSnapshots, deleteStateSnapshot, broadcastTrackingState } from './message-handlers.js';\nimport { executeDOMAction } from './dom-primitives.js';\nimport { canTakeScreenshot, recordScreenshot } from './state-manager.js';\n// Extract values from index for easier reference (but NOT DebugCategory - imported directly above)\nconst { debugLog, diagnosticLog } = index;\n// =============================================================================\n// TIMEOUT CONFIGURATION\n// =============================================================================\n/**\n * Timeout for async execute commands (JavaScript execution in page context)\n * Needs to accommodate:\n * - Axe accessibility audits on large pages (20-30s)\n * - Complex DOM queries\n * - Screenshot capture and encoding\n * - Custom JavaScript execution\n */\nconst ASYNC_EXECUTE_TIMEOUT_MS = 60000; // 60 seconds\n/**\n * Timeout for async browser actions (navigation, refresh, etc.)\n * Needs to accommodate:\n * - Page navigation on slow networks\n * - Page load and rendering\n * - Resource fetching\n */\nconst ASYNC_BROWSER_ACTION_TIMEOUT_MS = 60000; // 60 seconds\n// =============================================================================\n// RESULT HELPERS\n// =============================================================================\n/** Send a query result back through /sync */\nfunction sendResult(syncClient, queryId, result) {\n    debugLog(DebugCategory.CONNECTION, 'sendResult via /sync', { queryId, hasResult: result != null });\n    syncClient.queueCommandResult({ id: queryId, status: 'complete', result });\n}\n/** Send an async command result back through /sync */\nfunction sendAsyncResult(syncClient, queryId, correlationId, status, result, error) {\n    debugLog(DebugCategory.CONNECTION, 'sendAsyncResult via /sync', { queryId, correlationId, status, hasResult: result != null, error: error || null });\n    syncClient.queueCommandResult({\n        id: queryId,\n        correlation_id: correlationId,\n        status,\n        result,\n        error,\n    });\n}\n/** Show a visual action toast on the tracked tab */\nfunction actionToast(tabId, text, detail, state = 'success', durationMs = 3000) {\n    chrome.tabs.sendMessage(tabId, {\n        type: 'GASOLINE_ACTION_TOAST',\n        text,\n        detail,\n        state,\n        duration_ms: durationMs,\n    }).catch(() => { });\n}\n// =============================================================================\n// ISOLATED WORLD EXECUTION (chrome.scripting API)\n// =============================================================================\n/**\n * Execute JavaScript via chrome.scripting.executeScript.\n * Used as fallback when MAIN world execution fails due to page CSP,\n * or when inject script is not loaded.\n * The func is injected natively by Chrome's extension system.\n */\nasync function executeViaScriptingAPI(tabId, script, timeoutMs) {\n    const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error(`Script exceeded ${timeoutMs}ms timeout`)), timeoutMs + 2000);\n    });\n    const executionPromise = chrome.scripting.executeScript({\n        target: { tabId },\n        world: 'MAIN',\n        func: (code) => {\n            try {\n                const cleaned = code.trim();\n                const hasMultiple = cleaned.includes(';');\n                const hasReturn = /\\breturn\\b/.test(cleaned);\n                const body = hasMultiple || hasReturn\n                    ? `\"use strict\"; ${cleaned}`\n                    : `\"use strict\"; return (${cleaned});`;\n                // eslint-disable-next-line no-new-func\n                const fn = new Function(body);\n                const result = fn();\n                if (result !== null && result !== undefined && typeof result.then === 'function') {\n                    return result.then((v) => {\n                        return { success: true, result: serialize(v) };\n                    }).catch((err) => {\n                        const e = err;\n                        return { success: false, error: 'promise_rejected', message: e.message };\n                    });\n                }\n                return { success: true, result: serialize(result) };\n            }\n            catch (err) {\n                const e = err;\n                const msg = e.message || '';\n                if (msg.includes('Content Security Policy') || msg.includes('Trusted Type') || msg.includes('unsafe-eval')) {\n                    return {\n                        success: false,\n                        error: 'csp_blocked_all_worlds',\n                        message: 'Page CSP blocks dynamic script execution. ' +\n                            'Use query_dom for DOM operations or navigate away from this CSP-restricted page.',\n                    };\n                }\n                return { success: false, error: 'execution_error', message: msg, stack: e.stack };\n            }\n            function serialize(value, depth = 0, seen = new WeakSet()) {\n                if (depth > 10)\n                    return '[max depth]';\n                if (value === null || value === undefined)\n                    return value;\n                const t = typeof value;\n                if (t === 'string' || t === 'number' || t === 'boolean')\n                    return value;\n                if (t === 'function')\n                    return '[Function]';\n                if (t === 'symbol')\n                    return String(value);\n                if (t === 'object') {\n                    const obj = value;\n                    if (seen.has(obj))\n                        return '[Circular]';\n                    seen.add(obj);\n                    if (Array.isArray(obj))\n                        return obj.slice(0, 100).map(v => serialize(v, depth + 1, seen));\n                    if (obj instanceof Error)\n                        return { error: obj.message };\n                    if (obj instanceof Date)\n                        return obj.toISOString();\n                    if (obj instanceof RegExp)\n                        return String(obj);\n                    // DOM node duck-type check (works across worlds)\n                    if ('nodeType' in obj && 'nodeName' in obj) {\n                        const node = obj;\n                        return `[${node.nodeName}${node.id ? '#' + node.id : ''}]`;\n                    }\n                    const result = {};\n                    for (const key of Object.keys(obj).slice(0, 50)) {\n                        try {\n                            result[key] = serialize(obj[key], depth + 1, seen);\n                        }\n                        catch {\n                            result[key] = '[unserializable]';\n                        }\n                    }\n                    return result;\n                }\n                return String(value);\n            }\n        },\n        args: [script],\n    });\n    try {\n        const results = await Promise.race([executionPromise, timeoutPromise]);\n        const firstResult = results?.[0]?.result;\n        if (firstResult && typeof firstResult === 'object') {\n            return firstResult;\n        }\n        return { success: false, error: 'no_result', message: 'chrome.scripting.executeScript produced no result' };\n    }\n    catch (err) {\n        const msg = err.message || '';\n        if (msg.includes('timeout')) {\n            return { success: false, error: 'execution_timeout', message: msg };\n        }\n        return { success: false, error: 'scripting_api_error', message: msg };\n    }\n}\n/**\n * Execute JS with world-aware routing.\n * - isolated: execute directly via chrome.scripting API\n * - main: send to content script (MAIN world via inject)\n * - auto: try content script, fallback to scripting API on CSP/inject errors\n */\nasync function executeWithWorldRouting(tabId, queryParams, world) {\n    let parsedParams;\n    try {\n        parsedParams = typeof queryParams === 'string' ? JSON.parse(queryParams) : queryParams;\n    }\n    catch {\n        parsedParams = {};\n    }\n    const script = parsedParams.script || '';\n    const timeoutMs = parsedParams.timeout_ms || 5000;\n    if (world === 'isolated') {\n        return executeViaScriptingAPI(tabId, script, timeoutMs);\n    }\n    // MAIN or AUTO: try content script (MAIN world) first\n    try {\n        const result = await chrome.tabs.sendMessage(tabId, {\n            type: 'GASOLINE_EXECUTE_QUERY',\n            params: queryParams,\n        });\n        // Auto-fallback: retry via scripting API on CSP or inject issues\n        if (world === 'auto' && result && !result.success &&\n            (result.error === 'csp_blocked' || result.error === 'inject_not_loaded')) {\n            debugLog(DebugCategory.CONNECTION, 'Auto-fallback to chrome.scripting API', {\n                error: result.error, tabId,\n            });\n            return executeViaScriptingAPI(tabId, script, timeoutMs);\n        }\n        return result;\n    }\n    catch (err) {\n        let message = err.message || 'Tab communication failed';\n        // Auto-fallback: content script not reachable\n        if (world === 'auto' && message.includes('Receiving end does not exist')) {\n            debugLog(DebugCategory.CONNECTION, 'Auto-fallback (content script unreachable)', { tabId });\n            return executeViaScriptingAPI(tabId, script, timeoutMs);\n        }\n        if (message.includes('Receiving end does not exist')) {\n            message =\n                'Content script not loaded. REQUIRED ACTION: Refresh the page first using this command:\\n\\ninteract({action: \"refresh\"})\\n\\nThen retry your command.';\n        }\n        return { success: false, error: 'content_script_not_loaded', message };\n    }\n}\n// =============================================================================\n// PENDING QUERY HANDLING\n// =============================================================================\nexport async function handlePendingQuery(query, syncClient) {\n    debugLog(DebugCategory.CONNECTION, 'handlePendingQuery ENTER', {\n        id: query.id,\n        type: query.type,\n        correlation_id: query.correlation_id || null,\n        hasSyncClient: !!syncClient,\n    });\n    try {\n        if (query.type.startsWith('state_')) {\n            await handleStateQuery(query, syncClient);\n            return;\n        }\n        const storage = await eventListeners.getTrackedTabInfo();\n        let tabId;\n        if (storage.trackedTabId) {\n            diagnosticLog(`[Diagnostic] Using tracked tab ${storage.trackedTabId} for query ${query.type}`);\n            try {\n                await chrome.tabs.get(storage.trackedTabId);\n                tabId = storage.trackedTabId;\n            }\n            catch {\n                diagnosticLog(`[Diagnostic] Tracked tab ${storage.trackedTabId} no longer exists, clearing tracking`);\n                eventListeners.clearTrackedTab();\n                const activeTabs = await chrome.tabs.query({ active: true, currentWindow: true });\n                const firstActiveTab = activeTabs[0];\n                if (!firstActiveTab?.id)\n                    return;\n                tabId = firstActiveTab.id;\n            }\n        }\n        else {\n            const activeTabs = await chrome.tabs.query({ active: true, currentWindow: true });\n            const firstActiveTab = activeTabs[0];\n            if (!firstActiveTab?.id)\n                return;\n            tabId = firstActiveTab.id;\n        }\n        if (!tabId)\n            return;\n        if (query.type === 'subtitle') {\n            let params;\n            try {\n                params = typeof query.params === 'string' ? JSON.parse(query.params) : query.params;\n            }\n            catch {\n                params = {};\n            }\n            chrome.tabs.sendMessage(tabId, {\n                type: 'GASOLINE_SUBTITLE',\n                text: params.text ?? '',\n            }).catch(() => { });\n            sendResult(syncClient, query.id, { success: true, subtitle: params.text || 'cleared' });\n            return;\n        }\n        if (query.type === 'screenshot') {\n            try {\n                const rateCheck = canTakeScreenshot(tabId);\n                if (!rateCheck.allowed) {\n                    sendResult(syncClient, query.id, {\n                        error: `Rate limited: ${rateCheck.reason}`,\n                        ...(rateCheck.nextAllowedIn != null ? { next_allowed_in: rateCheck.nextAllowedIn } : {}),\n                    });\n                    return;\n                }\n                const tab = await chrome.tabs.get(tabId);\n                const dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, {\n                    format: 'jpeg',\n                    quality: 80,\n                });\n                recordScreenshot(tabId);\n                // POST to /screenshots with query_id — server saves file and resolves query directly\n                const response = await fetch(`${index.serverUrl}/screenshots`, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        data_url: dataUrl,\n                        url: tab.url,\n                        query_id: query.id,\n                    }),\n                });\n                if (!response.ok) {\n                    sendResult(syncClient, query.id, { error: `Server returned ${response.status}` });\n                }\n                // No sendResult needed — server resolves the query via query_id\n            }\n            catch (err) {\n                sendResult(syncClient, query.id, {\n                    error: 'screenshot_failed',\n                    message: err.message || 'Failed to capture screenshot',\n                });\n            }\n            return;\n        }\n        if (query.type === 'browser_action') {\n            let params;\n            try {\n                params = typeof query.params === 'string' ? JSON.parse(query.params) : query.params;\n            }\n            catch {\n                sendResult(syncClient, query.id, {\n                    success: false,\n                    error: 'invalid_params',\n                    message: 'Failed to parse browser_action params as JSON',\n                });\n                return;\n            }\n            if (query.correlation_id) {\n                await handleAsyncBrowserAction(query, tabId, params, syncClient);\n            }\n            else {\n                const result = await handleBrowserAction(tabId, params);\n                sendResult(syncClient, query.id, result);\n            }\n            return;\n        }\n        if (query.type === 'highlight') {\n            let params;\n            try {\n                params = typeof query.params === 'string' ? JSON.parse(query.params) : query.params;\n            }\n            catch {\n                sendResult(syncClient, query.id, {\n                    error: 'invalid_params',\n                    message: 'Failed to parse highlight params as JSON',\n                });\n                return;\n            }\n            const result = await handlePilotCommand('GASOLINE_HIGHLIGHT', params);\n            sendResult(syncClient, query.id, result);\n            return;\n        }\n        if (query.type === 'page_info') {\n            const tab = await chrome.tabs.get(tabId);\n            const result = {\n                url: tab.url,\n                title: tab.title,\n                favicon: tab.favIconUrl,\n                status: tab.status,\n                viewport: {\n                    width: tab.width,\n                    height: tab.height,\n                },\n            };\n            sendResult(syncClient, query.id, result);\n            return;\n        }\n        if (query.type === 'tabs') {\n            const allTabs = await chrome.tabs.query({});\n            const tabsList = allTabs.map((tab) => ({\n                id: tab.id,\n                url: tab.url,\n                title: tab.title,\n                active: tab.active,\n                windowId: tab.windowId,\n                index: tab.index,\n            }));\n            sendResult(syncClient, query.id, { tabs: tabsList });\n            return;\n        }\n        // Waterfall query - fetch network waterfall data on demand\n        if (query.type === 'waterfall') {\n            debugLog(DebugCategory.CAPTURE, 'Handling waterfall query', { queryId: query.id, tabId });\n            try {\n                const tab = await chrome.tabs.get(tabId);\n                debugLog(DebugCategory.CAPTURE, 'Got tab for waterfall', { tabId, url: tab.url });\n                const result = (await chrome.tabs.sendMessage(tabId, {\n                    type: 'GET_NETWORK_WATERFALL',\n                }));\n                debugLog(DebugCategory.CAPTURE, 'Waterfall result from content script', {\n                    entries: result?.entries?.length || 0\n                });\n                sendResult(syncClient, query.id, {\n                    entries: result?.entries || [],\n                    pageURL: tab.url || '',\n                    count: result?.entries?.length || 0,\n                });\n                debugLog(DebugCategory.CAPTURE, 'Posted waterfall result', { queryId: query.id });\n            }\n            catch (err) {\n                debugLog(DebugCategory.CAPTURE, 'Waterfall query error', {\n                    queryId: query.id,\n                    error: err.message\n                });\n                sendResult(syncClient, query.id, {\n                    error: 'waterfall_query_failed',\n                    message: err.message || 'Failed to fetch network waterfall',\n                    entries: [],\n                });\n            }\n            return;\n        }\n        if (query.type === 'dom') {\n            try {\n                const result = await chrome.tabs.sendMessage(tabId, {\n                    type: 'DOM_QUERY',\n                    params: query.params,\n                });\n                sendResult(syncClient, query.id, result);\n            }\n            catch (err) {\n                sendResult(syncClient, query.id, {\n                    error: 'dom_query_failed',\n                    message: err.message || 'Failed to execute DOM query',\n                });\n            }\n            return;\n        }\n        if (query.type === 'a11y') {\n            try {\n                const result = await chrome.tabs.sendMessage(tabId, {\n                    type: 'A11Y_QUERY',\n                    params: query.params,\n                });\n                sendResult(syncClient, query.id, result);\n            }\n            catch (err) {\n                sendResult(syncClient, query.id, {\n                    error: 'a11y_audit_failed',\n                    message: err.message || 'Failed to execute accessibility audit',\n                });\n            }\n            return;\n        }\n        if (query.type === 'dom_action') {\n            if (!index.__aiWebPilotEnabledCache) {\n                sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', null, 'ai_web_pilot_disabled');\n                return;\n            }\n            await executeDOMAction(query, tabId, syncClient, sendAsyncResult, actionToast);\n            return;\n        }\n        if (query.type === 'execute') {\n            if (!index.__aiWebPilotEnabledCache) {\n                if (query.correlation_id) {\n                    sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', null, 'ai_web_pilot_disabled');\n                }\n                else {\n                    sendResult(syncClient, query.id, {\n                        success: false,\n                        error: 'ai_web_pilot_disabled',\n                        message: 'AI Web Pilot is not enabled in the extension popup',\n                    });\n                }\n                return;\n            }\n            // Parse world param for routing\n            let execParams;\n            try {\n                execParams = typeof query.params === 'string' ? JSON.parse(query.params) : query.params;\n            }\n            catch {\n                execParams = {};\n            }\n            const world = execParams.world || 'auto';\n            if (query.correlation_id) {\n                await handleAsyncExecuteCommand(query, tabId, world, syncClient);\n            }\n            else {\n                try {\n                    const result = await executeWithWorldRouting(tabId, query.params, world);\n                    sendResult(syncClient, query.id, result);\n                }\n                catch (err) {\n                    sendResult(syncClient, query.id, {\n                        success: false,\n                        error: 'execution_failed',\n                        message: err.message || 'Execution failed',\n                    });\n                }\n            }\n            return;\n        }\n    }\n    catch (err) {\n        debugLog(DebugCategory.CONNECTION, 'Error handling pending query', {\n            type: query.type,\n            id: query.id,\n            error: err.message,\n        });\n    }\n}\nasync function handleStateQuery(query, syncClient) {\n    if (!index.__aiWebPilotEnabledCache) {\n        sendResult(syncClient, query.id, { error: 'ai_web_pilot_disabled' });\n        return;\n    }\n    let params;\n    try {\n        params = typeof query.params === 'string' ? JSON.parse(query.params) : query.params;\n    }\n    catch {\n        sendResult(syncClient, query.id, {\n            error: 'invalid_params',\n            message: 'Failed to parse state query params as JSON',\n        });\n        return;\n    }\n    const action = params.action;\n    try {\n        let result;\n        switch (action) {\n            case 'capture': {\n                const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n                const firstTab = tabs[0];\n                if (!firstTab?.id) {\n                    sendResult(syncClient, query.id, { error: 'no_active_tab' });\n                    return;\n                }\n                result = await chrome.tabs.sendMessage(firstTab.id, {\n                    type: 'GASOLINE_MANAGE_STATE',\n                    params: { action: 'capture' },\n                });\n                break;\n            }\n            case 'save': {\n                const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n                const firstTab = tabs[0];\n                if (!firstTab?.id) {\n                    sendResult(syncClient, query.id, { error: 'no_active_tab' });\n                    return;\n                }\n                const captureResult = (await chrome.tabs.sendMessage(firstTab.id, {\n                    type: 'GASOLINE_MANAGE_STATE',\n                    params: { action: 'capture' },\n                }));\n                if (captureResult.error) {\n                    sendResult(syncClient, query.id, { error: captureResult.error });\n                    return;\n                }\n                result = await saveStateSnapshot(params.name, captureResult);\n                break;\n            }\n            case 'load': {\n                const snapshot = await loadStateSnapshot(params.name);\n                if (!snapshot) {\n                    sendResult(syncClient, query.id, {\n                        error: `Snapshot '${params.name}' not found`,\n                    });\n                    return;\n                }\n                const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n                const firstTab = tabs[0];\n                if (!firstTab?.id) {\n                    sendResult(syncClient, query.id, { error: 'no_active_tab' });\n                    return;\n                }\n                result = await chrome.tabs.sendMessage(firstTab.id, {\n                    type: 'GASOLINE_MANAGE_STATE',\n                    params: {\n                        action: 'restore',\n                        state: snapshot,\n                        include_url: params.include_url !== false,\n                    },\n                });\n                break;\n            }\n            case 'list':\n                result = { snapshots: await listStateSnapshots() };\n                break;\n            case 'delete':\n                result = await deleteStateSnapshot(params.name);\n                break;\n            default:\n                result = { error: `Unknown action: ${action}` };\n        }\n        sendResult(syncClient, query.id, result);\n    }\n    catch (err) {\n        sendResult(syncClient, query.id, { error: err.message });\n    }\n}\nasync function handleBrowserAction(tabId, params) {\n    const { action, url, reason } = params || {};\n    if (!index.__aiWebPilotEnabledCache) {\n        return { success: false, error: 'ai_web_pilot_disabled', message: 'AI Web Pilot is not enabled' };\n    }\n    try {\n        switch (action) {\n            case 'refresh':\n                actionToast(tabId, 'refresh', reason || 'reloading page', 'trying', 10000);\n                await chrome.tabs.reload(tabId);\n                await eventListeners.waitForTabLoad(tabId);\n                actionToast(tabId, 'refresh', reason || 'page reloaded', 'success');\n                return { success: true, action: 'refresh' };\n            case 'navigate': {\n                if (!url) {\n                    return { success: false, error: 'missing_url', message: 'URL required for navigate action' };\n                }\n                if (url.startsWith('chrome://') || url.startsWith('chrome-extension://')) {\n                    return {\n                        success: false,\n                        error: 'restricted_url',\n                        message: 'Cannot navigate to Chrome internal pages',\n                    };\n                }\n                actionToast(tabId, 'navigate', reason || url, 'trying', 10000);\n                await chrome.tabs.update(tabId, { url });\n                await eventListeners.waitForTabLoad(tabId);\n                await new Promise((r) => setTimeout(r, 500));\n                const contentScriptLoaded = await eventListeners.pingContentScript(tabId);\n                if (contentScriptLoaded) {\n                    broadcastTrackingState().catch(() => { });\n                    actionToast(tabId, 'navigate', reason || url, 'success');\n                    return {\n                        success: true,\n                        action: 'navigate',\n                        url,\n                        content_script_status: 'loaded',\n                        message: 'Content script ready',\n                    };\n                }\n                const tab = await chrome.tabs.get(tabId);\n                if (tab.url?.startsWith('file://')) {\n                    return {\n                        success: true,\n                        action: 'navigate',\n                        url,\n                        content_script_status: 'unavailable',\n                        message: 'Content script cannot load on file:// URLs. Enable \"Allow access to file URLs\" in extension settings.',\n                    };\n                }\n                debugLog(DebugCategory.CAPTURE, 'Content script not loaded after navigate, refreshing', { tabId, url });\n                await chrome.tabs.reload(tabId);\n                await eventListeners.waitForTabLoad(tabId);\n                await new Promise((r) => setTimeout(r, 1000));\n                const loadedAfterRefresh = await eventListeners.pingContentScript(tabId);\n                if (loadedAfterRefresh) {\n                    broadcastTrackingState().catch(() => { });\n                    return {\n                        success: true,\n                        action: 'navigate',\n                        url,\n                        content_script_status: 'refreshed',\n                        message: 'Page refreshed to load content script',\n                    };\n                }\n                return {\n                    success: true,\n                    action: 'navigate',\n                    url,\n                    content_script_status: 'failed',\n                    message: 'Navigation complete but content script could not be loaded. AI Web Pilot tools may not work.',\n                };\n            }\n            case 'back':\n                await chrome.tabs.goBack(tabId);\n                return { success: true, action: 'back' };\n            case 'forward':\n                await chrome.tabs.goForward(tabId);\n                return { success: true, action: 'forward' };\n            default:\n                return { success: false, error: 'unknown_action', message: `Unknown action: ${action}` };\n        }\n    }\n    catch (err) {\n        return { success: false, error: 'browser_action_failed', message: err.message };\n    }\n}\nasync function handleAsyncExecuteCommand(query, tabId, world, syncClient) {\n    const startTime = Date.now();\n    try {\n        const result = await Promise.race([\n            executeWithWorldRouting(tabId, query.params, world),\n            new Promise((_, reject) => {\n                setTimeout(() => reject(new Error(`Script execution timed out after ${ASYNC_EXECUTE_TIMEOUT_MS}ms. Script may be stuck in a loop or waiting for user input.`)), ASYNC_EXECUTE_TIMEOUT_MS);\n            }),\n        ]);\n        if (result.success) {\n            actionToast(tabId, 'execute_js', 'script completed', 'success');\n        }\n        sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', result);\n        debugLog(DebugCategory.CONNECTION, 'Completed async command', {\n            correlationId: query.correlation_id,\n            elapsed: Date.now() - startTime,\n            success: result.success,\n        });\n    }\n    catch {\n        const timeoutMessage = `JavaScript execution exceeded timeout. RECOMMENDED ACTIONS:\n\n1. Break your task into smaller discrete steps that execute in < 2s for best results\n2. Check your script for infinite loops or blocking operations\n3. Simplify the operation or target a smaller DOM scope`;\n        sendAsyncResult(syncClient, query.id, query.correlation_id, 'timeout', null, timeoutMessage);\n        debugLog(DebugCategory.CONNECTION, 'Async command timeout', {\n            correlationId: query.correlation_id,\n            elapsed: Date.now() - startTime,\n        });\n    }\n}\nasync function handleAsyncBrowserAction(query, tabId, params, syncClient) {\n    const startTime = Date.now();\n    const executionPromise = handleBrowserAction(tabId, params)\n        .then((result) => {\n        return result;\n    })\n        .catch((err) => {\n        return {\n            success: false,\n            error: err.message || 'Browser action failed',\n        };\n    });\n    try {\n        const execResult = await Promise.race([\n            executionPromise,\n            new Promise((_, reject) => {\n                setTimeout(() => reject(new Error(`Browser action execution timed out after ${ASYNC_BROWSER_ACTION_TIMEOUT_MS}ms. Action may be waiting for user interaction or network response.`)), ASYNC_BROWSER_ACTION_TIMEOUT_MS);\n            }),\n        ]);\n        if (execResult.success !== false) {\n            sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', execResult);\n        }\n        else {\n            sendAsyncResult(syncClient, query.id, query.correlation_id, 'complete', null, execResult.error);\n        }\n        debugLog(DebugCategory.CONNECTION, 'Completed async browser action', {\n            correlationId: query.correlation_id,\n            elapsed: Date.now() - startTime,\n            success: execResult.success !== false,\n        });\n    }\n    catch {\n        const timeoutMessage = `Browser action exceeded 10s timeout. DIAGNOSTIC STEPS:\n\n1. Check page status: observe({what: 'page'})\n2. Check for console errors: observe({what: 'errors'})\n3. Check network requests: observe({what: 'network', status_min: 400})`;\n        sendAsyncResult(syncClient, query.id, query.correlation_id, 'timeout', null, timeoutMessage);\n        debugLog(DebugCategory.CONNECTION, 'Async browser action timeout', {\n            correlationId: query.correlation_id,\n            elapsed: Date.now() - startTime,\n        });\n    }\n}\nexport async function handlePilotCommand(command, params) {\n    if (!index.__aiWebPilotEnabledCache) {\n        if (typeof chrome !== 'undefined' && chrome.storage) {\n            const localResult = await new Promise((resolve) => {\n                chrome.storage.local.get(['aiWebPilotEnabled'], (result) => {\n                    resolve(result);\n                });\n            });\n            if (localResult.aiWebPilotEnabled === true) {\n                // Update cache (note: this module imports from index.ts which has the state)\n                // We can't directly update it, so we return the error\n            }\n        }\n    }\n    if (!index.__aiWebPilotEnabledCache) {\n        return { error: 'ai_web_pilot_disabled' };\n    }\n    try {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        const firstTab = tabs[0];\n        if (!firstTab?.id) {\n            return { error: 'no_active_tab' };\n        }\n        const tabId = firstTab.id;\n        const result = await chrome.tabs.sendMessage(tabId, {\n            type: command,\n            params,\n        });\n        return result || { success: true };\n    }\n    catch (err) {\n        return { error: err.message || 'command_failed' };\n    }\n}\n//# sourceMappingURL=pending-queries.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/snapshots.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'DEBUG_LOG_MAX_ENTRIES' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":28,"suggestions":[{"messageId":"removeVar","data":{"varName":"DEBUG_LOG_MAX_ENTRIES"},"fix":{"range":[733,767],"text":""},"desc":"Remove unused variable 'DEBUG_LOG_MAX_ENTRIES'."}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":193,"column":26,"nodeType":"MemberExpression","endLine":193,"endColumn":55},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":204,"column":26,"nodeType":"MemberExpression","endLine":204,"endColumn":48},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":220,"column":29,"nodeType":"MemberExpression","endLine":220,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":223,"column":49,"nodeType":"MemberExpression","endLine":223,"endColumn":75}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Source Maps and Stack Trace Resolution\n * Handles source map fetching and caching, stack frame parsing,\n * VLQ decoding, and stack trace resolution for better error messages.\n */\nimport { getSourceMapCacheEntry, setSourceMapCacheEntry, isSourceMapEnabled, } from './cache-limits.js';\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n/** Source map fetch timeout */\nconst SOURCE_MAP_FETCH_TIMEOUT = 5000;\n/** Context annotation thresholds */\nconst CONTEXT_SIZE_THRESHOLD = 20 * 1024;\nconst CONTEXT_WARNING_WINDOW_MS = 60000;\nconst CONTEXT_WARNING_COUNT = 3;\n/** Debug log buffer size */\nconst DEBUG_LOG_MAX_ENTRIES = 200;\n/** Processing query TTL */\nconst PROCESSING_QUERY_TTL_MS = 60000;\n/** Stack frame regex patterns */\nconst STACK_FRAME_REGEX = /^\\s*at\\s+(?:(.+?)\\s+\\()?(?:(.+?):(\\d+):(\\d+)|(.+?):(\\d+))\\)?$/;\nconst ANONYMOUS_FRAME_REGEX = /^\\s*at\\s+(.+?):(\\d+):(\\d+)$/;\n/** VLQ character mapping */\nconst VLQ_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst VLQ_CHAR_MAP = new Map(VLQ_CHARS.split('').map((c, i) => [c, i]));\n// =============================================================================\n// STATE\n// =============================================================================\n/** Context annotation monitoring state */\nlet contextExcessiveTimestamps = [];\nlet contextWarningState = null;\n/** Processing queries tracking */\nconst processingQueries = new Map();\n// =============================================================================\n// CONTEXT ANNOTATION MONITORING\n// =============================================================================\n/**\n * Measure the serialized byte size of _context in a log entry\n */\nexport function measureContextSize(entry) {\n    const context = entry._context;\n    if (!context || typeof context !== 'object')\n        return 0;\n    const keys = Object.keys(context);\n    if (keys.length === 0)\n        return 0;\n    return JSON.stringify(context).length;\n}\n/**\n * Check a batch of entries for excessive context annotation usage\n */\nexport function checkContextAnnotations(entries) {\n    const now = Date.now();\n    for (const entry of entries) {\n        const size = measureContextSize(entry);\n        if (size > CONTEXT_SIZE_THRESHOLD) {\n            contextExcessiveTimestamps.push({ ts: now, size });\n        }\n    }\n    contextExcessiveTimestamps = contextExcessiveTimestamps.filter((t) => now - t.ts < CONTEXT_WARNING_WINDOW_MS);\n    if (contextExcessiveTimestamps.length >= CONTEXT_WARNING_COUNT) {\n        const avgSize = contextExcessiveTimestamps.reduce((sum, t) => sum + t.size, 0) / contextExcessiveTimestamps.length;\n        contextWarningState = {\n            sizeKB: Math.round(avgSize / 1024),\n            count: contextExcessiveTimestamps.length,\n            triggeredAt: now,\n        };\n    }\n    else if (contextWarningState && contextExcessiveTimestamps.length === 0) {\n        contextWarningState = null;\n    }\n}\n/**\n * Get the current context annotation warning state\n */\nexport function getContextWarning() {\n    return contextWarningState;\n}\n/**\n * Reset the context annotation warning (for testing)\n */\nexport function resetContextWarning() {\n    contextExcessiveTimestamps = [];\n    contextWarningState = null;\n}\n// =============================================================================\n// VLQ DECODING AND SOURCE MAP PARSING\n// =============================================================================\n/**\n * Decode a VLQ-encoded string into an array of integers\n */\nexport function decodeVLQ(str) {\n    const result = [];\n    let shift = 0;\n    let value = 0;\n    for (const char of str) {\n        const digit = VLQ_CHAR_MAP.get(char);\n        if (digit === undefined) {\n            throw new Error(`Invalid VLQ character: ${char}`);\n        }\n        const continued = digit & 32;\n        value += (digit & 31) << shift;\n        if (continued) {\n            shift += 5;\n        }\n        else {\n            const negate = value & 1;\n            value = value >> 1;\n            result.push(negate ? -value : value);\n            value = 0;\n            shift = 0;\n        }\n    }\n    return result;\n}\n/**\n * Parse a source map's mappings string into a structured format\n */\nexport function parseMappings(mappingsStr) {\n    const lines = mappingsStr.split(';');\n    const parsed = [];\n    for (const line of lines) {\n        const segments = [];\n        if (line.length > 0) {\n            const segmentStrs = line.split(',');\n            for (const segmentStr of segmentStrs) {\n                if (segmentStr.length > 0) {\n                    segments.push(decodeVLQ(segmentStr));\n                }\n            }\n        }\n        parsed.push(segments);\n    }\n    return parsed;\n}\n/**\n * Parse a stack trace line into components\n */\nexport function parseStackFrame(line) {\n    const match = line.match(STACK_FRAME_REGEX);\n    if (match) {\n        const [, functionName, file1, line1, col1, file2, line2] = match;\n        return {\n            functionName: functionName || '<anonymous>',\n            fileName: file1 || file2 || '',\n            lineNumber: parseInt(line1 || line2 || '0', 10),\n            columnNumber: col1 ? parseInt(col1, 10) : 0,\n            raw: line,\n        };\n    }\n    const anonMatch = line.match(ANONYMOUS_FRAME_REGEX);\n    if (anonMatch) {\n        return {\n            functionName: '<anonymous>',\n            fileName: anonMatch[1] || '',\n            lineNumber: parseInt(anonMatch[2] || '0', 10),\n            columnNumber: parseInt(anonMatch[3] || '0', 10),\n            raw: line,\n        };\n    }\n    return null;\n}\n/**\n * Extract sourceMappingURL from script content\n */\nexport function extractSourceMapUrl(content) {\n    const regex = /\\/\\/[#@]\\s*sourceMappingURL=(.+?)(?:\\s|$)/;\n    const match = content.match(regex);\n    return match && match[1] ? match[1].trim() : null;\n}\n/**\n * Parse source map data into a usable format\n */\nexport function parseSourceMapData(sourceMap) {\n    const mappings = parseMappings(sourceMap.mappings || '');\n    return {\n        sources: sourceMap.sources || [],\n        names: sourceMap.names || [],\n        sourceRoot: sourceMap.sourceRoot || '',\n        mappings,\n        sourcesContent: sourceMap.sourcesContent || [],\n    };\n}\n/**\n * Find original location from source map\n */\nexport function findOriginalLocation(sourceMap, line, column) {\n    if (!sourceMap || !sourceMap.mappings)\n        return null;\n    const lineIndex = line - 1;\n    if (lineIndex < 0 || lineIndex >= sourceMap.mappings.length)\n        return null;\n    const lineSegments = sourceMap.mappings[lineIndex];\n    if (!lineSegments || lineSegments.length === 0)\n        return null;\n    let genCol = 0;\n    let sourceIndex = 0;\n    let origLine = 0;\n    let origCol = 0;\n    let nameIndex = 0;\n    let bestMatch = null;\n    for (let li = 0; li <= lineIndex; li++) {\n        genCol = 0;\n        const segments = sourceMap.mappings[li];\n        if (!segments)\n            continue;\n        for (const segment of segments) {\n            if (segment.length >= 1)\n                genCol += segment[0];\n            if (segment.length >= 2)\n                sourceIndex += segment[1];\n            if (segment.length >= 3)\n                origLine += segment[2];\n            if (segment.length >= 4)\n                origCol += segment[3];\n            if (segment.length >= 5)\n                nameIndex += segment[4];\n            if (li === lineIndex && genCol <= column) {\n                bestMatch = {\n                    source: sourceMap.sources[sourceIndex] || '',\n                    line: origLine + 1,\n                    column: origCol,\n                    name: segment.length >= 5 ? sourceMap.names[nameIndex] || null : null,\n                };\n            }\n        }\n    }\n    return bestMatch;\n}\n/**\n * Fetch a source map for a script URL\n */\nexport async function fetchSourceMap(scriptUrl, debugLogFn) {\n    if (getSourceMapCacheEntry(scriptUrl)) {\n        return getSourceMapCacheEntry(scriptUrl) || null;\n    }\n    try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), SOURCE_MAP_FETCH_TIMEOUT);\n        const scriptResponse = await fetch(scriptUrl, { signal: controller.signal });\n        clearTimeout(timeoutId);\n        if (!scriptResponse.ok) {\n            setSourceMapCacheEntry(scriptUrl, null);\n            return null;\n        }\n        const scriptContent = await scriptResponse.text();\n        let sourceMapUrl = extractSourceMapUrl(scriptContent);\n        if (!sourceMapUrl) {\n            setSourceMapCacheEntry(scriptUrl, null);\n            return null;\n        }\n        if (sourceMapUrl.startsWith('data:')) {\n            const base64Match = sourceMapUrl.match(/^data:application\\/json;base64,(.+)$/);\n            if (base64Match && base64Match[1]) {\n                let jsonStr;\n                try {\n                    jsonStr = atob(base64Match[1]);\n                }\n                catch {\n                    if (debugLogFn)\n                        debugLogFn('sourcemap', 'Invalid base64 in inline source map', { scriptUrl });\n                    setSourceMapCacheEntry(scriptUrl, null);\n                    return null;\n                }\n                let sourceMap;\n                try {\n                    sourceMap = JSON.parse(jsonStr);\n                }\n                catch {\n                    if (debugLogFn)\n                        debugLogFn('sourcemap', 'Invalid JSON in inline source map', { scriptUrl });\n                    setSourceMapCacheEntry(scriptUrl, null);\n                    return null;\n                }\n                const parsed = parseSourceMapData(sourceMap);\n                setSourceMapCacheEntry(scriptUrl, parsed);\n                return parsed;\n            }\n            setSourceMapCacheEntry(scriptUrl, null);\n            return null;\n        }\n        if (!sourceMapUrl.startsWith('http')) {\n            const base = scriptUrl.substring(0, scriptUrl.lastIndexOf('/') + 1);\n            sourceMapUrl = new URL(sourceMapUrl, base).href;\n        }\n        const mapController = new AbortController();\n        const mapTimeoutId = setTimeout(() => mapController.abort(), SOURCE_MAP_FETCH_TIMEOUT);\n        const mapResponse = await fetch(sourceMapUrl, { signal: mapController.signal });\n        clearTimeout(mapTimeoutId);\n        if (!mapResponse.ok) {\n            setSourceMapCacheEntry(scriptUrl, null);\n            return null;\n        }\n        let sourceMap;\n        try {\n            sourceMap = await mapResponse.json();\n        }\n        catch {\n            if (debugLogFn)\n                debugLogFn('sourcemap', 'Invalid JSON in external source map', { scriptUrl, sourceMapUrl });\n            setSourceMapCacheEntry(scriptUrl, null);\n            return null;\n        }\n        const parsed = parseSourceMapData(sourceMap);\n        setSourceMapCacheEntry(scriptUrl, parsed);\n        return parsed;\n    }\n    catch (err) {\n        if (debugLogFn) {\n            debugLogFn('sourcemap', 'Source map fetch failed', {\n                scriptUrl,\n                error: err.message,\n            });\n        }\n        setSourceMapCacheEntry(scriptUrl, null);\n        return null;\n    }\n}\n/**\n * Resolve a single stack frame to original location\n */\nexport async function resolveStackFrame(frame, debugLogFn) {\n    if (!frame.fileName || !frame.fileName.startsWith('http')) {\n        return frame;\n    }\n    const sourceMap = await fetchSourceMap(frame.fileName, debugLogFn);\n    if (!sourceMap) {\n        return frame;\n    }\n    const original = findOriginalLocation(sourceMap, frame.lineNumber, frame.columnNumber);\n    if (!original) {\n        return frame;\n    }\n    return {\n        ...frame,\n        originalFileName: original.source,\n        originalLineNumber: original.line,\n        originalColumnNumber: original.column,\n        originalFunctionName: original.name || frame.functionName,\n        resolved: true,\n    };\n}\n/**\n * Resolve an entire stack trace\n */\nexport async function resolveStackTrace(stack, debugLogFn) {\n    if (!stack || !isSourceMapEnabled())\n        return stack;\n    const lines = stack.split('\\n');\n    const resolvedLines = [];\n    for (const line of lines) {\n        const frame = parseStackFrame(line);\n        if (!frame) {\n            resolvedLines.push(line);\n            continue;\n        }\n        try {\n            const resolved = await resolveStackFrame(frame, debugLogFn);\n            if (resolved.resolved) {\n                const funcName = resolved.originalFunctionName || resolved.functionName;\n                const fileName = resolved.originalFileName;\n                const lineNum = resolved.originalLineNumber;\n                const colNum = resolved.originalColumnNumber;\n                resolvedLines.push(`    at ${funcName} (${fileName}:${lineNum}:${colNum}) [resolved from ${resolved.fileName}:${resolved.lineNumber}:${resolved.columnNumber}]`);\n            }\n            else {\n                resolvedLines.push(line);\n            }\n        }\n        catch {\n            resolvedLines.push(line);\n        }\n    }\n    return resolvedLines.join('\\n');\n}\n// =============================================================================\n// PROCESSING QUERY TRACKING\n// =============================================================================\n/**\n * Get current state of processing queries (for testing)\n */\nexport function getProcessingQueriesState() {\n    return processingQueries;\n}\n/**\n * Add a query to the processing set with timestamp\n */\nexport function addProcessingQuery(queryId, timestamp = Date.now()) {\n    processingQueries.set(queryId, timestamp);\n}\n/**\n * Remove a query from the processing set\n */\nexport function removeProcessingQuery(queryId) {\n    processingQueries.delete(queryId);\n}\n/**\n * Check if a query is currently being processed\n */\nexport function isQueryProcessing(queryId) {\n    return processingQueries.has(queryId);\n}\n/**\n * Clean up stale processing queries that have exceeded the TTL\n */\nexport function cleanupStaleProcessingQueries(debugLogFn) {\n    const now = Date.now();\n    for (const [queryId, timestamp] of processingQueries) {\n        if (now - timestamp > PROCESSING_QUERY_TTL_MS) {\n            processingQueries.delete(queryId);\n            if (debugLogFn) {\n                debugLogFn('connection', 'Cleaned up stale processing query', {\n                    queryId,\n                    age: Math.round((now - timestamp) / 1000) + 's',\n                });\n            }\n        }\n    }\n}\n//# sourceMappingURL=snapshots.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/snapshots.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/state-manager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/storage-utils.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":71,"column":18,"nodeType":"MemberExpression","endLine":71,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":138,"column":18,"nodeType":"MemberExpression","endLine":138,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Storage Utilities - Wrapper functions for chrome.storage with support for both\n * persistent (local) and ephemeral (session) storage.\n *\n * Usage:\n * - Ephemeral state (resets on service worker restart): use session storage\n *   * trackedTabId, trackedTabUrl\n *   * debugMode (user preference is persistent, but cache resets on restart)\n *   * aiWebPilotEnabled cache\n *\n * - Persistent state (survives browser restart): use local storage\n *   * serverUrl (user setting)\n *   * logLevel (user preference)\n *   * screenshotOnError (user preference)\n *   * sourceMapEnabled (user preference)\n *   * state snapshots\n *\n * Note: chrome.storage.session only available in Chrome 102+\n * This module handles graceful degradation for older versions\n */\n// =============================================================================\n// FEATURE DETECTION\n// =============================================================================\n/**\n * Type-safe access to chrome.storage with session storage support\n * Chrome.storage.session is only available in Chrome 102+\n */\nfunction getStorageWithSession() {\n    if (typeof chrome === 'undefined' || !chrome.storage)\n        return null;\n    return chrome.storage;\n}\n/**\n * Check if chrome.storage.session is available (Chrome 102+)\n */\nfunction isSessionStorageAvailable() {\n    const storage = getStorageWithSession();\n    return storage !== null && storage.session !== undefined;\n}\n// =============================================================================\n// SESSION STORAGE UTILITIES (ephemeral, resets on service worker restart)\n// =============================================================================\n/**\n * Set an ephemeral value in session storage (callback-based)\n * Falls back to memory for older Chrome versions\n */\nexport function setSessionValue(key, value, callback) {\n    const storage = getStorageWithSession();\n    if (!storage || !storage.session) {\n        // Graceful degradation: store in memory (will be lost on service worker restart anyway)\n        if (callback)\n            callback();\n        return;\n    }\n    storage.session.set({ [key]: value }, () => {\n        if (callback)\n            callback();\n    });\n}\n/**\n * Get an ephemeral value from session storage (callback-based)\n * Falls back to undefined for older Chrome versions\n */\nexport function getSessionValue(key, callback) {\n    const storage = getStorageWithSession();\n    if (!storage || !storage.session) {\n        callback(undefined);\n        return;\n    }\n    storage.session.get([key], (result) => {\n        callback(result[key]);\n    });\n}\n/**\n * Remove an ephemeral value from session storage (callback-based)\n */\nexport function removeSessionValue(key, callback) {\n    const storage = getStorageWithSession();\n    if (!storage || !storage.session) {\n        if (callback)\n            callback();\n        return;\n    }\n    storage.session.remove([key], () => {\n        if (callback)\n            callback();\n    });\n}\n/**\n * Clear all ephemeral values from session storage (callback-based)\n */\nexport function clearSessionStorage(callback) {\n    const storage = getStorageWithSession();\n    if (!storage || !storage.session) {\n        if (callback)\n            callback();\n        return;\n    }\n    storage.session.clear(() => {\n        if (callback)\n            callback();\n    });\n}\n// =============================================================================\n// LOCAL STORAGE UTILITIES (persistent, survives browser restart)\n// =============================================================================\n/**\n * Set a persistent value in local storage (callback-based)\n */\nexport function setLocalValue(key, value, callback) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        if (callback)\n            callback();\n        return;\n    }\n    chrome.storage.local.set({ [key]: value }, () => {\n        if (chrome.runtime.lastError) {\n            console.warn(`[Gasoline] Storage error for key ${key}:`, chrome.runtime.lastError.message);\n        }\n        if (callback)\n            callback();\n    });\n}\n/**\n * Get a persistent value from local storage (callback-based)\n */\nexport function getLocalValue(key, callback) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        callback(undefined);\n        return;\n    }\n    chrome.storage.local.get([key], (result) => {\n        if (chrome.runtime.lastError) {\n            console.warn(`[Gasoline] Storage error for key ${key}:`, chrome.runtime.lastError.message);\n            callback(undefined);\n            return;\n        }\n        callback(result[key]);\n    });\n}\n/**\n * Remove a persistent value from local storage (callback-based)\n */\nexport function removeLocalValue(key, callback) {\n    if (typeof chrome === 'undefined' || !chrome.storage) {\n        if (callback)\n            callback();\n        return;\n    }\n    chrome.storage.local.remove([key], () => {\n        if (callback)\n            callback();\n    });\n}\n// =============================================================================\n// FACADE FUNCTIONS - Choose storage area automatically\n// =============================================================================\n/**\n * Set a value in the appropriate storage area (callback-based)\n * For ephemeral data, prefers session storage (Chrome 102+), falls back to memory\n * For persistent data, uses local storage\n */\nexport function setValue(key, value, areaName, callback) {\n    const area = areaName || 'session';\n    if (area === 'session') {\n        setSessionValue(key, value, callback);\n    }\n    else if (area === 'local') {\n        setLocalValue(key, value, callback);\n    }\n    else {\n        if (callback)\n            callback();\n    }\n}\n/**\n * Get a value from the appropriate storage area (callback-based)\n */\nexport function getValue(key, areaName, callback) {\n    const area = areaName || 'session';\n    if (area === 'session') {\n        getSessionValue(key, callback);\n    }\n    else if (area === 'local') {\n        getLocalValue(key, callback);\n    }\n    else {\n        callback(undefined);\n    }\n}\n/**\n * Remove a value from the appropriate storage area (callback-based)\n */\nexport function removeValue(key, areaName, callback) {\n    const area = areaName || 'session';\n    if (area === 'session') {\n        removeSessionValue(key, callback);\n    }\n    else if (area === 'local') {\n        removeLocalValue(key, callback);\n    }\n    else {\n        if (callback)\n            callback();\n    }\n}\n// =============================================================================\n// STATE RECOVERY & DIAGNOSTICS\n// =============================================================================\n/**\n * Get diagnostic info about storage availability\n */\nexport function getStorageDiagnostics() {\n    return {\n        sessionStorageAvailable: isSessionStorageAvailable(),\n        localStorageAvailable: typeof chrome !== 'undefined' && !!chrome.storage?.local,\n        browserVersion: navigator.userAgent,\n    };\n}\n/**\n * State version key for recovery detection\n */\nconst STATE_VERSION_KEY = 'gasoline_state_version';\nconst CURRENT_STATE_VERSION = '1.0.0';\n/**\n * Check if service worker was restarted (state version mismatch)\n * Returns true if state was lost/cleared (callback-based)\n */\nexport function wasServiceWorkerRestarted(callback) {\n    if (!isSessionStorageAvailable()) {\n        // Can't detect restart without session storage\n        callback(false);\n        return;\n    }\n    getSessionValue(STATE_VERSION_KEY, (storedVersion) => {\n        callback(storedVersion !== CURRENT_STATE_VERSION);\n    });\n}\n/**\n * Mark the current state version (call on init) - callback-based\n */\nexport function markStateVersion(callback) {\n    setSessionValue(STATE_VERSION_KEY, CURRENT_STATE_VERSION, callback);\n}\n//# sourceMappingURL=storage-utils.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/sync-client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/background/version-check.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/favicon-replacer.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":129,"column":39,"nodeType":"MemberExpression","endLine":129,"endColumn":69}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Favicon Replacer - Visual indicator for tracked tabs\n * Replaces the page's favicon with the Gasoline flame icon when tab tracking is enabled.\n * Adds flickering animation when AI Pilot is active.\n */\n/**\n * Original favicon href (to restore when tracking stops)\n */\nlet originalFaviconHref = null;\n/**\n * Interval ID for flicker effect (uses setInterval, not requestAnimationFrame)\n * This ensures animation continues even when tab is hidden (visible in tab bar)\n */\nlet flickerInterval = null;\n/**\n * Initialize favicon replacement.\n * Listens for tracking state changes and updates favicon accordingly.\n */\nexport function initFaviconReplacer() {\n    // Listen for tracking state updates from background\n    chrome.runtime.onMessage.addListener((message, _sender, _sendResponse) => {\n        if (message.type === 'trackingStateChanged') {\n            const newState = message.state;\n            updateFavicon(newState);\n        }\n    });\n    // Request initial tracking state\n    chrome.runtime.sendMessage({ type: 'getTrackingState' }, (response) => {\n        if (response && response.state) {\n            updateFavicon(response.state);\n        }\n    });\n}\n/**\n * Update favicon based on tracking state.\n * - Not tracked: Shows original favicon\n * - Tracked (AI Pilot off): Shows static glowing flame\n * - Tracked (AI Pilot on): Shows flickering flame\n */\nfunction updateFavicon(state) {\n    if (!state.isTracked) {\n        // Restore original favicon\n        restoreOriginalFavicon();\n        stopFlicker();\n    }\n    else if (state.aiPilotEnabled) {\n        // Tracked + AI Pilot on = flickering flame\n        replaceFaviconWithFlame(true);\n        startFlicker();\n    }\n    else {\n        // Tracked only = static glowing flame\n        replaceFaviconWithFlame(false);\n        stopFlicker();\n    }\n}\n/**\n * Save original favicon and replace with Gasoline flame.\n */\nfunction replaceFaviconWithFlame(withGlow) {\n    // Save original favicon (only once)\n    if (!originalFaviconHref) {\n        const existingLink = document.querySelector('link[rel*=\"icon\"]');\n        originalFaviconHref = existingLink?.href || '';\n    }\n    // Remove existing favicons\n    const existingIcons = document.querySelectorAll('link[rel*=\"icon\"]');\n    existingIcons.forEach((icon) => icon.remove());\n    // Add Gasoline flame favicon\n    const link = document.createElement('link');\n    link.rel = 'icon';\n    link.type = 'image/svg+xml';\n    link.id = 'gasoline-favicon';\n    // Use glow icon if tracking, regular icon if not\n    const iconPath = withGlow ? 'icons/icon-glow.svg' : 'icons/icon.svg';\n    link.href = chrome.runtime.getURL(iconPath);\n    document.head.appendChild(link);\n}\n/**\n * Restore the original page favicon.\n */\nfunction restoreOriginalFavicon() {\n    // Remove Gasoline favicon\n    const gasolineIcon = document.getElementById('gasoline-favicon');\n    if (gasolineIcon) {\n        gasolineIcon.remove();\n    }\n    // Restore original\n    if (originalFaviconHref) {\n        const link = document.createElement('link');\n        link.rel = 'icon';\n        link.href = originalFaviconHref;\n        document.head.appendChild(link);\n    }\n}\n/**\n * Start flicker animation (for AI Pilot active state).\n * Realistic 8-frame flame animation:\n * - Bottom stays anchored (flames grow UPWARD, not scaled from center)\n * - Smaller flames = more orange/red (cooler, 85-92% height) + smaller darker ring\n * - Normal flame = orange-yellow gradient (100% height) + medium orange ring\n * - Larger flames = more yellow/white (hotter, 105-112% height) + larger brighter ring\n * - 150ms per frame = 1.2s full cycle (fast, visible flicker)\n * - Uses setInterval (not requestAnimationFrame) so it's visible in tab bar when tab is hidden\n */\nfunction startFlicker() {\n    if (flickerInterval !== null) {\n        return; // Already flickering\n    }\n    // 8-frame sequence for smooth breathing effect with color temperature shift\n    const flameFrames = [\n        'icon-flicker-1-tiny.svg', // 85% - dark red/orange (coolest) + small dark ring\n        'icon-flicker-2-small.svg', // 92% - orange + small orange ring\n        'icon-flicker-3-normal.svg', // 100% - orange-yellow (base) + medium orange ring\n        'icon-flicker-4-medium.svg', // 105% - yellow + medium yellow ring\n        'icon-flicker-5-large.svg', // 112% - yellow/white (PEAK - hottest) + large bright ring\n        'icon-flicker-6-medium.svg', // 105% - yellow + medium yellow ring (shrinking)\n        'icon-flicker-7-smallmed.svg', // 96% - orange-yellow + medium ring\n        'icon-flicker-8-small.svg', // 92% - orange + small orange ring (back to small)\n    ];\n    let currentFrameIndex = 0;\n    // Use setInterval instead of requestAnimationFrame so animation continues\n    // even when tab is hidden (user can see flicker in browser tab bar)\n    flickerInterval = window.setInterval(() => {\n        currentFrameIndex = (currentFrameIndex + 1) % flameFrames.length;\n        // Update favicon\n        const gasolineIcon = document.getElementById('gasoline-favicon');\n        if (gasolineIcon) {\n            const iconPath = `icons/${flameFrames[currentFrameIndex]}`;\n            gasolineIcon.href = chrome.runtime.getURL(iconPath);\n        }\n    }, 150); // 150ms per frame = 1.2s full cycle (browser-limited, but visible)\n}\n/**\n * Stop flicker animation.\n */\nfunction stopFlicker() {\n    if (flickerInterval !== null) {\n        clearInterval(flickerInterval);\n        flickerInterval = null;\n    }\n}\n//# sourceMappingURL=favicon-replacer.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/message-forwarding.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/message-handlers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/request-tracking.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/runtime-message-listener.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":28,"column":19,"nodeType":"MemberExpression","endLine":28,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Runtime Message Listener Module\n * Handles chrome.runtime messages from background script\n */\nimport { isValidBackgroundSender, handlePing, handleToggleMessage, forwardHighlightMessage, handleStateCommand, handleExecuteJs, handleExecuteQuery, handleA11yQuery, handleDomQuery, handleGetNetworkWaterfall, } from './message-handlers.js';\n/** Color themes for each toast state */\nconst TOAST_THEMES = {\n    trying: { bg: 'linear-gradient(135deg, #ff6b00 0%, #ff9500 100%)', shadow: 'rgba(255, 107, 0, 0.4)' },\n    success: { bg: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', shadow: 'rgba(34, 197, 94, 0.4)' },\n    warning: { bg: 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)', shadow: 'rgba(245, 158, 11, 0.4)' },\n    error: { bg: 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)', shadow: 'rgba(239, 68, 68, 0.4)' },\n};\n/** Truncate text to maxLen characters with ellipsis */\nfunction truncateText(text, maxLen) {\n    if (text.length <= maxLen)\n        return text;\n    return text.slice(0, maxLen - 1) + '\\u2026';\n}\n/**\n * Show a brief visual toast overlay for AI actions.\n * Supports color-coded states and structured content with truncation.\n */\nfunction showActionToast(text, detail, state = 'trying', durationMs = 3000) {\n    // Remove existing toast\n    const existing = document.getElementById('gasoline-action-toast');\n    if (existing)\n        existing.remove();\n    const theme = TOAST_THEMES[state] ?? TOAST_THEMES.trying;\n    const toast = document.createElement('div');\n    toast.id = 'gasoline-action-toast';\n    // Build content: label + truncated detail\n    const label = document.createElement('span');\n    label.textContent = truncateText(text, 30);\n    Object.assign(label.style, { fontWeight: '700' });\n    toast.appendChild(label);\n    if (detail) {\n        const sep = document.createElement('span');\n        sep.textContent = '  ';\n        Object.assign(sep.style, { opacity: '0.6', margin: '0 4px' });\n        toast.appendChild(sep);\n        const det = document.createElement('span');\n        det.textContent = truncateText(detail, 50);\n        Object.assign(det.style, { fontWeight: '400', opacity: '0.9' });\n        toast.appendChild(det);\n    }\n    Object.assign(toast.style, {\n        position: 'fixed',\n        top: '16px',\n        left: '50%',\n        transform: 'translateX(-50%)',\n        padding: '8px 20px',\n        background: theme.bg,\n        color: '#fff',\n        fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n        fontSize: '13px',\n        borderRadius: '8px',\n        boxShadow: `0 4px 20px ${theme.shadow}`,\n        zIndex: '2147483647',\n        pointerEvents: 'none',\n        opacity: '0',\n        transition: 'opacity 0.2s ease-in',\n        maxWidth: '500px',\n        whiteSpace: 'nowrap',\n        overflow: 'hidden',\n        display: 'flex',\n        alignItems: 'center',\n        gap: '0',\n    });\n    const target = document.body || document.documentElement;\n    if (!target)\n        return;\n    target.appendChild(toast);\n    // Fade in\n    requestAnimationFrame(() => {\n        toast.style.opacity = '1';\n    });\n    // Fade out and remove\n    setTimeout(() => {\n        toast.style.opacity = '0';\n        setTimeout(() => toast.remove(), 300);\n    }, durationMs);\n}\n// Toggle state caches — updated by forwarded setting messages from background\nlet actionToastsEnabled = true;\nlet subtitlesEnabled = true;\n/**\n * Show or update a persistent subtitle bar at the bottom of the viewport.\n * Empty text clears the subtitle.\n */\nfunction showSubtitle(text) {\n    const ELEMENT_ID = 'gasoline-subtitle';\n    if (!text) {\n        // Clear: remove existing element\n        const existing = document.getElementById(ELEMENT_ID);\n        if (existing) {\n            existing.style.opacity = '0';\n            setTimeout(() => existing.remove(), 200);\n        }\n        return;\n    }\n    let bar = document.getElementById(ELEMENT_ID);\n    if (!bar) {\n        bar = document.createElement('div');\n        bar.id = ELEMENT_ID;\n        Object.assign(bar.style, {\n            position: 'fixed',\n            bottom: '0',\n            left: '0',\n            width: '100%',\n            padding: '12px 24px',\n            background: 'rgba(0, 0, 0, 0.85)',\n            color: '#fff',\n            fontFamily: '-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif',\n            fontSize: '16px',\n            lineHeight: '1.4',\n            zIndex: '2147483646',\n            pointerEvents: 'none',\n            opacity: '0',\n            transition: 'opacity 0.2s ease-in',\n            maxHeight: '4.2em', // ~3 lines\n            overflow: 'hidden',\n            textOverflow: 'ellipsis',\n            boxSizing: 'border-box',\n        });\n        const target = document.body || document.documentElement;\n        if (!target)\n            return;\n        target.appendChild(bar);\n    }\n    bar.textContent = text;\n    requestAnimationFrame(() => {\n        if (bar)\n            bar.style.opacity = '1';\n    });\n}\n/**\n * Initialize runtime message listener\n * Listens for messages from background (feature toggles and pilot commands)\n */\nexport function initRuntimeMessageListener() {\n    // Load overlay toggle states from storage\n    chrome.storage.local.get(['actionToastsEnabled', 'subtitlesEnabled'], (result) => {\n        if (result.actionToastsEnabled !== undefined)\n            actionToastsEnabled = result.actionToastsEnabled;\n        if (result.subtitlesEnabled !== undefined)\n            subtitlesEnabled = result.subtitlesEnabled;\n    });\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n        // SECURITY: Validate sender is from the extension background, not from page context\n        if (!isValidBackgroundSender(sender)) {\n            console.warn('[Gasoline] Rejected message from untrusted sender:', sender.id);\n            return false;\n        }\n        // Handle ping to check if content script is loaded\n        if (message.type === 'GASOLINE_PING') {\n            return handlePing(sendResponse);\n        }\n        // Show AI action toast overlay (gated by toggle)\n        if (message.type === 'GASOLINE_ACTION_TOAST') {\n            if (!actionToastsEnabled)\n                return false;\n            const msg = message;\n            if (msg.text)\n                showActionToast(msg.text, msg.detail, msg.state || 'trying', msg.duration_ms);\n            return false;\n        }\n        // Show subtitle overlay (gated by toggle)\n        if (message.type === 'GASOLINE_SUBTITLE') {\n            if (!subtitlesEnabled)\n                return false;\n            const msg = message;\n            showSubtitle(msg.text ?? '');\n            return false;\n        }\n        // Handle overlay toggle updates from background\n        if (message.type === 'setActionToastsEnabled') {\n            actionToastsEnabled = message.enabled;\n            return false;\n        }\n        if (message.type === 'setSubtitlesEnabled') {\n            subtitlesEnabled = message.enabled;\n            return false;\n        }\n        // Handle toggle messages\n        handleToggleMessage(message);\n        // Handle GASOLINE_HIGHLIGHT from background\n        if (message.type === 'GASOLINE_HIGHLIGHT') {\n            forwardHighlightMessage(message)\n                .then((result) => {\n                sendResponse(result);\n            })\n                .catch((err) => {\n                sendResponse({ success: false, error: err.message });\n            });\n            return true; // Will respond asynchronously\n        }\n        // Handle state management commands from background\n        if (message.type === 'GASOLINE_MANAGE_STATE') {\n            // message.params contains action, state, include_url from the manage_state tool\n            // handleStateCommand accepts params with optional action (StateAction), name, state, include_url\n            handleStateCommand(message.params)\n                .then((result) => sendResponse(result))\n                .catch((err) => sendResponse({ error: err.message }));\n            return true; // Keep channel open for async response\n        }\n        // Handle GASOLINE_EXECUTE_JS from background (direct pilot command)\n        if (message.type === 'GASOLINE_EXECUTE_JS') {\n            const params = message.params || {};\n            return handleExecuteJs(params, sendResponse);\n        }\n        // Handle GASOLINE_EXECUTE_QUERY from background (polling system)\n        if (message.type === 'GASOLINE_EXECUTE_QUERY') {\n            return handleExecuteQuery(message.params || {}, sendResponse);\n        }\n        // Handle A11Y_QUERY from background (run accessibility audit in page context)\n        if (message.type === 'A11Y_QUERY') {\n            return handleA11yQuery(message.params || {}, sendResponse);\n        }\n        // Handle DOM_QUERY from background (execute CSS selector query in page context)\n        if (message.type === 'DOM_QUERY') {\n            return handleDomQuery(message.params || {}, sendResponse);\n        }\n        // Handle GET_NETWORK_WATERFALL from background (collect PerformanceResourceTiming data)\n        if (message.type === 'GET_NETWORK_WATERFALL') {\n            return handleGetNetworkWaterfall(sendResponse);\n        }\n        return undefined;\n    });\n}\n//# sourceMappingURL=runtime-message-listener.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/script-injection.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/tab-tracking.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/timeout-utils.js","messages":[{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":30,"column":40,"nodeType":"CallExpression","messageId":"returnsValue","endLine":38,"endColumn":26,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[972,1354],"text":"{setTimeout(() => {\n                cleanup?.();\n                if (timeoutFallback !== undefined) {\n                    reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, timeoutFallback));\n                }\n                else {\n                    reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n                }\n            }, timeoutMs)}"},"desc":"Wrap the expression in `{}`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Timeout Utilities for Content Script\n * Inlined utilities for promise timeout handling\n * Content scripts cannot use ES module imports, so these utilities are duplicated\n */\n/** Custom error for timeout operations */\nexport class TimeoutError extends Error {\n    fallback;\n    constructor(message, fallback) {\n        super(message);\n        this.fallback = fallback;\n        this.name = 'TimeoutError';\n    }\n}\n/** Create a deferred promise for external resolution */\nexport function createDeferredPromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n/** Race a promise against a timeout with cleanup on timeout */\nexport async function promiseRaceWithCleanup(promise, timeoutMs, timeoutFallback, cleanup) {\n    try {\n        return await Promise.race([\n            promise,\n            new Promise((_, reject) => setTimeout(() => {\n                cleanup?.();\n                if (timeoutFallback !== undefined) {\n                    reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`, timeoutFallback));\n                }\n                else {\n                    reject(new TimeoutError(`Operation timed out after ${timeoutMs}ms`));\n                }\n            }, timeoutMs)),\n        ]);\n    }\n    catch (err) {\n        if (err instanceof TimeoutError && err.fallback !== undefined) {\n            return err.fallback;\n        }\n        throw err;\n    }\n}\n//# sourceMappingURL=timeout-utils.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/content/window-message-listener.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":54,"column":32,"nodeType":"MemberExpression","endLine":54,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Window Message Listener Module\n * Handles window.postMessage events from inject.js\n */\nimport { resolveHighlightRequest, resolveExecuteRequest, resolveA11yRequest, resolveDomRequest, } from './request-tracking.js';\nimport { MESSAGE_MAP, safeSendMessage } from './message-forwarding.js';\nimport { getIsTrackedTab, getCurrentTabId } from './tab-tracking.js';\n/**\n * Initialize consolidated window message listener\n * Handles all messages from inject.js\n */\nexport function initWindowMessageListener() {\n    window.addEventListener('message', (event) => {\n        // Only accept messages from this window\n        if (event.source !== window)\n            return;\n        const { type: messageType, requestId, result, payload } = event.data || {};\n        // Handle highlight responses\n        if (messageType === 'GASOLINE_HIGHLIGHT_RESPONSE') {\n            if (requestId !== undefined) {\n                resolveHighlightRequest(requestId, result);\n            }\n            return;\n        }\n        // Handle execute JS results\n        if (messageType === 'GASOLINE_EXECUTE_JS_RESULT') {\n            if (requestId !== undefined) {\n                resolveExecuteRequest(requestId, result);\n            }\n            return;\n        }\n        // Handle a11y audit results from inject.js\n        if (messageType === 'GASOLINE_A11Y_QUERY_RESPONSE') {\n            if (requestId !== undefined) {\n                resolveA11yRequest(requestId, result);\n            }\n            return;\n        }\n        // Handle DOM query results from inject.js\n        if (messageType === 'GASOLINE_DOM_QUERY_RESPONSE') {\n            if (requestId !== undefined) {\n                resolveDomRequest(requestId, result);\n            }\n            return;\n        }\n        // Tab isolation filter: only forward captured data from the tracked tab.\n        // Response messages (highlight, execute JS, a11y) are NOT filtered because\n        // they are responses to explicit commands from the background script.\n        if (!getIsTrackedTab()) {\n            return; // Drop captured data from untracked tabs\n        }\n        // Handle MESSAGE_MAP forwarding - attach tabId to every message\n        if (messageType && messageType in MESSAGE_MAP && payload && typeof payload === 'object') {\n            const mappedType = MESSAGE_MAP[messageType];\n            if (mappedType) {\n                safeSendMessage({\n                    type: mappedType,\n                    payload,\n                    tabId: getCurrentTabId(),\n                });\n            }\n        }\n    });\n}\n//# sourceMappingURL=window-message-listener.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/early-patch.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/inject.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/inject/api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/inject/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/inject/message-handlers.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":75,"column":17,"nodeType":"MemberExpression","endLine":75,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":75,"column":55,"nodeType":"MemberExpression","endLine":75,"endColumn":63},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":78,"column":17,"nodeType":"MemberExpression","endLine":78,"endColumn":28}],"suppressedMessages":[{"ruleId":"no-new-func","severity":2,"message":"The Function constructor is eval.","line":119,"column":24,"nodeType":"NewExpression","messageId":"noFunctionConstructor","endLine":119,"endColumn":44,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Message Handlers - Handles messages from content script including\n * settings, state management, JavaScript execution, and DOM/accessibility queries.\n */\nimport { createDeferredPromise } from '../lib/timeout-utils.js';\nimport { executeDOMQuery, runAxeAuditWithTimeout } from '../lib/dom-queries.js';\nimport { getNetworkWaterfall, setNetworkWaterfallEnabled, setNetworkBodyCaptureEnabled, setServerUrl, } from '../lib/network.js';\nimport { setPerformanceMarksEnabled, installPerformanceCapture, uninstallPerformanceCapture } from '../lib/performance.js';\nimport { setActionCaptureEnabled } from '../lib/actions.js';\nimport { setWebSocketCaptureEnabled, setWebSocketCaptureMode, installWebSocketCapture, uninstallWebSocketCapture, } from '../lib/websocket.js';\nimport { setPerformanceSnapshotEnabled } from '../lib/perf-snapshot.js';\nimport { setDeferralEnabled } from './observers.js';\n/**\n * Valid setting names from content script\n */\nconst VALID_SETTINGS = new Set([\n    'setNetworkWaterfallEnabled',\n    'setPerformanceMarksEnabled',\n    'setActionReplayEnabled',\n    'setWebSocketCaptureEnabled',\n    'setWebSocketCaptureMode',\n    'setPerformanceSnapshotEnabled',\n    'setDeferralEnabled',\n    'setNetworkBodyCaptureEnabled',\n    'setServerUrl',\n]);\nconst VALID_STATE_ACTIONS = new Set(['capture', 'restore']);\n/**\n * Safe serialization for complex objects returned from executeJavaScript.\n */\nexport function safeSerializeForExecute(value, depth = 0, seen = new WeakSet()) {\n    if (depth > 10)\n        return '[max depth exceeded]';\n    if (value === null)\n        return null;\n    if (value === undefined)\n        return undefined;\n    const type = typeof value;\n    if (type === 'string' || type === 'number' || type === 'boolean') {\n        return value;\n    }\n    if (type === 'function') {\n        return `[Function: ${value.name || 'anonymous'}]`;\n    }\n    if (type === 'symbol') {\n        return value.toString();\n    }\n    if (type === 'object') {\n        const obj = value;\n        if (seen.has(obj))\n            return '[Circular]';\n        seen.add(obj);\n        if (Array.isArray(obj)) {\n            return obj.slice(0, 100).map((v) => safeSerializeForExecute(v, depth + 1, seen));\n        }\n        if (obj instanceof Error) {\n            return { error: obj.message, stack: obj.stack };\n        }\n        if (obj instanceof Date) {\n            return obj.toISOString();\n        }\n        if (obj instanceof RegExp) {\n            return obj.toString();\n        }\n        // DOM nodes\n        if (typeof Node !== 'undefined' && obj instanceof Node) {\n            const node = obj;\n            return `[${node.nodeName}${node.id ? '#' + node.id : ''}]`;\n        }\n        // Plain objects\n        const result = {};\n        const keys = Object.keys(obj).slice(0, 50);\n        for (const key of keys) {\n            try {\n                result[key] = safeSerializeForExecute(obj[key], depth + 1, seen);\n            }\n            catch {\n                result[key] = '[unserializable]';\n            }\n        }\n        if (Object.keys(obj).length > 50) {\n            result['...'] = `[${Object.keys(obj).length - 50} more keys]`;\n        }\n        return result;\n    }\n    return String(value);\n}\n/**\n * Execute arbitrary JavaScript in the page context with timeout handling.\n */\nexport function executeJavaScript(script, timeoutMs = 5000) {\n    const deferred = createDeferredPromise();\n    const executeWithTimeoutProtection = async () => {\n        const timeoutHandle = setTimeout(() => {\n            deferred.resolve({\n                success: false,\n                error: 'execution_timeout',\n                message: `Script exceeded ${timeoutMs}ms timeout. RECOMMENDED ACTIONS:\n\n1. Check for infinite loops or blocking operations in your script\n2. Break the task into smaller pieces (< 2s execution time works best)\n3. Verify the script logic - test with simpler operations first\n\nTip: Run small test scripts to isolate the issue, then build up complexity.`,\n            });\n        }, timeoutMs);\n        try {\n            const cleanScript = script.trim();\n            const hasMultipleStatements = cleanScript.includes(';');\n            const hasExplicitReturn = /\\breturn\\b/.test(cleanScript);\n            let fnBody;\n            if (hasMultipleStatements || hasExplicitReturn) {\n                fnBody = `\"use strict\"; ${cleanScript}`;\n            }\n            else {\n                fnBody = `\"use strict\"; return (${cleanScript});`;\n            }\n            // eslint-disable-next-line no-new-func\n            const fn = new Function(fnBody);\n            const result = fn();\n            // Handle promises\n            if (result && typeof result.then === 'function') {\n                ;\n                result\n                    .then((value) => {\n                    clearTimeout(timeoutHandle);\n                    deferred.resolve({ success: true, result: safeSerializeForExecute(value) });\n                })\n                    .catch((err) => {\n                    clearTimeout(timeoutHandle);\n                    deferred.resolve({\n                        success: false,\n                        error: 'promise_rejected',\n                        message: err.message,\n                        stack: err.stack,\n                    });\n                });\n            }\n            else {\n                clearTimeout(timeoutHandle);\n                deferred.resolve({ success: true, result: safeSerializeForExecute(result) });\n            }\n        }\n        catch (err) {\n            clearTimeout(timeoutHandle);\n            const error = err;\n            if (error.message &&\n                (error.message.includes('Content Security Policy') ||\n                    error.message.includes('unsafe-eval') ||\n                    error.message.includes('Trusted Type'))) {\n                deferred.resolve({\n                    success: false,\n                    error: 'csp_blocked',\n                    message: 'This page has a Content Security Policy that blocks script execution in the MAIN world. ' +\n                        'Use world: \"isolated\" to bypass CSP (DOM access only, no page JS globals). ' +\n                        'With world: \"auto\" (default), this fallback happens automatically.',\n                });\n            }\n            else {\n                deferred.resolve({\n                    success: false,\n                    error: 'execution_error',\n                    message: error.message,\n                    stack: error.stack,\n                });\n            }\n        }\n    };\n    executeWithTimeoutProtection().catch((err) => {\n        console.error('[Gasoline] Unexpected error in executeJavaScript:', err);\n        deferred.resolve({\n            success: false,\n            error: 'execution_error',\n            message: 'Unexpected error during script execution',\n        });\n    });\n    return deferred.promise;\n}\n/**\n * Install message listener for handling content script messages\n */\nexport function installMessageListener(captureStateFn, restoreStateFn) {\n    if (typeof window === 'undefined')\n        return;\n    window.addEventListener('message', (event) => {\n        // Only accept messages from this window\n        if (event.source !== window)\n            return;\n        // Handle settings messages from content script\n        if (event.data?.type === 'GASOLINE_SETTING') {\n            const data = event.data;\n            // Validate setting name\n            if (!VALID_SETTINGS.has(data.setting)) {\n                console.warn('[Gasoline] Invalid setting:', data.setting);\n                return;\n            }\n            // Validate parameter types based on setting\n            if (data.setting === 'setWebSocketCaptureMode') {\n                if (typeof data.mode !== 'string') {\n                    console.warn('[Gasoline] Invalid mode type for setWebSocketCaptureMode');\n                    return;\n                }\n            }\n            else if (data.setting === 'setServerUrl') {\n                if (typeof data.url !== 'string') {\n                    console.warn('[Gasoline] Invalid url type for setServerUrl');\n                    return;\n                }\n            }\n            else {\n                // Boolean settings\n                if (typeof data.enabled !== 'boolean') {\n                    console.warn('[Gasoline] Invalid enabled value type');\n                    return;\n                }\n            }\n            handleSetting(data);\n        }\n        // Handle state management commands from content script\n        if (event.data?.type === 'GASOLINE_STATE_COMMAND') {\n            const data = event.data;\n            handleStateCommand(data, captureStateFn, restoreStateFn);\n        }\n        // Handle GASOLINE_EXECUTE_JS from content script\n        if (event.data?.type === 'GASOLINE_EXECUTE_JS') {\n            handleExecuteJs(event.data);\n        }\n        // Handle GASOLINE_A11Y_QUERY from content script\n        if (event.data?.type === 'GASOLINE_A11Y_QUERY') {\n            handleA11yQuery(event.data);\n        }\n        // Handle GASOLINE_DOM_QUERY from content script\n        if (event.data?.type === 'GASOLINE_DOM_QUERY') {\n            handleDomQuery(event.data);\n        }\n        // Handle GASOLINE_GET_WATERFALL from content script\n        if (event.data?.type === 'GASOLINE_GET_WATERFALL') {\n            handleGetWaterfall(event.data);\n        }\n    });\n}\nfunction handleSetting(data) {\n    switch (data.setting) {\n        case 'setNetworkWaterfallEnabled':\n            setNetworkWaterfallEnabled(data.enabled);\n            break;\n        case 'setPerformanceMarksEnabled':\n            setPerformanceMarksEnabled(data.enabled);\n            if (data.enabled) {\n                installPerformanceCapture();\n            }\n            else {\n                uninstallPerformanceCapture();\n            }\n            break;\n        case 'setActionReplayEnabled':\n            setActionCaptureEnabled(data.enabled);\n            break;\n        case 'setWebSocketCaptureEnabled':\n            setWebSocketCaptureEnabled(data.enabled);\n            if (data.enabled) {\n                installWebSocketCapture();\n            }\n            else {\n                uninstallWebSocketCapture();\n            }\n            break;\n        case 'setWebSocketCaptureMode':\n            setWebSocketCaptureMode((data.mode || 'medium'));\n            break;\n        case 'setPerformanceSnapshotEnabled':\n            setPerformanceSnapshotEnabled(data.enabled);\n            break;\n        case 'setDeferralEnabled':\n            setDeferralEnabled(data.enabled);\n            break;\n        case 'setNetworkBodyCaptureEnabled':\n            setNetworkBodyCaptureEnabled(data.enabled);\n            break;\n        case 'setServerUrl':\n            setServerUrl(data.url);\n            break;\n    }\n}\nfunction handleStateCommand(data, captureStateFn, restoreStateFn) {\n    const { messageId, action, state } = data;\n    // Validate action\n    if (!VALID_STATE_ACTIONS.has(action)) {\n        console.warn('[Gasoline] Invalid state action:', action);\n        window.postMessage({\n            type: 'GASOLINE_STATE_RESPONSE',\n            messageId,\n            result: { error: `Invalid action: ${action}` },\n        }, window.location.origin);\n        return;\n    }\n    // Validate state object for restore action\n    if (action === 'restore' && (!state || typeof state !== 'object')) {\n        console.warn('[Gasoline] Invalid state object for restore');\n        window.postMessage({\n            type: 'GASOLINE_STATE_RESPONSE',\n            messageId,\n            result: { error: 'Invalid state object' },\n        }, window.location.origin);\n        return;\n    }\n    let result;\n    try {\n        if (action === 'capture') {\n            result = captureStateFn();\n        }\n        else if (action === 'restore') {\n            const includeUrl = data.include_url !== false;\n            result = restoreStateFn(state, includeUrl);\n        }\n        else {\n            result = { error: `Unknown action: ${action}` };\n        }\n    }\n    catch (err) {\n        result = { error: err.message };\n    }\n    // Send response back to content script\n    window.postMessage({\n        type: 'GASOLINE_STATE_RESPONSE',\n        messageId,\n        result,\n    }, window.location.origin);\n}\nfunction handleExecuteJs(data) {\n    const { requestId, script, timeoutMs } = data;\n    // Validate parameters\n    if (typeof script !== 'string') {\n        console.warn('[Gasoline] Script must be a string');\n        window.postMessage({\n            type: 'GASOLINE_EXECUTE_JS_RESULT',\n            requestId,\n            result: { success: false, error: 'invalid_script', message: 'Script must be a string' },\n        }, window.location.origin);\n        return;\n    }\n    if (typeof requestId !== 'number' && typeof requestId !== 'string') {\n        console.warn('[Gasoline] Invalid requestId type');\n        return;\n    }\n    executeJavaScript(script, timeoutMs)\n        .then((result) => {\n        window.postMessage({\n            type: 'GASOLINE_EXECUTE_JS_RESULT',\n            requestId,\n            result,\n        }, window.location.origin);\n    })\n        .catch((err) => {\n        console.error('[Gasoline] Failed to execute JS:', err);\n        window.postMessage({\n            type: 'GASOLINE_EXECUTE_JS_RESULT',\n            requestId,\n            result: { success: false, error: 'execution_failed', message: err.message },\n        }, window.location.origin);\n    });\n}\nfunction handleA11yQuery(data) {\n    const { requestId, params } = data;\n    if (typeof runAxeAuditWithTimeout !== 'function') {\n        window.postMessage({\n            type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n            requestId,\n            result: {\n                error: 'runAxeAuditWithTimeout not available - try reloading the extension',\n            },\n        }, window.location.origin);\n        return;\n    }\n    try {\n        runAxeAuditWithTimeout(params || {})\n            .then((result) => {\n            window.postMessage({\n                type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n                requestId,\n                result,\n            }, window.location.origin);\n        })\n            .catch((err) => {\n            console.error('[Gasoline] Accessibility audit error:', err);\n            window.postMessage({\n                type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n                requestId,\n                result: { error: err.message || 'Accessibility audit failed' },\n            }, window.location.origin);\n        });\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to run accessibility audit:', err);\n        window.postMessage({\n            type: 'GASOLINE_A11Y_QUERY_RESPONSE',\n            requestId,\n            result: { error: err.message || 'Failed to run accessibility audit' },\n        }, window.location.origin);\n    }\n}\nfunction handleDomQuery(data) {\n    const { requestId, params } = data;\n    if (typeof executeDOMQuery !== 'function') {\n        window.postMessage({\n            type: 'GASOLINE_DOM_QUERY_RESPONSE',\n            requestId,\n            result: {\n                error: 'executeDOMQuery not available - try reloading the extension',\n            },\n        }, window.location.origin);\n        return;\n    }\n    try {\n        executeDOMQuery((params || {}))\n            .then((result) => {\n            window.postMessage({\n                type: 'GASOLINE_DOM_QUERY_RESPONSE',\n                requestId,\n                result,\n            }, window.location.origin);\n        })\n            .catch((err) => {\n            console.error('[Gasoline] DOM query error:', err);\n            window.postMessage({\n                type: 'GASOLINE_DOM_QUERY_RESPONSE',\n                requestId,\n                result: { error: err.message || 'DOM query failed' },\n            }, window.location.origin);\n        });\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to run DOM query:', err);\n        window.postMessage({\n            type: 'GASOLINE_DOM_QUERY_RESPONSE',\n            requestId,\n            result: { error: err.message || 'Failed to run DOM query' },\n        }, window.location.origin);\n    }\n}\nfunction handleGetWaterfall(data) {\n    const { requestId } = data;\n    try {\n        const entries = getNetworkWaterfall({});\n        // Convert camelCase WaterfallEntry fields to snake_case for Go daemon\n        const snakeEntries = (entries || []).map((e) => ({\n            url: e.url,\n            name: e.url,\n            initiator_type: e.initiatorType,\n            start_time: e.startTime,\n            duration: e.duration,\n            transfer_size: e.transferSize,\n            encoded_body_size: e.encodedBodySize,\n            decoded_body_size: e.decodedBodySize,\n        }));\n        window.postMessage({\n            type: 'GASOLINE_WATERFALL_RESPONSE',\n            requestId,\n            entries: snakeEntries,\n            pageURL: window.location.href,\n        }, window.location.origin);\n    }\n    catch (err) {\n        console.error('[Gasoline] Failed to get network waterfall:', err);\n        window.postMessage({\n            type: 'GASOLINE_WATERFALL_RESPONSE',\n            requestId,\n            entries: [],\n        }, window.location.origin);\n    }\n}\n//# sourceMappingURL=message-handlers.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/inject/observers.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":50,"column":39,"nodeType":"MemberExpression","endLine":50,"endColumn":51},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":52,"column":29,"nodeType":"MemberExpression","endLine":52,"endColumn":45},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":79,"column":35,"nodeType":"MemberExpression","endLine":79,"endColumn":47},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":81,"column":25,"nodeType":"MemberExpression","endLine":81,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Observers - Observer registration and management for DOM, network,\n * performance, and WebSocket events.\n */\nimport { installPerformanceCapture, uninstallPerformanceCapture } from '../lib/performance.js';\nimport { installWebSocketCapture, uninstallWebSocketCapture, } from '../lib/websocket.js';\nimport { wrapFetchWithBodies, } from '../lib/network.js';\nimport { installConsoleCapture, uninstallConsoleCapture } from '../lib/console.js';\nimport { installExceptionCapture, uninstallExceptionCapture } from '../lib/exceptions.js';\nimport { installActionCapture, uninstallActionCapture, installNavigationCapture, uninstallNavigationCapture, } from '../lib/actions.js';\nimport { postLog } from '../lib/bridge.js';\nimport { MAX_RESPONSE_LENGTH, SENSITIVE_HEADERS, MEMORY_SOFT_LIMIT_MB, MEMORY_HARD_LIMIT_MB } from '../lib/constants.js';\n// Store original fetch for restoration\nlet originalFetch = null;\n// Interception deferral state (Phase 1/Phase 2 split)\nlet deferralEnabled = true;\nlet phase2Installed = false;\nlet injectionTimestamp = 0;\nlet phase2Timestamp = 0;\n/**\n * Wrap fetch to capture network errors\n */\nexport function wrapFetch(originalFetchFn) {\n    return async function (input, init) {\n        const startTime = Date.now();\n        const url = typeof input === 'string' ? input : input.url;\n        const method = init?.method || (typeof input === 'object' && 'method' in input ? input.method : 'GET') || 'GET';\n        try {\n            const response = await originalFetchFn(input, init);\n            const duration = Date.now() - startTime;\n            // Capture errors (4xx, 5xx)\n            if (!response.ok) {\n                let responseBody = '';\n                try {\n                    const cloned = response.clone();\n                    responseBody = await cloned.text();\n                    if (responseBody.length > MAX_RESPONSE_LENGTH) {\n                        responseBody = responseBody.slice(0, MAX_RESPONSE_LENGTH) + '... [truncated]';\n                    }\n                }\n                catch {\n                    responseBody = '[Could not read response]';\n                }\n                // Filter sensitive headers (check both init.headers and Request object headers)\n                const safeHeaders = {};\n                const rawHeaders = init?.headers || (typeof input === 'object' && 'headers' in input ? input.headers : null);\n                if (rawHeaders) {\n                    const headers = rawHeaders instanceof Headers ? Object.fromEntries(rawHeaders) : rawHeaders;\n                    Object.keys(headers).forEach((key) => {\n                        const value = headers[key];\n                        if (value && !SENSITIVE_HEADERS.includes(key.toLowerCase())) {\n                            safeHeaders[key] = value;\n                        }\n                    });\n                }\n                const logPayload = {\n                    level: 'error',\n                    type: 'network',\n                    method: method.toUpperCase(),\n                    url,\n                    status: response.status,\n                    statusText: response.statusText,\n                    duration,\n                    response: responseBody,\n                    ...(Object.keys(safeHeaders).length > 0 ? { headers: safeHeaders } : {}),\n                };\n                postLog(logPayload);\n            }\n            return response;\n        }\n        catch (error) {\n            const duration = Date.now() - startTime;\n            // Filter sensitive headers for the error path\n            const safeHeaders = {};\n            const rawHeaders = init?.headers || (typeof input === 'object' && 'headers' in input ? input.headers : null);\n            if (rawHeaders) {\n                const headers = rawHeaders instanceof Headers ? Object.fromEntries(rawHeaders) : rawHeaders;\n                Object.keys(headers).forEach((key) => {\n                    const value = headers[key];\n                    if (value && !SENSITIVE_HEADERS.includes(key.toLowerCase())) {\n                        safeHeaders[key] = value;\n                    }\n                });\n            }\n            const logPayload = {\n                level: 'error',\n                type: 'network',\n                method: method.toUpperCase(),\n                url,\n                error: error.message,\n                duration,\n                ...(Object.keys(safeHeaders).length > 0 ? { headers: safeHeaders } : {}),\n            };\n            postLog(logPayload);\n            throw error;\n        }\n    };\n}\n/**\n * Install fetch capture.\n * Uses wrapFetchWithBodies to capture request/response bodies for all requests,\n * then wraps that with wrapFetch to also capture error details for 4xx/5xx responses.\n */\nexport function installFetchCapture() {\n    originalFetch = window.fetch;\n    // Layer 1: wrapFetchWithBodies captures request/response bodies for ALL requests\n    // Layer 2: wrapFetch captures detailed error logging for 4xx/5xx responses\n    // Use unknown intermediate cast to handle TypeScript's strict fetch overload types\n    // This is necessary because the DOM lib defines fetch with multiple overloads\n    // that TypeScript cannot reconcile with our simpler function signature\n    const wrappedWithBodies = wrapFetchWithBodies(originalFetch);\n    window.fetch = wrapFetch(wrappedWithBodies);\n}\n/**\n * Uninstall fetch capture\n */\nexport function uninstallFetchCapture() {\n    if (originalFetch) {\n        window.fetch = originalFetch;\n        originalFetch = null;\n    }\n}\n/**\n * Install all capture hooks\n */\nexport function install() {\n    installConsoleCapture();\n    installFetchCapture();\n    installExceptionCapture();\n    installActionCapture();\n    installNavigationCapture();\n    installWebSocketCapture();\n    installPerformanceCapture();\n}\n/**\n * Uninstall all capture hooks\n */\nexport function uninstall() {\n    uninstallConsoleCapture();\n    uninstallFetchCapture();\n    uninstallExceptionCapture();\n    uninstallActionCapture();\n    uninstallNavigationCapture();\n    uninstallWebSocketCapture();\n    uninstallPerformanceCapture();\n}\n/**\n * Check if heavy intercepts should be deferred until page load\n */\nexport function shouldDeferIntercepts() {\n    if (typeof document === 'undefined')\n        return false;\n    return document.readyState === 'loading';\n}\n/**\n * Check memory pressure and adjust buffer capacities\n */\nexport function checkMemoryPressure(state) {\n    const result = { ...state };\n    if (state.memoryUsageMB >= MEMORY_HARD_LIMIT_MB) {\n        // Hard limit: disable network bodies\n        result.networkBodiesEnabled = false;\n        result.wsBufferCapacity = Math.floor(state.wsBufferCapacity * 0.25);\n        result.networkBufferCapacity = Math.floor(state.networkBufferCapacity * 0.25);\n    }\n    else if (state.memoryUsageMB >= MEMORY_SOFT_LIMIT_MB) {\n        // Soft limit: reduce buffers\n        result.wsBufferCapacity = Math.floor(state.wsBufferCapacity * 0.5);\n        result.networkBufferCapacity = Math.floor(state.networkBufferCapacity * 0.5);\n    }\n    return result;\n}\n/**\n * Phase 1 (Immediate): Lightweight, non-intercepting setup.\n */\nexport function installPhase1() {\n    console.log('[Gasoline] Phase 1 installing (lightweight API + perf observers)');\n    injectionTimestamp = performance.now();\n    phase2Installed = false;\n    phase2Timestamp = 0;\n    // Start PerformanceObservers (passive observers, no prototype modification)\n    installPerformanceCapture();\n    // Now handle Phase 2 scheduling\n    if (!deferralEnabled) {\n        // Deferral disabled: install Phase 2 immediately\n        installPhase2();\n    }\n    else {\n        const installDeferred = () => {\n            if (!phase2Installed)\n                setTimeout(installPhase2, 100);\n        };\n        if (document.readyState === 'complete') {\n            // Page already loaded, defer by 100ms\n            installDeferred();\n        }\n        else {\n            // Wait for load event, then defer by 100ms\n            window.addEventListener('load', installDeferred, { once: true });\n            // 10-second timeout fallback\n            setTimeout(() => {\n                if (!phase2Installed)\n                    installPhase2();\n            }, 10000);\n        }\n    }\n}\n/**\n * Phase 2 (Deferred): Heavy interceptors.\n */\nexport function installPhase2() {\n    // Double-injection guard\n    if (phase2Installed)\n        return;\n    // Environment guard\n    if (typeof window === 'undefined' || typeof document === 'undefined')\n        return;\n    console.log('[Gasoline] Phase 2 installing (heavy interceptors: console, fetch, WS, errors, actions)');\n    phase2Timestamp = performance.now();\n    phase2Installed = true;\n    // Install all heavy interceptors\n    install();\n}\nexport function getDeferralState() {\n    return {\n        deferralEnabled,\n        phase2Installed,\n        injectionTimestamp,\n        phase2Timestamp,\n    };\n}\n/**\n * Set whether interception deferral is enabled.\n */\nexport function setDeferralEnabled(enabled) {\n    deferralEnabled = enabled;\n}\n//# sourceMappingURL=observers.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/inject/state.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":23,"column":13,"nodeType":"MemberExpression","endLine":23,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":32,"column":13,"nodeType":"MemberExpression","endLine":32,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview State Management - Handles browser state capture/restore and\n * element highlighting for the AI Web Pilot.\n */\nimport { sendPerformanceSnapshot } from '../lib/perf-snapshot.js';\nlet gasolineHighlighter = null;\n/**\n * Capture browser state (localStorage, sessionStorage, cookies).\n * Returns a snapshot that can be restored later.\n */\nexport function captureState() {\n    const state = {\n        url: window.location.href,\n        timestamp: Date.now(),\n        localStorage: {},\n        sessionStorage: {},\n        cookies: document.cookie,\n    };\n    const localStorageData = {};\n    for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key) {\n            localStorageData[key] = localStorage.getItem(key) || '';\n        }\n    }\n    ;\n    state.localStorage = localStorageData;\n    const sessionStorageData = {};\n    for (let i = 0; i < sessionStorage.length; i++) {\n        const key = sessionStorage.key(i);\n        if (key) {\n            sessionStorageData[key] = sessionStorage.getItem(key) || '';\n        }\n    }\n    ;\n    state.sessionStorage = sessionStorageData;\n    return state;\n}\n/**\n * Validates a storage key to prevent prototype pollution and other attacks\n */\nfunction isValidStorageKey(key) {\n    if (typeof key !== 'string')\n        return false;\n    if (key.length === 0 || key.length > 256)\n        return false;\n    // Reject prototype pollution vectors\n    const dangerous = ['__proto__', 'constructor', 'prototype'];\n    const lowerKey = key.toLowerCase();\n    for (const pattern of dangerous) {\n        if (lowerKey.includes(pattern))\n            return false;\n    }\n    return true;\n}\n/**\n * Restore browser state from a snapshot.\n * Clears existing state before restoring.\n */\nexport function restoreState(state, includeUrl = true) {\n    // Validate state object\n    if (!state || typeof state !== 'object') {\n        return { success: false, error: 'Invalid state object' };\n    }\n    // Clear existing\n    localStorage.clear();\n    sessionStorage.clear();\n    // Restore localStorage with validation\n    let skipped = 0;\n    for (const [key, value] of Object.entries(state.localStorage || {})) {\n        if (!isValidStorageKey(key)) {\n            skipped++;\n            console.warn('[gasoline] Skipped localStorage key with invalid pattern:', key);\n            continue;\n        }\n        // Limit value size (10MB max per item)\n        if (typeof value === 'string' && value.length > 10 * 1024 * 1024) {\n            skipped++;\n            console.warn('[gasoline] Skipped localStorage value exceeding 10MB:', key);\n            continue;\n        }\n        localStorage.setItem(key, value);\n    }\n    // Restore sessionStorage with validation\n    for (const [key, value] of Object.entries(state.sessionStorage || {})) {\n        if (!isValidStorageKey(key)) {\n            skipped++;\n            console.warn('[gasoline] Skipped sessionStorage key with invalid pattern:', key);\n            continue;\n        }\n        if (typeof value === 'string' && value.length > 10 * 1024 * 1024) {\n            skipped++;\n            console.warn('[gasoline] Skipped sessionStorage value exceeding 10MB:', key);\n            continue;\n        }\n        sessionStorage.setItem(key, value);\n    }\n    // Restore cookies (clear then set)\n    document.cookie.split(';').forEach((c) => {\n        const namePart = c.split('=')[0];\n        if (namePart) {\n            const name = namePart.trim();\n            if (name) {\n                document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/`;\n            }\n        }\n    });\n    if (state.cookies) {\n        state.cookies.split(';').forEach((c) => {\n            document.cookie = c.trim();\n        });\n    }\n    const restored = {\n        localStorage: Object.keys(state.localStorage || {}).length - skipped,\n        sessionStorage: Object.keys(state.sessionStorage || {}).length,\n        cookies: (state.cookies || '').split(';').filter((c) => c.trim()).length,\n        skipped,\n    };\n    // Navigate if requested (with basic URL validation)\n    if (includeUrl && state.url && state.url !== window.location.href) {\n        // Basic URL validation: must be http/https\n        try {\n            const url = new URL(state.url);\n            if (url.protocol === 'http:' || url.protocol === 'https:') {\n                window.location.href = state.url;\n            }\n            else {\n                console.warn('[gasoline] Skipped navigation to non-HTTP(S) URL:', state.url);\n            }\n        }\n        catch (e) {\n            console.warn('[gasoline] Invalid URL for navigation:', state.url, e);\n        }\n    }\n    if (skipped > 0) {\n        console.warn(`[gasoline] restoreState completed with ${skipped} skipped item(s)`);\n    }\n    return { success: true, restored };\n}\n/**\n * Highlight a DOM element by injecting a red overlay div.\n */\nexport function highlightElement(selector, durationMs = 5000) {\n    // Remove existing highlight\n    if (gasolineHighlighter) {\n        gasolineHighlighter.remove();\n        gasolineHighlighter = null;\n    }\n    const element = document.querySelector(selector);\n    if (!element) {\n        return { success: false, error: 'element_not_found', selector };\n    }\n    const rect = element.getBoundingClientRect();\n    gasolineHighlighter = document.createElement('div');\n    gasolineHighlighter.id = 'gasoline-highlighter';\n    gasolineHighlighter.dataset.selector = selector;\n    Object.assign(gasolineHighlighter.style, {\n        position: 'fixed',\n        top: `${rect.top}px`,\n        left: `${rect.left}px`,\n        width: `${rect.width}px`,\n        height: `${rect.height}px`,\n        border: '4px solid red',\n        borderRadius: '4px',\n        backgroundColor: 'rgba(255, 0, 0, 0.1)',\n        zIndex: '2147483647',\n        pointerEvents: 'none',\n        boxSizing: 'border-box',\n    });\n    const targetElement = document.body || document.documentElement;\n    if (targetElement) {\n        targetElement.appendChild(gasolineHighlighter);\n    }\n    else {\n        console.warn('[Gasoline] No document body available for highlighter injection');\n        return;\n    }\n    setTimeout(() => {\n        if (gasolineHighlighter) {\n            gasolineHighlighter.remove();\n            gasolineHighlighter = null;\n        }\n    }, durationMs);\n    return {\n        success: true,\n        selector,\n        bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height },\n    };\n}\n/**\n * Clear any existing highlight\n */\nexport function clearHighlight() {\n    if (gasolineHighlighter) {\n        gasolineHighlighter.remove();\n        gasolineHighlighter = null;\n    }\n}\n/**\n * Handle scroll - update highlight position\n */\nif (typeof window !== 'undefined') {\n    window.addEventListener('scroll', () => {\n        if (gasolineHighlighter) {\n            const selector = gasolineHighlighter.dataset.selector;\n            if (selector) {\n                const el = document.querySelector(selector);\n                if (el) {\n                    const rect = el.getBoundingClientRect();\n                    gasolineHighlighter.style.top = `${rect.top}px`;\n                    gasolineHighlighter.style.left = `${rect.left}px`;\n                }\n            }\n        }\n    }, { passive: true });\n}\n/**\n * Handle GASOLINE_HIGHLIGHT_REQUEST messages from content script\n */\nif (typeof window !== 'undefined') {\n    window.addEventListener('message', (event) => {\n        if (event.source !== window)\n            return;\n        if (event.data?.type === 'GASOLINE_HIGHLIGHT_REQUEST') {\n            const { requestId, params } = event.data;\n            const { selector, duration_ms } = params || { selector: '' };\n            const result = highlightElement(selector, duration_ms);\n            window.postMessage({\n                type: 'GASOLINE_HIGHLIGHT_RESPONSE',\n                requestId,\n                result,\n            }, window.location.origin);\n        }\n    });\n}\n/**\n * Wrapper for sending performance snapshot (exported for compatibility)\n */\nexport function sendPerformanceSnapshotWrapper() {\n    sendPerformanceSnapshot();\n}\n//# sourceMappingURL=state.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/actions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/ai-context.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":121,"column":20,"nodeType":"MemberExpression","endLine":121,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":292,"column":17,"nodeType":"MemberExpression","endLine":292,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":295,"column":17,"nodeType":"MemberExpression","endLine":295,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":298,"column":17,"nodeType":"MemberExpression","endLine":298,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":364,"column":75,"nodeType":"MemberExpression","endLine":364,"endColumn":110}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview AI-preprocessed error enrichment pipeline.\n * Parses stack traces, resolves source maps, extracts code snippets,\n * detects UI frameworks (React/Vue/Svelte), captures state snapshots,\n * and generates AI-friendly error summaries. All within a timeout guard.\n */\nimport { AI_CONTEXT_SNIPPET_LINES, AI_CONTEXT_MAX_LINE_LENGTH, AI_CONTEXT_MAX_SNIPPETS_SIZE, AI_CONTEXT_MAX_ANCESTRY_DEPTH, AI_CONTEXT_MAX_PROP_KEYS, AI_CONTEXT_MAX_STATE_KEYS, AI_CONTEXT_MAX_RELEVANT_SLICE, AI_CONTEXT_MAX_VALUE_LENGTH, AI_CONTEXT_SOURCE_MAP_CACHE_SIZE, AI_CONTEXT_PIPELINE_TIMEOUT_MS, } from './constants.js';\n// =============================================================================\n// MODULE STATE\n// =============================================================================\n// AI Context state\nlet aiContextEnabled = true;\nlet aiContextStateSnapshotEnabled = false;\nconst aiSourceMapCache = new Map();\n// =============================================================================\n// STACK FRAME PARSING\n// =============================================================================\n/**\n * Parse stack trace into structured frames\n * Supports Chrome and Firefox formats\n * @param stack - The stack trace string\n * @returns Array of frame objects { functionName, filename, lineno, colno }\n */\nexport function parseStackFrames(stack) {\n    if (!stack)\n        return [];\n    const frames = [];\n    const lines = stack.split('\\n');\n    for (const line of lines) {\n        const trimmed = line.trim();\n        // Chrome format: \"    at functionName (url:line:col)\"\n        // or \"    at url:line:col\"\n        const chromeMatch = trimmed.match(/^at\\s+(?:(.+?)\\s+\\()?(.+?):(\\d+):(\\d+)\\)?$/);\n        if (chromeMatch) {\n            const filename = chromeMatch[2];\n            if (!filename || filename.includes('<anonymous>'))\n                continue;\n            const lineStr = chromeMatch[3];\n            const colStr = chromeMatch[4];\n            if (!lineStr || !colStr)\n                continue;\n            frames.push({\n                functionName: chromeMatch[1] || null,\n                filename,\n                lineno: parseInt(lineStr, 10),\n                colno: parseInt(colStr, 10),\n            });\n            continue;\n        }\n        // Firefox format: \"functionName@url:line:col\"\n        const firefoxMatch = trimmed.match(/^(.+?)@(.+?):(\\d+):(\\d+)$/);\n        if (firefoxMatch) {\n            const filename = firefoxMatch[2];\n            if (!filename || filename.includes('<anonymous>'))\n                continue;\n            const lineStr = firefoxMatch[3];\n            const colStr = firefoxMatch[4];\n            if (!lineStr || !colStr)\n                continue;\n            frames.push({\n                functionName: firefoxMatch[1] || null,\n                filename,\n                lineno: parseInt(lineStr, 10),\n                colno: parseInt(colStr, 10),\n            });\n            continue;\n        }\n    }\n    return frames;\n}\n// =============================================================================\n// SOURCE MAP PARSING\n// =============================================================================\n/**\n * Parse an inline base64 source map data URL\n * @param dataUrl - The data: URL containing the source map\n * @returns Parsed source map or null\n */\nexport function parseSourceMap(dataUrl) {\n    if (!dataUrl || typeof dataUrl !== 'string')\n        return null;\n    if (!dataUrl.startsWith('data:'))\n        return null;\n    try {\n        // Extract base64 content after the last comma\n        const base64Match = dataUrl.match(/;base64,(.+)$/);\n        if (!base64Match || !base64Match[1])\n            return null;\n        const decoded = atob(base64Match[1]);\n        const parsed = JSON.parse(decoded);\n        // Only useful if it has sourcesContent\n        if (!parsed.sourcesContent || parsed.sourcesContent.length === 0)\n            return null;\n        return parsed;\n    }\n    catch {\n        return null;\n    }\n}\n// =============================================================================\n// CODE SNIPPET EXTRACTION\n// =============================================================================\n/**\n * Extract a code snippet around a given line number\n * @param sourceContent - The full source file content\n * @param line - The 1-based line number of the error\n * @returns Array of { line, text, isError? } or null\n */\nexport function extractSnippet(sourceContent, line) {\n    if (!sourceContent || typeof sourceContent !== 'string')\n        return null;\n    if (!line || line < 1)\n        return null;\n    const lines = sourceContent.split('\\n');\n    if (line > lines.length)\n        return null;\n    const start = Math.max(0, line - 1 - AI_CONTEXT_SNIPPET_LINES);\n    const end = Math.min(lines.length, line + AI_CONTEXT_SNIPPET_LINES);\n    const snippet = [];\n    for (let i = start; i < end; i++) {\n        let text = lines[i];\n        if (!text)\n            continue;\n        if (text.length > AI_CONTEXT_MAX_LINE_LENGTH) {\n            text = text.slice(0, AI_CONTEXT_MAX_LINE_LENGTH);\n        }\n        const entry = { line: i + 1, text };\n        if (i + 1 === line)\n            entry.isError = true;\n        snippet.push(entry);\n    }\n    return snippet;\n}\n/**\n * Extract source snippets for multiple stack frames\n * @param frames - Parsed stack frames\n * @param mockSourceMaps - Map of filename to parsed source map\n * @returns Array of snippet objects\n */\nexport async function extractSourceSnippets(frames, mockSourceMaps) {\n    // SOURCE MAP CACHING STRATEGY:\n    // This function works with a mockSourceMaps lookup that is pre-populated by\n    // resolveSourceMap(). The caching layer is managed separately via the module-level\n    // aiSourceMapCache Map, which stores up to AI_CONTEXT_SOURCE_MAP_CACHE_SIZE entries\n    // using LRU eviction. When a source map is needed here, it should already be cached\n    // by the MCP observe handler that parsed the HTTP response headers.\n    //\n    // OPTIMIZATION: We only process the top 3 stack frames to limit computation and avoid\n    // redundant snippets. Most stack traces have the root cause in the first 1-3 frames.\n    //\n    // PARSE ERROR HANDLING: If sourcesContent is missing, we skip the frame entirely\n    // rather than erroring. This gracefully handles source maps generated without embedded\n    // sources (which only contain mappings, not code). We never throw here.\n    //\n    // SIZE ENFORCEMENT: Total snippets are capped at AI_CONTEXT_MAX_SNIPPETS_SIZE to prevent\n    // bloating the error entry. Each snippet's JSON serialized size is checked before adding.\n    // This ensures the enriched error entry stays lightweight for AI processing.\n    const snippets = [];\n    let totalSize = 0;\n    for (const frame of frames.slice(0, 3)) {\n        if (totalSize >= AI_CONTEXT_MAX_SNIPPETS_SIZE)\n            break;\n        const sourceMap = mockSourceMaps[frame.filename];\n        if (!sourceMap || !sourceMap.sourcesContent || !sourceMap.sourcesContent[0])\n            continue;\n        const snippet = extractSnippet(sourceMap.sourcesContent[0], frame.lineno);\n        if (!snippet)\n            continue;\n        const snippetObj = { file: frame.filename, line: frame.lineno, snippet };\n        const snippetSize = JSON.stringify(snippetObj).length;\n        if (totalSize + snippetSize > AI_CONTEXT_MAX_SNIPPETS_SIZE)\n            break;\n        totalSize += snippetSize;\n        snippets.push(snippetObj);\n    }\n    return snippets;\n}\n// =============================================================================\n// FRAMEWORK DETECTION\n// =============================================================================\n/**\n * Detect which UI framework an element belongs to\n * @param element - The DOM element (or element-like object)\n * @returns { framework, key? } or null\n */\nexport function detectFramework(element) {\n    if (!element || typeof element !== 'object')\n        return null;\n    // React: __reactFiber$ or __reactInternalInstance$\n    const keys = Object.keys(element);\n    const reactKey = keys.find((k) => k.startsWith('__reactFiber$') || k.startsWith('__reactInternalInstance$'));\n    if (reactKey)\n        return { framework: 'react', key: reactKey };\n    // Vue 3: __vueParentComponent or __vue_app__\n    if (element.__vueParentComponent || element.__vue_app__) {\n        return { framework: 'vue' };\n    }\n    // Svelte: __svelte_meta\n    if (element.__svelte_meta) {\n        return { framework: 'svelte' };\n    }\n    return null;\n}\n// =============================================================================\n// REACT COMPONENT ANCESTRY\n// =============================================================================\n/**\n * Walk a React fiber tree to extract component ancestry\n * @param fiber - The React fiber node\n * @returns Array of { name, propKeys?, hasState?, stateKeys? } in root-first order\n */\nexport function getReactComponentAncestry(fiber) {\n    if (!fiber)\n        return null;\n    const ancestry = [];\n    let current = fiber;\n    let depth = 0;\n    while (current && depth < AI_CONTEXT_MAX_ANCESTRY_DEPTH) {\n        depth++;\n        // Only include component fibers (type is function/object), skip host elements (type is string)\n        if (current.type && typeof current.type !== 'string') {\n            const typeObj = current.type;\n            const name = typeObj.displayName || typeObj.name || 'Anonymous';\n            const entry = { name };\n            // Extract prop keys (excluding children)\n            if (current.memoizedProps && typeof current.memoizedProps === 'object') {\n                entry.propKeys = Object.keys(current.memoizedProps)\n                    .filter((k) => k !== 'children')\n                    .slice(0, AI_CONTEXT_MAX_PROP_KEYS);\n            }\n            // Extract state keys\n            if (current.memoizedState && typeof current.memoizedState === 'object' && !Array.isArray(current.memoizedState)) {\n                entry.hasState = true;\n                entry.stateKeys = Object.keys(current.memoizedState).slice(0, AI_CONTEXT_MAX_STATE_KEYS);\n            }\n            ancestry.push(entry);\n        }\n        current = current.return;\n    }\n    return ancestry.reverse(); // Root-first order\n}\n// =============================================================================\n// STATE SNAPSHOT\n// =============================================================================\n/**\n * Capture application state snapshot from known store patterns\n * @param errorMessage - The error message for keyword matching\n * @returns State snapshot or null\n */\nexport function captureStateSnapshot(errorMessage) {\n    if (typeof window === 'undefined')\n        return null;\n    try {\n        // Try Redux store\n        const store = window.__REDUX_STORE__;\n        if (!store || typeof store.getState !== 'function')\n            return null;\n        const state = store.getState();\n        if (!state || typeof state !== 'object')\n            return null;\n        // REACT COMPONENT ANCESTRY DETECTION ALGORITHM:\n        // This function captures application state from Redux to provide context for AI debugging.\n        // The \"ancestry\" aspect applies to the React component tree via the accompanying\n        // getReactComponentAncestry() function that walks React fibers. Here, we focus on\n        // state relevance matching.\n        //\n        // STATE RELEVANCE MATCHING STRATEGY:\n        // 1. Extract error keywords from the error message (words > 2 chars) to contextually\n        //    identify relevant state slices. For example, \"TypeError: Cannot read property 'user'\"\n        //    makes 'user' a search keyword.\n        // 2. Build a \"relevant slice\" by traversing nested state objects and matching against:\n        //    - COMMON ERROR STATE KEYS: 'error', 'loading', 'status', 'failed' (always relevant)\n        //    - ERROR MESSAGE KEYWORDS: Any state key containing matched words from the error\n        // 3. This multi-strategy approach surfaces both generic error states and error-specific\n        //    slices without needing to inspect the entire state tree (which could be enormous).\n        //\n        // PERFORMANCE IMPLICATIONS:\n        // - Top-level state entries are iterated once (O(n) where n = Redux root keys)\n        // - Nested object entries only processed if parent is object && not array (simple guard)\n        // - Slice collection caps at AI_CONTEXT_MAX_RELEVANT_SLICE (typically 10 entries) to\n        //   prevent large state objects from dominating the error context\n        // - Individual values truncated at AI_CONTEXT_MAX_VALUE_LENGTH (2000 chars) to keep\n        //   serialized error entry small\n        // - Error message keyword extraction is single-pass, O(m) where m = error message length\n        //\n        // NOTE: This only supports Redux. Other state management (Zustand, Recoil, MobX)\n        // would require additional window.__* patterns and corresponding modifications.\n        // Build keys with types\n        const keys = {};\n        for (const [key, value] of Object.entries(state)) {\n            if (Array.isArray(value)) {\n                keys[key] = { type: 'array' };\n            }\n            else if (value === null) {\n                keys[key] = { type: 'null' };\n            }\n            else {\n                keys[key] = { type: typeof value };\n            }\n        }\n        // Build relevant slice\n        const relevantSlice = {};\n        let sliceCount = 0;\n        const errorWords = (errorMessage || '')\n            .toLowerCase()\n            .split(/\\W+/)\n            .filter((w) => w.length > 2);\n        for (const [key, value] of Object.entries(state)) {\n            if (sliceCount >= AI_CONTEXT_MAX_RELEVANT_SLICE)\n                break;\n            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n                for (const [subKey, subValue] of Object.entries(value)) {\n                    if (sliceCount >= AI_CONTEXT_MAX_RELEVANT_SLICE)\n                        break;\n                    const isRelevantKey = ['error', 'loading', 'status', 'failed'].some((k) => subKey.toLowerCase().includes(k));\n                    const isKeywordMatch = errorWords.some((w) => key.toLowerCase().includes(w));\n                    if (isRelevantKey || isKeywordMatch) {\n                        let val = subValue;\n                        if (typeof val === 'string' && val.length > AI_CONTEXT_MAX_VALUE_LENGTH) {\n                            val = val.slice(0, AI_CONTEXT_MAX_VALUE_LENGTH);\n                        }\n                        relevantSlice[`${key}.${subKey}`] = val;\n                        sliceCount++;\n                    }\n                }\n            }\n        }\n        return {\n            source: 'redux',\n            keys,\n            relevantSlice,\n        };\n    }\n    catch {\n        return null;\n    }\n}\n// =============================================================================\n// AI SUMMARY GENERATION\n// =============================================================================\n/**\n * Generate a template-based AI summary from enrichment data\n * @param data - { errorType, message, file, line, componentAncestry, stateSnapshot }\n * @returns Summary string\n */\nexport function generateAiSummary(data) {\n    const parts = [];\n    // Error type and location\n    if (data.file && data.line) {\n        parts.push(`${data.errorType} in ${data.file}:${data.line} — ${data.message}`);\n    }\n    else {\n        parts.push(`${data.errorType}: ${data.message}`);\n    }\n    // Component context\n    if (data.componentAncestry && data.componentAncestry.components) {\n        const path = data.componentAncestry.components.map((c) => c.name).join(' > ');\n        parts.push(`Component tree: ${path}.`);\n    }\n    // State context\n    if (data.stateSnapshot && data.stateSnapshot.relevantSlice) {\n        const sliceKeys = Object.keys(data.stateSnapshot.relevantSlice);\n        if (sliceKeys.length > 0) {\n            const stateInfo = sliceKeys.map((k) => `${k}=${JSON.stringify(data.stateSnapshot.relevantSlice[k])}`).join(', ');\n            parts.push(`State: ${stateInfo}.`);\n        }\n    }\n    return parts.join(' ');\n}\n/**\n * Full error enrichment pipeline\n * @param error - The error entry to enrich\n * @returns The enriched error entry\n */\nexport async function enrichErrorWithAiContext(error) {\n    if (!aiContextEnabled)\n        return error;\n    const enriched = { ...error };\n    try {\n        // Race the entire pipeline against a timeout\n        const context = await Promise.race([\n            (async () => {\n                const result = {};\n                // Parse stack frames\n                const frames = parseStackFrames(error.stack);\n                if (frames.length === 0) {\n                    return { summary: error.message || 'Unknown error' };\n                }\n                const topFrame = frames[0];\n                // Source snippets (from cache)\n                if (topFrame) {\n                    const cached = getSourceMapCache(topFrame.filename);\n                    if (cached) {\n                        const snippets = await extractSourceSnippets(frames, { [topFrame.filename]: cached });\n                        if (snippets.length > 0)\n                            result.sourceSnippets = snippets;\n                    }\n                }\n                // Component ancestry from activeElement\n                if (typeof document !== 'undefined' && document.activeElement) {\n                    const framework = detectFramework(document.activeElement);\n                    if (framework && framework.framework === 'react' && framework.key) {\n                        const fiber = document.activeElement[framework.key];\n                        const components = getReactComponentAncestry(fiber);\n                        if (components && components.length > 0) {\n                            result.componentAncestry = { framework: 'react', components };\n                        }\n                    }\n                }\n                // State snapshot (if enabled)\n                if (aiContextStateSnapshotEnabled) {\n                    const snapshot = captureStateSnapshot(error.message || '');\n                    if (snapshot)\n                        result.stateSnapshot = snapshot;\n                }\n                // Generate summary\n                result.summary = generateAiSummary({\n                    errorType: error.message?.split(':')[0] || 'Error',\n                    message: error.message || '',\n                    file: topFrame?.filename || null,\n                    line: topFrame?.lineno || null,\n                    componentAncestry: result.componentAncestry || null,\n                    stateSnapshot: result.stateSnapshot || null,\n                });\n                return result;\n            })(),\n            new Promise((resolve) => {\n                setTimeout(() => resolve({ summary: `${error.message || 'Error'}` }), AI_CONTEXT_PIPELINE_TIMEOUT_MS);\n            }),\n        ]);\n        enriched._aiContext = context;\n        if (!enriched._enrichments)\n            enriched._enrichments = [];\n        enriched._enrichments.push('aiContext');\n    }\n    catch {\n        // Pipeline failed, add minimal context\n        enriched._aiContext = { summary: error.message || 'Unknown error' };\n        if (!enriched._enrichments)\n            enriched._enrichments = [];\n        enriched._enrichments.push('aiContext');\n    }\n    return enriched;\n}\n// =============================================================================\n// CONFIGURATION\n// =============================================================================\n/**\n * Enable or disable AI context enrichment\n * @param enabled\n */\nexport function setAiContextEnabled(enabled) {\n    aiContextEnabled = enabled;\n}\n/**\n * Enable or disable state snapshot in AI context\n * @param enabled\n */\nexport function setAiContextStateSnapshot(enabled) {\n    aiContextStateSnapshotEnabled = enabled;\n}\n// =============================================================================\n// SOURCE MAP CACHE\n// =============================================================================\n/**\n * Cache a parsed source map for a URL\n * @param url - The script URL\n * @param map - The parsed source map\n */\nexport function setSourceMapCache(url, map) {\n    // Evict oldest if adding new entry and at capacity\n    if (!aiSourceMapCache.has(url) && aiSourceMapCache.size >= AI_CONTEXT_SOURCE_MAP_CACHE_SIZE) {\n        const firstKey = aiSourceMapCache.keys().next().value;\n        if (firstKey) {\n            aiSourceMapCache.delete(firstKey);\n        }\n    }\n    // Move to end (LRU): delete first if exists, then add\n    // This ensures recently accessed/updated entries are kept longest\n    aiSourceMapCache.delete(url);\n    aiSourceMapCache.set(url, map);\n}\n/**\n * Get a cached source map\n * @param url - The script URL\n * @returns The cached source map or null\n */\nexport function getSourceMapCache(url) {\n    return aiSourceMapCache.get(url) || null;\n}\n/**\n * Get the number of cached source maps\n * @returns\n */\nexport function getSourceMapCacheSize() {\n    return aiSourceMapCache.size;\n}\n/**\n * Reset all module state for testing purposes\n * Clears source map cache and restores default settings.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting() {\n    aiContextEnabled = true;\n    aiContextStateSnapshotEnabled = false;\n    aiSourceMapCache.clear();\n}\n//# sourceMappingURL=ai-context.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/bridge.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/console.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":17,"column":9,"nodeType":"MemberExpression","endLine":17,"endColumn":32,"suppressions":[{"kind":"directive","justification":"method from known-safe local array of console methods"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":17,"column":35,"nodeType":"MemberExpression","endLine":17,"endColumn":50,"suppressions":[{"kind":"directive","justification":"method from known-safe local array of console methods"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":19,"column":9,"nodeType":"MemberExpression","endLine":19,"endColumn":24,"suppressions":[{"kind":"directive","justification":"method from known-safe local array of console methods"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":28,"column":13,"nodeType":"MemberExpression","endLine":28,"endColumn":36,"suppressions":[{"kind":"directive","justification":"method from known-safe local array of console methods"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":38,"column":9,"nodeType":"MemberExpression","endLine":38,"endColumn":24,"suppressions":[{"kind":"directive","justification":"method from Object.keys of our own originalConsole storage"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":38,"column":27,"nodeType":"MemberExpression","endLine":38,"endColumn":50,"suppressions":[{"kind":"directive","justification":"method from Object.keys of our own originalConsole storage"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/constants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/context.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":18,"column":9,"nodeType":"MemberExpression","endLine":18,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Context annotations storage and management.\n * Provides key-value annotations that attach to captured events for\n * richer debugging context (e.g., user flow, feature flag, session info).\n */\nimport { MAX_CONTEXT_SIZE, MAX_CONTEXT_VALUE_SIZE } from './constants.js';\nimport { safeSerialize } from './serialize.js';\n// Context annotations storage\nconst contextAnnotations = new Map();\n/**\n * Get current context annotations as an object\n */\nexport function getContextAnnotations() {\n    if (contextAnnotations.size === 0)\n        return null;\n    const result = {};\n    for (const [key, value] of contextAnnotations) {\n        result[key] = value;\n    }\n    return result;\n}\n/**\n * Set a context annotation\n */\nexport function setContextAnnotation(key, value) {\n    if (typeof key !== 'string' || key.length === 0) {\n        console.warn('[Gasoline] annotate() requires a non-empty string key');\n        return false;\n    }\n    if (key.length > 100) {\n        console.warn('[Gasoline] annotate() key must be 100 characters or less');\n        return false;\n    }\n    // Enforce max context keys\n    if (!contextAnnotations.has(key) && contextAnnotations.size >= MAX_CONTEXT_SIZE) {\n        console.warn(`[Gasoline] Maximum context annotations (${MAX_CONTEXT_SIZE}) reached`);\n        return false;\n    }\n    // Serialize and check size\n    const serialized = safeSerialize(value);\n    const serializedStr = JSON.stringify(serialized);\n    if (serializedStr.length > MAX_CONTEXT_VALUE_SIZE) {\n        console.warn(`[Gasoline] Context value for \"${key}\" exceeds max size, truncating`);\n        contextAnnotations.set(key, '[Value too large]');\n        return false;\n    }\n    contextAnnotations.set(key, serialized);\n    return true;\n}\n/**\n * Remove a context annotation\n */\nexport function removeContextAnnotation(key) {\n    return contextAnnotations.delete(key);\n}\n/**\n * Clear all context annotations\n */\nexport function clearContextAnnotations() {\n    contextAnnotations.clear();\n}\n//# sourceMappingURL=context.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/dom-queries.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":17,"column":20,"nodeType":"MemberExpression","endLine":17,"endColumn":31},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":58,"column":17,"nodeType":"MemberExpression","endLine":58,"endColumn":35},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":70,"column":27,"nodeType":"MemberExpression","endLine":70,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview On-demand DOM queries.\n * Provides structured DOM querying, page info extraction, and\n * accessibility auditing via axe-core.\n */\nimport { DOM_QUERY_MAX_ELEMENTS, DOM_QUERY_MAX_TEXT, DOM_QUERY_MAX_DEPTH, DOM_QUERY_MAX_HTML, A11Y_MAX_NODES_PER_VIOLATION, A11Y_AUDIT_TIMEOUT_MS, } from './constants.js';\n/**\n * Execute a DOM query and return structured results\n */\nexport async function executeDOMQuery(params) {\n    const { selector, include_styles, properties, include_children, max_depth } = params;\n    const elements = document.querySelectorAll(selector);\n    const matchCount = elements.length;\n    const cappedDepth = Math.min(max_depth || 3, DOM_QUERY_MAX_DEPTH);\n    const matches = [];\n    for (let i = 0; i < Math.min(elements.length, DOM_QUERY_MAX_ELEMENTS); i++) {\n        const el = elements[i];\n        if (!el)\n            continue;\n        const entry = serializeDOMElement(el, include_styles, properties, include_children, cappedDepth, 0);\n        matches.push(entry);\n    }\n    return {\n        url: window.location.href,\n        title: document.title,\n        matchCount,\n        returnedCount: matches.length,\n        matches,\n    };\n}\n/**\n * Serialize a DOM element to a plain object\n */\nfunction serializeDOMElement(el, includeStyles, styleProps, includeChildren, maxDepth, currentDepth) {\n    const entry = {\n        tag: el.tagName ? el.tagName.toLowerCase() : '',\n        text: (el.textContent || '').slice(0, DOM_QUERY_MAX_TEXT),\n        visible: el.offsetParent !== null || (el.getBoundingClientRect && el.getBoundingClientRect().width > 0),\n    };\n    // Attributes\n    if (el.attributes && el.attributes.length > 0) {\n        entry.attributes = {};\n        for (const attr of el.attributes) {\n            entry.attributes[attr.name] = attr.value;\n        }\n    }\n    // Bounding box\n    if (el.getBoundingClientRect) {\n        const rect = el.getBoundingClientRect();\n        entry.boundingBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };\n    }\n    // Computed styles\n    if (includeStyles && typeof window.getComputedStyle === 'function') {\n        const computed = window.getComputedStyle(el);\n        entry.styles = {};\n        if (styleProps && styleProps.length > 0) {\n            for (const prop of styleProps) {\n                entry.styles[prop] = computed.getPropertyValue(prop);\n            }\n        }\n        else {\n            entry.styles = { display: computed.display, color: computed.color, position: computed.position };\n        }\n    }\n    // Children (capped to avoid unbounded serialization)\n    if (includeChildren && currentDepth < maxDepth && el.children && el.children.length > 0) {\n        entry.children = [];\n        const maxChildren = Math.min(el.children.length, DOM_QUERY_MAX_ELEMENTS);\n        for (let i = 0; i < maxChildren; i++) {\n            const child = el.children[i];\n            if (child) {\n                entry.children.push(serializeDOMElement(child, false, undefined, true, maxDepth, currentDepth + 1));\n            }\n        }\n    }\n    return entry;\n}\n/**\n * Get comprehensive page info\n */\nexport async function getPageInfo() {\n    const headings = [];\n    const headingEls = document.querySelectorAll('h1,h2,h3,h4,h5,h6');\n    for (const h of headingEls) {\n        headings.push((h.textContent || '').slice(0, DOM_QUERY_MAX_TEXT));\n    }\n    const forms = [];\n    const formEls = document.querySelectorAll('form');\n    for (const form of formEls) {\n        const fields = [];\n        const inputs = form.querySelectorAll('input,select,textarea');\n        for (const input of inputs) {\n            const inputEl = input;\n            if (inputEl.name)\n                fields.push(inputEl.name);\n        }\n        forms.push({\n            id: form.id || undefined,\n            action: form.action || undefined,\n            fields,\n        });\n    }\n    return {\n        url: window.location.href,\n        title: document.title,\n        viewport: { width: window.innerWidth, height: window.innerHeight },\n        scroll: { x: window.scrollX, y: window.scrollY },\n        documentHeight: document.documentElement.scrollHeight,\n        headings,\n        links: document.querySelectorAll('a').length,\n        images: document.querySelectorAll('img').length,\n        interactiveElements: document.querySelectorAll('button,input,select,textarea,a[href]').length,\n        forms,\n    };\n}\n/**\n * Load axe-core dynamically if not already present.\n *\n * IMPORTANT: axe-core MUST be loaded from the bundled local copy (lib/axe.min.js).\n * Chrome Web Store policy prohibits loading remotely hosted code. All third-party\n * libraries must be bundled with the extension package.\n */\nfunction loadAxeCore() {\n    return new Promise((resolve, reject) => {\n        if (window.axe) {\n            resolve();\n            return;\n        }\n        // Wait for axe-core to be injected by content script (which has chrome.runtime API access)\n        // Note: This function runs in page context (inject script), so we can't call chrome.runtime.getURL()\n        const checkInterval = setInterval(() => {\n            if (window.axe) {\n                clearInterval(checkInterval);\n                resolve();\n            }\n        }, 100);\n        // Timeout after 5 seconds\n        setTimeout(() => {\n            clearInterval(checkInterval);\n            reject(new Error('Accessibility audit failed: axe-core library not loaded (5s timeout). The extension content script may not have been injected on this page. Try reloading the tab and re-running the audit.'));\n        }, 5000);\n    });\n}\n/**\n * Run an accessibility audit using axe-core\n */\nexport async function runAxeAudit(params) {\n    await loadAxeCore();\n    const context = params.scope ? { include: [params.scope] } : document;\n    const config = {};\n    if (params.tags && params.tags.length > 0) {\n        config.runOnly = params.tags;\n    }\n    if (params.include_passes) {\n        config.resultTypes = ['violations', 'passes', 'incomplete', 'inapplicable'];\n    }\n    else {\n        config.resultTypes = ['violations', 'incomplete'];\n    }\n    const results = await window.axe.run(context, config);\n    return formatAxeResults(results);\n}\n/**\n * Run axe audit with a timeout\n */\nexport async function runAxeAuditWithTimeout(params, timeoutMs = A11Y_AUDIT_TIMEOUT_MS) {\n    return Promise.race([\n        runAxeAudit(params),\n        new Promise((resolve) => {\n            setTimeout(() => resolve({\n                violations: [],\n                summary: { violations: 0, passes: 0, incomplete: 0, inapplicable: 0 },\n                error: 'Accessibility audit timeout',\n            }), timeoutMs);\n        }),\n    ]);\n}\n/**\n * Format axe-core results into a compact representation\n */\nexport function formatAxeResults(axeResult) {\n    const formatViolation = (v) => {\n        const formatted = {\n            id: v.id,\n            impact: v.impact,\n            description: v.description,\n            helpUrl: v.helpUrl,\n            nodes: [],\n        };\n        // Extract WCAG tags\n        if (v.tags) {\n            formatted.wcag = v.tags.filter((t) => t.startsWith('wcag'));\n        }\n        // Format nodes (cap at 10)\n        formatted.nodes = (v.nodes || []).slice(0, A11Y_MAX_NODES_PER_VIOLATION).map((node) => {\n            const selector = Array.isArray(node.target) ? node.target[0] : node.target;\n            return {\n                selector: selector || '',\n                html: (node.html || '').slice(0, DOM_QUERY_MAX_HTML),\n                ...(node.failureSummary ? { failureSummary: node.failureSummary } : {}),\n            };\n        });\n        if (v.nodes && v.nodes.length > A11Y_MAX_NODES_PER_VIOLATION) {\n            formatted.nodeCount = v.nodes.length;\n        }\n        return formatted;\n    };\n    return {\n        violations: (axeResult.violations || []).map(formatViolation),\n        summary: {\n            violations: (axeResult.violations || []).length,\n            passes: (axeResult.passes || []).length,\n            incomplete: (axeResult.incomplete || []).length,\n            inapplicable: (axeResult.inapplicable || []).length,\n        },\n    };\n}\n//# sourceMappingURL=dom-queries.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/exceptions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/network.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":216,"column":17,"nodeType":"MemberExpression","endLine":216,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":223,"column":17,"nodeType":"MemberExpression","endLine":223,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":230,"column":17,"nodeType":"MemberExpression","endLine":230,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Network waterfall and body capture.\n * Provides PerformanceResourceTiming parsing, pending request tracking,\n * fetch body capture with size limits, and sensitive header sanitization.\n */\nimport { MAX_WATERFALL_ENTRIES, WATERFALL_TIME_WINDOW_MS, REQUEST_BODY_MAX, RESPONSE_BODY_MAX, BODY_READ_TIMEOUT_MS, SENSITIVE_HEADER_PATTERNS, BINARY_CONTENT_TYPES, } from './constants.js';\n// =============================================================================\n// MODULE STATE\n// =============================================================================\n// Configured server URL for filtering (updated via setServerUrl)\nlet configuredServerUrl = '';\n// Network Waterfall state\nlet networkWaterfallEnabled = false;\nconst pendingRequests = new Map(); // requestId -> { url, method, startTime }\nlet requestIdCounter = 0;\n// Network body capture state\nlet networkBodyCaptureEnabled = true; // Default: capture request/response bodies\n// =============================================================================\n// NETWORK WATERFALL\n// =============================================================================\n/**\n * Parse a PerformanceResourceTiming entry into waterfall phases\n * @param timing - The timing entry\n * @returns Parsed waterfall entry\n */\nexport function parseResourceTiming(timing) {\n    const phases = {\n        dns: Math.max(0, timing.domainLookupEnd - timing.domainLookupStart),\n        connect: Math.max(0, timing.connectEnd - timing.connectStart),\n        tls: timing.secureConnectionStart > 0 ? Math.max(0, timing.connectEnd - timing.secureConnectionStart) : 0,\n        ttfb: Math.max(0, timing.responseStart - timing.requestStart),\n        download: Math.max(0, timing.responseEnd - timing.responseStart),\n    };\n    const result = {\n        url: timing.name,\n        initiatorType: timing.initiatorType,\n        startTime: timing.startTime,\n        duration: timing.duration,\n        phases,\n        transferSize: timing.transferSize || 0,\n        encodedBodySize: timing.encodedBodySize || 0,\n        decodedBodySize: timing.decodedBodySize || 0,\n    };\n    // Detect cache hit\n    if (timing.transferSize === 0 && timing.encodedBodySize > 0) {\n        ;\n        result.cached = true;\n    }\n    return result;\n}\n/**\n * Get network waterfall entries\n * @param options - Options for filtering\n * @returns Array of waterfall entries\n */\nexport function getNetworkWaterfall(options = {}) {\n    if (typeof performance === 'undefined' || !performance)\n        return [];\n    try {\n        let entries = performance.getEntriesByType('resource') || [];\n        // Filter by time range\n        if (options.since) {\n            entries = entries.filter((e) => e.startTime >= options.since);\n        }\n        // Filter by initiator type\n        if (options.initiatorTypes) {\n            entries = entries.filter((e) => options.initiatorTypes.includes(e.initiatorType));\n        }\n        // Exclude data URLs\n        entries = entries.filter((e) => !e.name.startsWith('data:'));\n        // Sort by start time\n        entries.sort((a, b) => a.startTime - b.startTime);\n        // Limit entries\n        if (entries.length > MAX_WATERFALL_ENTRIES) {\n            entries = entries.slice(-MAX_WATERFALL_ENTRIES);\n        }\n        return entries.map(parseResourceTiming);\n    }\n    catch {\n        return [];\n    }\n}\n/**\n * Track a pending request\n * @param request - Request info { url, method, startTime }\n * @returns Request ID\n */\nexport function trackPendingRequest(request) {\n    const id = `req_${++requestIdCounter}`;\n    pendingRequests.set(id, {\n        ...request,\n        id,\n    });\n    return id;\n}\n/**\n * Complete a pending request\n * @param requestId - The request ID to complete\n */\nexport function completePendingRequest(requestId) {\n    pendingRequests.delete(requestId);\n}\n/**\n * Get all pending requests\n * @returns Array of pending requests\n */\nexport function getPendingRequests() {\n    return Array.from(pendingRequests.values());\n}\n/**\n * Clear all pending requests\n */\nexport function clearPendingRequests() {\n    pendingRequests.clear();\n}\n/**\n * Get network waterfall snapshot for an error\n * @param errorEntry - The error entry\n * @returns The waterfall snapshot\n */\nexport async function getNetworkWaterfallForError(errorEntry) {\n    if (!networkWaterfallEnabled)\n        return null;\n    const now = typeof performance !== 'undefined' && performance?.now ? performance.now() : 0;\n    const since = Math.max(0, now - WATERFALL_TIME_WINDOW_MS);\n    const entries = getNetworkWaterfall({ since });\n    const pending = getPendingRequests();\n    return {\n        type: 'network_waterfall',\n        ts: new Date().toISOString(),\n        _errorTs: errorEntry.ts,\n        entries,\n        pending,\n    };\n}\n/**\n * Set whether network waterfall is enabled\n * @param enabled - Whether to enable network waterfall\n */\nexport function setNetworkWaterfallEnabled(enabled) {\n    networkWaterfallEnabled = enabled;\n}\n/**\n * Check if network waterfall is enabled\n * @returns Whether network waterfall is enabled\n */\nexport function isNetworkWaterfallEnabled() {\n    return networkWaterfallEnabled;\n}\n// =============================================================================\n// NETWORK BODY CAPTURE\n// =============================================================================\n/**\n * Set whether network body capture is enabled\n * @param enabled - Whether to enable body capture\n */\nexport function setNetworkBodyCaptureEnabled(enabled) {\n    networkBodyCaptureEnabled = enabled;\n}\n/**\n * Check if network body capture is enabled\n * @returns Whether body capture is enabled\n */\nexport function isNetworkBodyCaptureEnabled() {\n    return networkBodyCaptureEnabled;\n}\n/**\n * Set the configured server URL for capture filtering.\n * Called when the server URL is loaded from settings.\n * @param url - The server URL (e.g., 'http://localhost:7890')\n */\nexport function setServerUrl(url) {\n    configuredServerUrl = url || '';\n}\n/**\n * Check if a URL should be captured (not gasoline server or extension)\n * @param url - The URL to check\n * @returns True if the URL should be captured\n */\nexport function shouldCaptureUrl(url) {\n    if (!url)\n        return true;\n    // Filter against the configured server URL if set\n    if (configuredServerUrl) {\n        try {\n            const serverParsed = new URL(configuredServerUrl);\n            const hostPort = serverParsed.host; // e.g., 'localhost:7890'\n            if (url.includes(hostPort))\n                return false;\n        }\n        catch {\n            // Fall through to hardcoded defaults\n        }\n    }\n    // Hardcoded fallback for default server URL\n    if (url.includes('localhost:7890') || url.includes('127.0.0.1:7890'))\n        return false;\n    if (url.startsWith('chrome-extension://'))\n        return false;\n    return true;\n}\n/**\n * Sanitize headers by removing sensitive ones\n * @param headers - Headers to sanitize\n * @returns Sanitized headers object\n */\nexport function sanitizeHeaders(headers) {\n    if (!headers)\n        return {};\n    const result = {};\n    if (headers instanceof Headers || typeof headers.forEach === 'function') {\n        // Headers object or Map\n        ;\n        headers.forEach((value, key) => {\n            if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n                result[key] = value;\n            }\n        });\n    }\n    else if (typeof headers.entries === 'function') {\n        for (const [key, value] of headers.entries()) {\n            if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n                result[key] = value;\n            }\n        }\n    }\n    else if (typeof headers === 'object') {\n        for (const [key, value] of Object.entries(headers)) {\n            if (!SENSITIVE_HEADER_PATTERNS.test(key)) {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Truncate request body at 8KB limit\n * @param body - The request body\n * @returns Truncation result\n */\nexport function truncateRequestBody(body) {\n    if (body === null || body === undefined)\n        return { body: null, truncated: false };\n    if (body.length <= REQUEST_BODY_MAX)\n        return { body, truncated: false };\n    return { body: body.slice(0, REQUEST_BODY_MAX), truncated: true };\n}\n/**\n * Truncate response body at 16KB limit\n * @param body - The response body\n * @returns Truncation result\n */\nexport function truncateResponseBody(body) {\n    if (body === null || body === undefined)\n        return { body: null, truncated: false };\n    if (body.length <= RESPONSE_BODY_MAX)\n        return { body, truncated: false };\n    return { body: body.slice(0, RESPONSE_BODY_MAX), truncated: true };\n}\n/**\n * Read a response body, returning text for text types and size info for binary\n * @param response - The cloned response object\n * @returns The body content or binary size placeholder\n */\nexport async function readResponseBody(response) {\n    const contentType = response.headers?.get?.('content-type') || '';\n    if (BINARY_CONTENT_TYPES.test(contentType)) {\n        const blob = await response.blob();\n        return `[Binary: ${blob.size} bytes, ${contentType}]`;\n    }\n    // Text-like or unknown content type: try reading as text\n    return await response.text();\n}\n/**\n * Read response body with a timeout\n * @param response - The cloned response object\n * @param timeoutMs - Timeout in milliseconds\n * @returns The body or timeout message\n */\nexport async function readResponseBodyWithTimeout(response, timeoutMs = BODY_READ_TIMEOUT_MS) {\n    return Promise.race([\n        readResponseBody(response),\n        new Promise((resolve) => {\n            setTimeout(() => resolve('[Skipped: body read timeout]'), timeoutMs);\n        }),\n    ]);\n}\n/**\n * Reset all module state for testing purposes\n * Clears pending requests, resets counters, and restores default settings.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting() {\n    configuredServerUrl = '';\n    networkWaterfallEnabled = false;\n    pendingRequests.clear();\n    requestIdCounter = 0;\n    networkBodyCaptureEnabled = true;\n}\n/**\n * Wrap a fetch function to capture request/response bodies\n * @param fetchFn - The original fetch function\n * @returns Wrapped fetch that captures bodies\n */\nexport function wrapFetchWithBodies(fetchFn) {\n    return async function (input, init) {\n        const startTime = Date.now();\n        // Extract URL and method\n        let url = '';\n        let method = 'GET';\n        let requestBody = null;\n        if (typeof input === 'string') {\n            url = input;\n        }\n        else if (input && input.url) {\n            url = input.url;\n            method = input.method || 'GET';\n        }\n        if (init) {\n            method = init.method || method;\n            requestBody = init.body || null;\n        }\n        // Skip gasoline server requests\n        if (!shouldCaptureUrl(url)) {\n            return fetchFn(input, init);\n        }\n        // Call original fetch\n        const response = await fetchFn(input, init);\n        const duration = Date.now() - startTime;\n        // Capture body asynchronously (don't block return)\n        const contentType = response.headers?.get?.('content-type') || '';\n        const cloned = response.clone ? response.clone() : null;\n        // Capture window reference now so deferred callback posts to correct target\n        const win = typeof window !== 'undefined' ? window : null;\n        Promise.resolve()\n            .then(async () => {\n            try {\n                let responseBody = '';\n                if (cloned) {\n                    if (BINARY_CONTENT_TYPES.test(contentType)) {\n                        const blob = await cloned.blob();\n                        responseBody = `[Binary: ${blob.size} bytes, ${contentType}]`;\n                    }\n                    else {\n                        responseBody = await readResponseBodyWithTimeout(cloned);\n                    }\n                }\n                const { body: truncResp } = truncateResponseBody(responseBody);\n                const { body: truncReq } = truncateRequestBody(typeof requestBody === 'string' ? requestBody : null);\n                if (win && networkBodyCaptureEnabled) {\n                    const message = {\n                        type: 'GASOLINE_NETWORK_BODY',\n                        payload: {\n                            url,\n                            method,\n                            status: response.status,\n                            contentType,\n                            requestBody: truncReq || (typeof requestBody === 'string' ? requestBody : undefined),\n                            responseBody: truncResp || responseBody,\n                            duration,\n                        },\n                    };\n                    win.postMessage(message, window.location.origin);\n                }\n            }\n            catch {\n                // Body capture failure should not affect user code\n            }\n        })\n            .catch((err) => {\n            // Log but don't throw - body capture is best-effort\n            console.debug('[Gasoline] Network body capture error:', err);\n        });\n        return response;\n    };\n}\n//# sourceMappingURL=network.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/perf-snapshot.js","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":51,"column":14,"nodeType":"MemberExpression","endLine":51,"endColumn":30,"suppressions":[{"kind":"directive","justification":"category from mapInitiatorType returns known resource type strings"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":53,"column":13,"nodeType":"MemberExpression","endLine":53,"endColumn":29,"suppressions":[{"kind":"directive","justification":"category from mapInitiatorType returns known resource type strings"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":56,"column":9,"nodeType":"MemberExpression","endLine":56,"endColumn":25,"suppressions":[{"kind":"directive","justification":"category from mapInitiatorType returns known resource type strings"}]},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":58,"column":9,"nodeType":"MemberExpression","endLine":58,"endColumn":25,"suppressions":[{"kind":"directive","justification":"category from mapInitiatorType returns known resource type strings"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/performance.js","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":106,"column":5,"endLine":106,"endColumn":67,"severity":2,"nodeType":null},{"ruleId":"@typescript-eslint/no-explicit-any","message":"Definition for rule '@typescript-eslint/no-explicit-any' was not found.","line":126,"column":5,"endLine":126,"endColumn":67,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Performance marks and measures capture.\n * Wraps performance.mark/measure to capture calls, uses PerformanceObserver\n * for additional entries, and provides error-time performance snapshots.\n */\nimport { MAX_PERFORMANCE_ENTRIES, PERFORMANCE_TIME_WINDOW_MS } from './constants.js';\n// Performance Marks state\nlet performanceMarksEnabled = false;\nlet capturedMarks = [];\nlet capturedMeasures = [];\nlet originalPerformanceMark = null;\nlet originalPerformanceMeasure = null;\nlet performanceObserver = null;\nlet performanceCaptureActive = false;\n/**\n * Get performance marks\n */\nexport function getPerformanceMarks(options = {}) {\n    if (typeof performance === 'undefined' || !performance)\n        return [];\n    try {\n        let marks = performance.getEntriesByType('mark') || [];\n        // Filter by time range\n        if (options.since) {\n            marks = marks.filter((m) => m.startTime >= options.since);\n        }\n        // Sort by start time\n        marks.sort((a, b) => a.startTime - b.startTime);\n        // Limit entries\n        if (marks.length > MAX_PERFORMANCE_ENTRIES) {\n            marks = marks.slice(-MAX_PERFORMANCE_ENTRIES);\n        }\n        return marks.map((m) => ({\n            name: m.name,\n            startTime: m.startTime,\n            detail: m.detail || null,\n        }));\n    }\n    catch {\n        return [];\n    }\n}\n/**\n * Get performance measures\n */\nexport function getPerformanceMeasures(options = {}) {\n    if (typeof performance === 'undefined' || !performance)\n        return [];\n    try {\n        let measures = performance.getEntriesByType('measure') || [];\n        // Filter by time range\n        if (options.since) {\n            measures = measures.filter((m) => m.startTime >= options.since);\n        }\n        // Sort by start time\n        measures.sort((a, b) => a.startTime - b.startTime);\n        // Limit entries\n        if (measures.length > MAX_PERFORMANCE_ENTRIES) {\n            measures = measures.slice(-MAX_PERFORMANCE_ENTRIES);\n        }\n        return measures.map((m) => ({\n            name: m.name,\n            startTime: m.startTime,\n            duration: m.duration,\n            ...(m.detail !== undefined\n                ? { detail: m.detail }\n                : {}),\n        }));\n    }\n    catch {\n        return [];\n    }\n}\n/**\n * Get captured marks from wrapper\n */\nexport function getCapturedMarks() {\n    return [...capturedMarks];\n}\n/**\n * Get captured measures from wrapper\n */\nexport function getCapturedMeasures() {\n    return [...capturedMeasures];\n}\n/**\n * Install performance capture wrapper\n */\nexport function installPerformanceCapture() {\n    if (typeof performance === 'undefined' || !performance)\n        return;\n    // Guard against double installation (prevents infinite recursion)\n    if (performanceCaptureActive) {\n        console.warn('[Gasoline] Performance capture already installed, skipping');\n        return;\n    }\n    // Clear previous captured data\n    capturedMarks = [];\n    capturedMeasures = [];\n    // Store originals\n    originalPerformanceMark = performance.mark.bind(performance);\n    originalPerformanceMeasure = performance.measure.bind(performance);\n    // Wrap performance.mark\n    // Note: Monkey-patching requires bypassing TypeScript's strict Performance API types.\n    // This is a standard pattern for browser API instrumentation.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const wrappedMark = function (name, options) {\n        const result = originalPerformanceMark.call(performance, name, options);\n        capturedMarks.push({\n            name,\n            startTime: result.startTime || performance.now(),\n            entryType: 'mark',\n            detail: options?.detail || undefined,\n            capturedAt: new Date().toISOString(),\n        });\n        // Limit captured marks\n        if (capturedMarks.length > MAX_PERFORMANCE_ENTRIES) {\n            capturedMarks.shift();\n        }\n        return result;\n    };\n    // Assign the wrapper, bypassing strict type checking for the overloaded method\n    Object.defineProperty(performance, 'mark', { value: wrappedMark, writable: true, configurable: true });\n    // Wrap performance.measure\n    // Note: Monkey-patching requires bypassing TypeScript's strict Performance API types.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const wrappedMeasure = function (name, startMark, endMark) {\n        const result = originalPerformanceMeasure.call(performance, name, startMark, endMark);\n        capturedMeasures.push({\n            name,\n            startTime: result.startTime || 0,\n            duration: result.duration || 0,\n            entryType: 'measure',\n            capturedAt: new Date().toISOString(),\n        });\n        // Limit captured measures\n        if (capturedMeasures.length > MAX_PERFORMANCE_ENTRIES) {\n            capturedMeasures.shift();\n        }\n        return result;\n    };\n    // Assign the wrapper, bypassing strict type checking for the overloaded method\n    Object.defineProperty(performance, 'measure', { value: wrappedMeasure, writable: true, configurable: true });\n    performanceCaptureActive = true;\n    // Try to use PerformanceObserver for additional entries\n    if (typeof window !== 'undefined' && typeof PerformanceObserver !== 'undefined') {\n        try {\n            performanceObserver = new PerformanceObserver((list) => {\n                for (const entry of list.getEntries()) {\n                    if (entry.entryType === 'mark') {\n                        // Avoid duplicates from our wrapper\n                        if (!capturedMarks.some((m) => m.name === entry.name && m.startTime === entry.startTime)) {\n                            capturedMarks.push({\n                                name: entry.name,\n                                startTime: entry.startTime,\n                                entryType: 'mark',\n                                detail: entry.detail || undefined,\n                                capturedAt: new Date().toISOString(),\n                            });\n                        }\n                    }\n                    else if (entry.entryType === 'measure') {\n                        if (!capturedMeasures.some((m) => m.name === entry.name && m.startTime === entry.startTime)) {\n                            capturedMeasures.push({\n                                name: entry.name,\n                                startTime: entry.startTime,\n                                duration: entry.duration,\n                                entryType: 'measure',\n                                capturedAt: new Date().toISOString(),\n                            });\n                        }\n                    }\n                }\n            });\n            if (performanceObserver) {\n                performanceObserver.observe({ entryTypes: ['mark', 'measure'] });\n            }\n        }\n        catch {\n            // PerformanceObserver not supported, continue without it\n        }\n    }\n}\n/**\n * Uninstall performance capture wrapper\n */\nexport function uninstallPerformanceCapture() {\n    if (typeof performance === 'undefined' || !performance)\n        return;\n    if (originalPerformanceMark) {\n        // Restore original performance.mark using Object.defineProperty for clean restoration\n        Object.defineProperty(performance, 'mark', { value: originalPerformanceMark, writable: true, configurable: true });\n        originalPerformanceMark = null;\n    }\n    if (originalPerformanceMeasure) {\n        // Restore original performance.measure using Object.defineProperty for clean restoration\n        Object.defineProperty(performance, 'measure', {\n            value: originalPerformanceMeasure,\n            writable: true,\n            configurable: true,\n        });\n        originalPerformanceMeasure = null;\n    }\n    if (performanceObserver) {\n        performanceObserver.disconnect();\n        performanceObserver = null;\n    }\n    capturedMarks = [];\n    capturedMeasures = [];\n    performanceCaptureActive = false;\n}\n/**\n * Check if performance capture is active\n */\nexport function isPerformanceCaptureActive() {\n    return performanceCaptureActive;\n}\n/**\n * Get performance snapshot for an error\n */\nexport async function getPerformanceSnapshotForError(errorEntry) {\n    if (!performanceMarksEnabled)\n        return null;\n    const now = typeof performance !== 'undefined' && performance?.now ? performance.now() : 0;\n    const since = Math.max(0, now - PERFORMANCE_TIME_WINDOW_MS);\n    const marks = getPerformanceMarks({ since });\n    const measures = getPerformanceMeasures({ since });\n    // Include navigation timing if available\n    let navigation = null;\n    if (typeof performance !== 'undefined' && performance) {\n        try {\n            const navEntries = performance.getEntriesByType('navigation') || [];\n            if (navEntries && navEntries.length > 0) {\n                const nav = navEntries[0];\n                if (nav) {\n                    navigation = {\n                        type: nav.type,\n                        startTime: nav.startTime,\n                        domContentLoadedEventEnd: nav.domContentLoadedEventEnd,\n                        loadEventEnd: nav.loadEventEnd,\n                    };\n                }\n            }\n        }\n        catch {\n            // Navigation timing not available\n        }\n    }\n    return {\n        type: 'performance',\n        ts: new Date().toISOString(),\n        _enrichments: ['performanceMarks'],\n        _errorTs: errorEntry.ts,\n        marks,\n        measures,\n        navigation,\n    };\n}\n/**\n * Set whether performance marks are enabled\n */\nexport function setPerformanceMarksEnabled(enabled) {\n    performanceMarksEnabled = enabled;\n}\n/**\n * Check if performance marks are enabled\n */\nexport function isPerformanceMarksEnabled() {\n    return performanceMarksEnabled;\n}\n//# sourceMappingURL=performance.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/reproduction.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/serialize.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":79,"column":17,"nodeType":"MemberExpression","endLine":79,"endColumn":28},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":79,"column":45,"nodeType":"MemberExpression","endLine":79,"endColumn":58},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":82,"column":17,"nodeType":"MemberExpression","endLine":82,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Serialization utilities for safe value handling.\n * Provides safe serialization with circular reference detection, DOM element\n * selector generation, and sensitive input detection.\n *\n * NOTE: This module has NO mutable state. All functions are pure and stateless.\n * No resetForTesting() function is needed.\n */\nimport { MAX_STRING_LENGTH, MAX_DEPTH, SENSITIVE_INPUT_TYPES } from './constants.js';\n/**\n * Safely serialize a value, handling circular references and special types\n */\nexport function safeSerialize(value, depth = 0, seen = new WeakSet()) {\n    // Handle null/undefined\n    if (value === null)\n        return null;\n    if (value === undefined)\n        return null;\n    // Handle primitives\n    const type = typeof value;\n    if (type === 'string') {\n        const strValue = value;\n        if (strValue.length > MAX_STRING_LENGTH) {\n            return strValue.slice(0, MAX_STRING_LENGTH) + '... [truncated]';\n        }\n        return strValue;\n    }\n    if (type === 'number') {\n        return value;\n    }\n    if (type === 'boolean') {\n        return value;\n    }\n    // Handle functions\n    if (type === 'function') {\n        const fn = value;\n        return `[Function: ${fn.name || 'anonymous'}]`;\n    }\n    // Handle Error objects specially\n    if (value instanceof Error) {\n        return {\n            name: value.name,\n            message: value.message,\n            stack: value.stack || null,\n        };\n    }\n    // Depth limit\n    if (depth >= MAX_DEPTH) {\n        return '[Max depth exceeded]';\n    }\n    // Handle objects\n    if (type === 'object') {\n        const objValue = value;\n        // Circular reference check\n        if (seen.has(objValue)) {\n            return '[Circular]';\n        }\n        seen.add(objValue);\n        // Handle DOM elements\n        const domLike = value;\n        if (domLike.nodeType) {\n            const tag = domLike.tagName ? domLike.tagName.toLowerCase() : 'node';\n            const id = domLike.id ? `#${domLike.id}` : '';\n            const classNameValue = domLike.className;\n            let className = '';\n            if (typeof classNameValue === 'string' && classNameValue) {\n                className = `.${classNameValue.split(' ').join('.')}`;\n            }\n            return `[${tag}${id}${className}]`;\n        }\n        // Handle arrays (cap at 100 elements to prevent OOM)\n        if (Array.isArray(value)) {\n            return value.slice(0, 100).map((item) => safeSerialize(item, depth + 1, seen));\n        }\n        // Handle plain objects (cap at 50 keys to prevent OOM)\n        const result = {};\n        for (const key of Object.keys(objValue).slice(0, 50)) {\n            try {\n                result[key] = safeSerialize(objValue[key], depth + 1, seen);\n            }\n            catch {\n                result[key] = '[Unserializable]';\n            }\n        }\n        return result;\n    }\n    return String(value);\n}\n/**\n * Get element selector for identification\n */\nexport function getElementSelector(element) {\n    if (!element || !element.tagName)\n        return '';\n    const tag = element.tagName.toLowerCase();\n    const id = element.id ? `#${element.id}` : '';\n    let classes = '';\n    const classNameValue = element.className;\n    if (classNameValue && typeof classNameValue === 'string') {\n        classes = '.' + classNameValue.trim().split(/\\s+/).slice(0, 2).join('.');\n    }\n    // Add data-testid if present\n    const testId = element.getAttribute('data-testid');\n    const testIdStr = testId ? `[data-testid=\"${testId}\"]` : '';\n    return `${tag}${id}${classes}${testIdStr}`.slice(0, 100);\n}\n/**\n * Check if an input contains sensitive data\n */\nexport function isSensitiveInput(element) {\n    if (!element)\n        return false;\n    const inputElement = element;\n    const type = (inputElement.type || '').toLowerCase();\n    const autocomplete = (inputElement.autocomplete || '').toLowerCase();\n    const name = (inputElement.name || '').toLowerCase();\n    // Check type attribute\n    if (SENSITIVE_INPUT_TYPES.includes(type))\n        return true;\n    // Check autocomplete attribute\n    if (autocomplete.includes('password') || autocomplete.includes('cc-') || autocomplete.includes('credit-card'))\n        return true;\n    // Check name attribute for common patterns\n    if (name.includes('password') ||\n        name.includes('passwd') ||\n        name.includes('secret') ||\n        name.includes('token') ||\n        name.includes('credit') ||\n        name.includes('card') ||\n        name.includes('cvv') ||\n        name.includes('cvc') ||\n        name.includes('ssn'))\n        return true;\n    return false;\n}\n//# sourceMappingURL=serialize.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/timeout-utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/version.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/lib/websocket.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":38,"column":30,"nodeType":"MemberExpression","endLine":38,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":49,"column":30,"nodeType":"MemberExpression","endLine":49,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":151,"column":13,"nodeType":"MemberExpression","endLine":151,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":152,"column":13,"nodeType":"MemberExpression","endLine":152,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":153,"column":13,"nodeType":"MemberExpression","endLine":153,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":155,"column":17,"nodeType":"MemberExpression","endLine":155,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview WebSocket capture.\n * Wraps the WebSocket constructor to intercept lifecycle events and messages,\n * with adaptive sampling, schema detection, and truncation.\n */\nimport { WS_MAX_BODY_SIZE, WS_PREVIEW_LIMIT } from './constants.js';\n// Cached TextEncoder instance to avoid per-call allocation in getSize() hot path\nconst _textEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;\n// WebSocket capture state\nlet originalWebSocket = null;\nlet webSocketCaptureEnabled = true;\nlet webSocketCaptureMode = 'medium';\n/**\n * Get the byte size of a WebSocket message\n */\nexport function getSize(data) {\n    if (typeof data === 'string') {\n        return _textEncoder ? _textEncoder.encode(data).length : data.length;\n    }\n    if (data instanceof ArrayBuffer)\n        return data.byteLength;\n    if (data && typeof data === 'object' && 'size' in data)\n        return data.size;\n    return 0;\n}\n/**\n * Format a WebSocket payload for logging\n */\nexport function formatPayload(data) {\n    if (typeof data === 'string')\n        return data;\n    if (data instanceof ArrayBuffer) {\n        const bytes = new Uint8Array(data);\n        if (data.byteLength < 256) {\n            // Small binary: hex preview\n            let hex = '';\n            for (let i = 0; i < bytes.length; i++) {\n                const byte = bytes[i];\n                if (byte !== undefined) {\n                    hex += byte.toString(16).padStart(2, '0');\n                }\n            }\n            return `[Binary: ${data.byteLength}B] ${hex}`;\n        }\n        else {\n            // Large binary: size + magic bytes (first 4 bytes)\n            let magic = '';\n            for (let i = 0; i < Math.min(4, bytes.length); i++) {\n                const byte = bytes[i];\n                if (byte !== undefined) {\n                    magic += byte.toString(16).padStart(2, '0');\n                }\n            }\n            return `[Binary: ${data.byteLength}B, magic:${magic}]`;\n        }\n    }\n    // Blob or Blob-like\n    if (data && typeof data === 'object' && 'size' in data) {\n        return `[Binary: ${data.size}B]`;\n    }\n    return String(data);\n}\n/**\n * Truncate a WebSocket message to the size limit\n */\nexport function truncateWsMessage(message) {\n    if (typeof message === 'string' && message.length > WS_MAX_BODY_SIZE) {\n        return { data: message.slice(0, WS_MAX_BODY_SIZE), truncated: true };\n    }\n    return { data: message, truncated: false };\n}\n/**\n * Create a connection tracker for adaptive sampling and schema detection\n */\nexport function createConnectionTracker(id, url) {\n    const tracker = {\n        id,\n        url,\n        messageCount: 0,\n        _sampleCounter: 0,\n        _messageRate: 0,\n        _messageTimestamps: [],\n        _schemaKeys: [],\n        _schemaVariants: new Map(),\n        _schemaConsistent: true,\n        _schemaDetected: false,\n        stats: {\n            incoming: { count: 0, bytes: 0, lastPreview: null, lastAt: null },\n            outgoing: { count: 0, bytes: 0, lastPreview: null, lastAt: null },\n        },\n        /**\n         * Record a message for stats and schema detection\n         *\n         * WEBSOCKET PAYLOAD SCHEMA INFERENCE LOGIC:\n         *\n         * This method implements a three-phase schema detection strategy to identify the\n         * shape of JSON messages flowing over a WebSocket connection. Understanding the\n         * schema is crucial for debugging: it reveals whether messages are uniform (good\n         * for testing) or polymorphic (suggests different message types or errors).\n         *\n         * PHASE 1: BOOTSTRAP DETECTION (messages 1-5)\n         *   Purpose: Quickly infer the \"canonical\" schema from the first JSON messages.\n         *   Strategy:\n         *     - Extract sorted object keys from each incoming JSON message\n         *     - Stop after 5 messages (samples are enough to detect schema; balance between\n         *       coverage and memory/CPU cost)\n         *     - Compute consistency: if all 5 messages have identical key sets, mark as\n         *       consistent=true\n         *     - Store key strings as comma-separated sorted lists (e.g., \"id,status,timestamp\")\n         *   Why 5: Statistically sufficient for most API patterns. First message might be\n         *     special (connection ACK). By message 5, the pattern is clear.\n         *   Early exit: If not JSON or message is array, skip (only track object schemas).\n         *\n         * PHASE 2: CONSISTENCY CHECKING (after first 2 messages)\n         *   Trigger: Once _schemaKeys.length >= 2, begin checking if all keys match the first.\n         *   Result: Sets _schemaConsistent = boolean indicating if messages have uniform schema.\n         *   Why check early: Detect schema changes immediately without waiting for all 5 messages.\n         *   Performance: O(n) single pass over _schemaKeys array; no redundant comparisons.\n         *\n         * PHASE 3: VARIANT TRACKING (messages 6+)\n         *   Purpose: After bootstrap, track schema variants without resetting detection.\n         *   Strategy:\n         *     - Continue parsing incoming JSON messages after _schemaDetected = true\n         *     - Build variants Map: key -> count (e.g., \"id,status\" -> 5 occurrences)\n         *     - Memory bound: Cap Map at 50 entries. Only add new variants if under cap;\n         *       always increment existing keys (ensures frequent patterns stay tracked).\n         *     - This bounds memory to ~50KB even on long-lived connections.\n         *   Why variants matter: Detects polymorphic message types (e.g., \"id,status,data\"\n         *     vs \"id,error,code\"). Useful for debugging API versioning issues.\n         *   Why cap variants: Long-running connections might emit hundreds of unique schemas.\n         *     Capping prevents unbounded growth while keeping the 50 most frequent variants.\n         *\n         * SAMPLING RATE DECISION:\n         *   The schema info (keys, consistency, variants) flows to getSchema() which returns:\n         *     - detectedKeys: union of all seen keys (for understanding message structure)\n         *     - consistent: boolean (true if all bootstrap messages matched)\n         *     - variants: array of key strings (top variants seen after bootstrap)\n         *   MCP observe handler uses this to emit SchemaInfo in WebSocket capture events,\n         *   helping users understand payload patterns without logging every message.\n         *\n         * MESSAGE RATE TRACKING:\n         *   Maintains _messageTimestamps for the last 5 seconds (sliding window). This powers\n         *   shouldSample() which implements adaptive sampling: high-frequency connections\n         *   (>200 msg/s) sample at 1-in-100; low-frequency (<2 msg/s) capture all messages.\n         *   This ensures detailed visibility on slow links without bloating on high-volume.\n        */\n        recordMessage(direction, data) {\n            this.messageCount++;\n            const size = data ? (typeof data === 'string' ? data.length : getSize(data)) : 0;\n            const now = Date.now();\n            this.stats[direction].count++;\n            this.stats[direction].bytes += size;\n            this.stats[direction].lastAt = now;\n            if (data && typeof data === 'string') {\n                this.stats[direction].lastPreview = data.length > WS_PREVIEW_LIMIT ? data.slice(0, WS_PREVIEW_LIMIT) : data;\n            }\n            // Track timestamps for rate calculation\n            this._messageTimestamps.push(now);\n            // Keep only last 5 seconds\n            const cutoff = now - 5000;\n            this._messageTimestamps = this._messageTimestamps.filter((t) => t >= cutoff);\n            // Schema detection from first 5 incoming JSON messages\n            if (direction === 'incoming' && data && typeof data === 'string' && this._schemaKeys.length < 5) {\n                try {\n                    const parsed = JSON.parse(data);\n                    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n                        const keys = Object.keys(parsed).sort();\n                        const keyStr = keys.join(',');\n                        this._schemaKeys.push(keyStr);\n                        // Track variants\n                        this._schemaVariants.set(keyStr, (this._schemaVariants.get(keyStr) || 0) + 1);\n                        // Check consistency after 2+ messages\n                        if (this._schemaKeys.length >= 2) {\n                            const first = this._schemaKeys[0];\n                            this._schemaConsistent = this._schemaKeys.every((k) => k === first);\n                        }\n                        if (this._schemaKeys.length >= 5) {\n                            this._schemaDetected = true;\n                        }\n                    }\n                }\n                catch {\n                    // Not JSON, no schema\n                }\n            }\n            // Track variants for messages beyond the first 5 (cap at 50 to bound memory)\n            if (direction === 'incoming' && data && typeof data === 'string' && this._schemaDetected) {\n                try {\n                    const parsed = JSON.parse(data);\n                    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n                        const keys = Object.keys(parsed).sort();\n                        const keyStr = keys.join(',');\n                        // Only add new variants if under cap; always increment existing\n                        if (this._schemaVariants.has(keyStr) || this._schemaVariants.size < 50) {\n                            this._schemaVariants.set(keyStr, (this._schemaVariants.get(keyStr) || 0) + 1);\n                        }\n                    }\n                }\n                catch {\n                    // Not JSON\n                }\n            }\n        },\n        /**\n         * Determine if a message should be sampled (logged)\n         */\n        shouldSample(_direction) {\n            this._sampleCounter++;\n            // 'all' mode: no sampling\n            if (webSocketCaptureMode === 'all')\n                return true;\n            // Always log first 5 messages on a connection\n            if (this.messageCount > 0 && this.messageCount <= 5)\n                return true;\n            const rate = this._messageRate || this.getMessageRate();\n            // Mode-based target caps:\n            // 'high': ~10 msg/s, 'medium': ~5 msg/s, 'low': ~2 msg/s\n            const targetRate = webSocketCaptureMode === 'high' ? 10 : webSocketCaptureMode === 'medium' ? 5 : 2;\n            if (rate <= targetRate)\n                return true;\n            const n = Math.max(1, Math.round(rate / targetRate));\n            return this._sampleCounter % n === 0;\n        },\n        /**\n         * Lifecycle events should always be logged\n         */\n        shouldLogLifecycle() {\n            return true;\n        },\n        /**\n         * Get sampling info\n         */\n        getSamplingInfo() {\n            const rate = this._messageRate || this.getMessageRate();\n            let targetRate = rate;\n            if (rate >= 10 && rate < 50)\n                targetRate = 10;\n            else if (rate >= 50 && rate < 200)\n                targetRate = 5;\n            else if (rate >= 200)\n                targetRate = 2;\n            return {\n                rate: `${rate}/s`,\n                logged: `${targetRate}/${Math.round(rate)}`,\n                window: '5s',\n            };\n        },\n        /**\n         * Get the current message rate (messages per second)\n         */\n        getMessageRate() {\n            if (this._messageTimestamps.length < 2)\n                return this._messageTimestamps.length;\n            const lastTime = this._messageTimestamps[this._messageTimestamps.length - 1];\n            const firstTime = this._messageTimestamps[0];\n            if (lastTime === undefined || firstTime === undefined)\n                return this._messageTimestamps.length;\n            const window = (lastTime - firstTime) / 1000;\n            return window > 0 ? this._messageTimestamps.length / window : this._messageTimestamps.length;\n        },\n        /**\n         * Set the message rate manually (for testing)\n         */\n        setMessageRate(rate) {\n            this._messageRate = rate;\n        },\n        /**\n         * Get the detected schema info\n         */\n        getSchema() {\n            if (this._schemaKeys.length === 0) {\n                return { detectedKeys: null, consistent: true };\n            }\n            // Get union of all detected keys\n            const allKeys = new Set();\n            for (const keyStr of this._schemaKeys) {\n                for (const k of keyStr.split(',')) {\n                    if (k)\n                        allKeys.add(k);\n                }\n            }\n            // Build variants list\n            const variants = [];\n            for (const [keyStr, count] of this._schemaVariants) {\n                if (count > 0)\n                    variants.push(keyStr);\n            }\n            return {\n                detectedKeys: allKeys.size > 0 ? Array.from(allKeys).sort() : null,\n                consistent: this._schemaConsistent,\n                variants: variants.length > 1 ? variants : undefined,\n            };\n        },\n        /**\n         * Check if a message represents a schema change\n         */\n        isSchemaChange(data) {\n            if (!this._schemaDetected || !data || typeof data !== 'string')\n                return false;\n            try {\n                const parsed = JSON.parse(data);\n                if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed))\n                    return false;\n                const keys = Object.keys(parsed)\n                    .sort()\n                    .join(',');\n                // It's a change if none of the first 5 schemas match\n                return !this._schemaKeys.includes(keys);\n            }\n            catch {\n                return false;\n            }\n        },\n    };\n    return tracker;\n}\n/**\n * Install WebSocket capture by wrapping the WebSocket constructor.\n * If the early-patch script ran first (world: \"MAIN\", document_start),\n * uses the saved original constructor and adopts buffered connections.\n */\nexport function installWebSocketCapture() {\n    if (typeof window === 'undefined')\n        return;\n    if (!window.WebSocket)\n        return; // No WebSocket support\n    if (originalWebSocket)\n        return; // Already installed\n    // Check for early-patch: use the saved original, not the early-patch wrapper\n    const earlyOriginal = window.__GASOLINE_ORIGINAL_WS__;\n    originalWebSocket = earlyOriginal || window.WebSocket;\n    const OriginalWS = originalWebSocket;\n    function GasolineWebSocket(url, protocols) {\n        const ws = new OriginalWS(url, protocols);\n        const connectionId = crypto.randomUUID();\n        const urlString = url.toString();\n        const tracker = createConnectionTracker(connectionId, urlString);\n        ws.addEventListener('open', () => {\n            if (!webSocketCaptureEnabled)\n                return;\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: { type: 'websocket', event: 'open', id: connectionId, url: urlString, ts: new Date().toISOString() },\n            }, window.location.origin);\n        });\n        ws.addEventListener('close', (event) => {\n            if (!webSocketCaptureEnabled)\n                return;\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: {\n                    type: 'websocket',\n                    event: 'close',\n                    id: connectionId,\n                    url: urlString,\n                    code: event.code,\n                    reason: event.reason,\n                    ts: new Date().toISOString(),\n                },\n            }, window.location.origin);\n        });\n        ws.addEventListener('error', () => {\n            if (!webSocketCaptureEnabled)\n                return;\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: {\n                    type: 'websocket',\n                    event: 'error',\n                    id: connectionId,\n                    url: urlString,\n                    ts: new Date().toISOString(),\n                },\n            }, window.location.origin);\n        });\n        ws.addEventListener('message', (event) => {\n            if (!webSocketCaptureEnabled)\n                return;\n            tracker.recordMessage('incoming', event.data);\n            if (!tracker.shouldSample('incoming'))\n                return;\n            const data = event.data;\n            const size = getSize(data);\n            const formatted = formatPayload(data);\n            const { data: truncatedData, truncated } = truncateWsMessage(formatted);\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: {\n                    type: 'websocket',\n                    event: 'message',\n                    id: connectionId,\n                    url: urlString,\n                    direction: 'incoming',\n                    data: truncatedData,\n                    size,\n                    truncated: truncated || undefined,\n                    ts: new Date().toISOString(),\n                },\n            }, window.location.origin);\n        });\n        // Wrap send() to capture outgoing messages\n        const originalSend = ws.send.bind(ws);\n        ws.send = function (data) {\n            if (webSocketCaptureEnabled) {\n                tracker.recordMessage('outgoing', data);\n            }\n            if (webSocketCaptureEnabled && tracker.shouldSample('outgoing')) {\n                const size = getSize(data);\n                const formatted = formatPayload(data);\n                const { data: truncatedData, truncated } = truncateWsMessage(formatted);\n                window.postMessage({\n                    type: 'GASOLINE_WS',\n                    payload: {\n                        type: 'websocket',\n                        event: 'message',\n                        id: connectionId,\n                        url: urlString,\n                        direction: 'outgoing',\n                        data: truncatedData,\n                        size,\n                        truncated: truncated || undefined,\n                        ts: new Date().toISOString(),\n                    },\n                }, '*');\n            }\n            return originalSend(data);\n        };\n        return ws;\n    }\n    // Set up prototype chain and static properties\n    GasolineWebSocket.prototype = OriginalWS.prototype;\n    Object.defineProperty(GasolineWebSocket, 'CONNECTING', { value: OriginalWS.CONNECTING, writable: false });\n    Object.defineProperty(GasolineWebSocket, 'OPEN', { value: OriginalWS.OPEN, writable: false });\n    Object.defineProperty(GasolineWebSocket, 'CLOSING', { value: OriginalWS.CLOSING, writable: false });\n    Object.defineProperty(GasolineWebSocket, 'CLOSED', { value: OriginalWS.CLOSED, writable: false });\n    window.WebSocket = GasolineWebSocket;\n    // Adopt connections buffered by the early-patch script\n    adoptEarlyConnections();\n}\n/**\n * Adopt WebSocket connections buffered by the early-patch script.\n * For each still-active connection, creates a tracker and attaches event listeners\n * so ongoing messages are captured. Posts synthetic \"open\" events for connections\n * that opened before the inject script loaded.\n */\nfunction adoptEarlyConnections() {\n    const earlyConnections = window.__GASOLINE_EARLY_WS__;\n    if (!earlyConnections || earlyConnections.length === 0) {\n        // Clean up globals even if no connections\n        delete window.__GASOLINE_ORIGINAL_WS__;\n        delete window.__GASOLINE_EARLY_WS__;\n        return;\n    }\n    let adopted = 0;\n    for (const conn of earlyConnections) {\n        const ws = conn.ws;\n        // Skip fully closed connections\n        if (ws.readyState === WebSocket.CLOSED)\n            continue;\n        adopted++;\n        const connectionId = crypto.randomUUID();\n        const urlString = conn.url;\n        const tracker = createConnectionTracker(connectionId, urlString);\n        // Post synthetic \"open\" event for connections that already opened\n        const hasOpened = conn.events.some((e) => e.type === 'open');\n        if (hasOpened && webSocketCaptureEnabled) {\n            const openEvent = conn.events.find((e) => e.type === 'open');\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: {\n                    type: 'websocket',\n                    event: 'open',\n                    id: connectionId,\n                    url: urlString,\n                    ts: openEvent ? new Date(openEvent.ts).toISOString() : new Date().toISOString(),\n                },\n            }, window.location.origin);\n        }\n        // Attach ongoing capture: close\n        ws.addEventListener('close', (event) => {\n            if (!webSocketCaptureEnabled)\n                return;\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: {\n                    type: 'websocket',\n                    event: 'close',\n                    id: connectionId,\n                    url: urlString,\n                    code: event.code,\n                    reason: event.reason,\n                    ts: new Date().toISOString(),\n                },\n            }, window.location.origin);\n        });\n        // Attach ongoing capture: error\n        ws.addEventListener('error', () => {\n            if (!webSocketCaptureEnabled)\n                return;\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: { type: 'websocket', event: 'error', id: connectionId, url: urlString, ts: new Date().toISOString() },\n            }, window.location.origin);\n        });\n        // Attach ongoing capture: incoming messages\n        ws.addEventListener('message', (event) => {\n            if (!webSocketCaptureEnabled)\n                return;\n            tracker.recordMessage('incoming', event.data);\n            if (!tracker.shouldSample('incoming'))\n                return;\n            const data = event.data;\n            const size = getSize(data);\n            const formatted = formatPayload(data);\n            const { data: truncatedData, truncated } = truncateWsMessage(formatted);\n            window.postMessage({\n                type: 'GASOLINE_WS',\n                payload: {\n                    type: 'websocket',\n                    event: 'message',\n                    id: connectionId,\n                    url: urlString,\n                    direction: 'incoming',\n                    data: truncatedData,\n                    size,\n                    truncated: truncated || undefined,\n                    ts: new Date().toISOString(),\n                },\n            }, window.location.origin);\n        });\n        // Wrap send() for outgoing capture\n        const originalSend = ws.send.bind(ws);\n        ws.send = function (data) {\n            if (webSocketCaptureEnabled) {\n                tracker.recordMessage('outgoing', data);\n            }\n            if (webSocketCaptureEnabled && tracker.shouldSample('outgoing')) {\n                const size = getSize(data);\n                const formatted = formatPayload(data);\n                const { data: truncatedData, truncated } = truncateWsMessage(formatted);\n                window.postMessage({\n                    type: 'GASOLINE_WS',\n                    payload: {\n                        type: 'websocket',\n                        event: 'message',\n                        id: connectionId,\n                        url: urlString,\n                        direction: 'outgoing',\n                        data: truncatedData,\n                        size,\n                        truncated: truncated || undefined,\n                        ts: new Date().toISOString(),\n                    },\n                }, '*');\n            }\n            return originalSend(data);\n        };\n    }\n    if (adopted > 0) {\n        console.log(`[Gasoline] Adopted ${adopted} early WebSocket connection(s)`);\n    }\n    // Clean up early-patch globals\n    delete window.__GASOLINE_ORIGINAL_WS__;\n    delete window.__GASOLINE_EARLY_WS__;\n}\n/**\n * Set the WebSocket capture mode\n */\nexport function setWebSocketCaptureMode(mode) {\n    webSocketCaptureMode = mode;\n}\n/**\n * Set WebSocket capture enabled state\n */\nexport function setWebSocketCaptureEnabled(enabled) {\n    webSocketCaptureEnabled = enabled;\n}\n/**\n * Get the current WebSocket capture mode\n */\nexport function getWebSocketCaptureMode() {\n    return webSocketCaptureMode;\n}\n/**\n * Uninstall WebSocket capture, restoring the original constructor\n */\nexport function uninstallWebSocketCapture() {\n    if (typeof window === 'undefined')\n        return;\n    if (originalWebSocket) {\n        window.WebSocket = originalWebSocket;\n        originalWebSocket = null;\n    }\n}\n/**\n * Reset all module state for testing purposes\n * Restores original WebSocket if installed, resets capture settings to defaults.\n * Call this in beforeEach/afterEach test hooks to prevent test pollution.\n */\nexport function resetForTesting() {\n    uninstallWebSocketCapture();\n    webSocketCaptureEnabled = false;\n    webSocketCaptureMode = 'medium';\n    originalWebSocket = null;\n    // Clean up early-patch globals if present\n    if (typeof window !== 'undefined') {\n        delete window.__GASOLINE_ORIGINAL_WS__;\n        delete window.__GASOLINE_EARLY_WS__;\n    }\n}\n//# sourceMappingURL=websocket.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/options.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/ai-web-pilot.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/feature-toggles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/settings.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/status-display.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/tab-tracking.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/popup/ui-utils.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":14,"column":68,"nodeType":"MemberExpression","endLine":14,"endColumn":76}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview Popup UI Utilities\n * Helper functions for UI updates\n */\n/**\n * Format bytes into human-readable file size\n */\nexport function formatFileSize(bytes) {\n    if (bytes === 0)\n        return '0 B';\n    const units = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);\n    const value = bytes / Math.pow(1024, i);\n    return `${value < 10 ? value.toFixed(1) : Math.round(value)} ${units[i]}`;\n}\n/**\n * Check if a URL is an internal browser page that cannot be tracked.\n * Chrome blocks content scripts from these pages, so tracking is impossible.\n */\nexport function isInternalUrl(url) {\n    if (!url)\n        return true;\n    const internalPrefixes = ['chrome://', 'chrome-extension://', 'about:', 'edge://', 'brave://', 'devtools://'];\n    return internalPrefixes.some((prefix) => url.startsWith(prefix));\n}\n//# sourceMappingURL=ui-utils.js.map","usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/accessibility.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/actions.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/ai-context.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/chrome.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/debug.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/dom.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/messages.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/network.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/performance.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/queries.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/runtime-messages.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/sourcemap.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/state.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/telemetry.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/utils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/extension/types/websocket.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/packages/gasoline-ci/gasoline-ci.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/packages/gasoline-playwright/index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/scripts/bundle-content.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/scripts/fix-imports.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/cli-integration.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/config.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/doctor.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/errors.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/install.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/output.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/cli/uninstall.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/a11y-query.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/a11y-runtime-error.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/ai-context.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/async-timeout.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/background.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/capture-control.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/circuit-breaker.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/content-tab-filtering.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/content.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/dom-query.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/favicon-replacer.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/fixtures/test-server.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/helpers.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/inject.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/integration.test.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/interception-deferral.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/log-quality.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/memory.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/network-bodies.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/network-body-e2e.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/network-body-install.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/network-waterfall.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/on-demand.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/options.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/performance-marks.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/performance-snapshot.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/performance.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/pilot-execute.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/pilot-highlight.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/pilot-state.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/pilot-toggle.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/popup.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/rate-limit.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/refactoring-verification.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/reliability-fixes.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/reproduction-script.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/web-vitals.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/brenn/dev/gasoline/tests/extension/websocket.test.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
