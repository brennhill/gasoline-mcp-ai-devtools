# generate_test v2 — Specification

## Motivation

Two observations drive this feature:

1. **The "no tests" problem.** Vibe-coded apps (AI-generated or AI-assisted) ship with zero test coverage. When something breaks, there's no regression safety net. Manual QA catches bugs late; automated tests catch them at commit time.

2. **Passive capture is the perfect test oracle.** Gasoline already observes the "working state" of an app: what the user clicked, what the API returned, what the DOM showed, and whether errors occurred. If we snapshot this working state into a test, any future regression is caught automatically.

The existing `generate_test` tool produces a basic Playwright script with status-code assertions. This spec extends it into a full regression test generator that captures **expected application state** at each step.

---

## What Exists Today

| Tool | What it does | Limitations |
|------|-------------|-------------|
| `get_reproduction_script` | Playwright action replay | No assertions, bug-focused |
| `get_session_timeline` | Correlated timeline (actions + network + console) | Read-only, no test output |
| `generate_test` | Playwright test with network/error assertions | No DOM state, no fixtures, no visual, no Cypress |

---

## What v2 Adds

| Capability | Description |
|-----------|-------------|
| **DOM state assertions** | Capture visible text/elements after each action; assert they render correctly |
| **API fixture generation** | Turn captured responses into mock fixtures for isolated testing |
| **Visual snapshot hooks** | Insert `expect(page).toHaveScreenshot()` at key steps |
| **Response contract assertions** | Assert full response shape (deep), not just status codes |
| **Multi-step wait strategies** | Use network idle / DOM stable signals instead of arbitrary timeouts |
| **Console cleanliness assertion** | Assert zero errors for the entire flow (already exists, enhanced) |
| **Test metadata comments** | Annotate generated tests with capture timestamp, URL, session duration |

---

## MCP Tool Definition

```json
{
  "name": "generate_test",
  "description": "Generate a Playwright regression test from a captured user session. Includes assertions for DOM state, network responses, and error-free execution. Turns a working session into a test that catches future regressions.",
  "inputSchema": {
    "type": "object",
    "properties": {
      "test_name": {
        "type": "string",
        "description": "Name for the generated test (default: derived from page URL and actions)"
      },
      "last_n_actions": {
        "type": "number",
        "description": "Scope to the last N user actions and their consequences (default: all)"
      },
      "base_url": {
        "type": "string",
        "description": "Replace origins in URLs (e.g., 'http://localhost:3000'). Enables portability."
      },
      "assertions": {
        "type": "object",
        "description": "Control which assertions are generated",
        "properties": {
          "network": {
            "type": "boolean",
            "description": "Assert API response status codes (default: true)"
          },
          "response_shape": {
            "type": "boolean",
            "description": "Assert response body structure via toHaveProperty (default: true)"
          },
          "no_errors": {
            "type": "boolean",
            "description": "Assert no console errors during the flow (default: true)"
          },
          "dom_state": {
            "type": "boolean",
            "description": "Assert visible DOM text/elements after navigation and key actions (default: true)"
          },
          "visual": {
            "type": "boolean",
            "description": "Insert toHaveScreenshot() at navigation steps (default: false)"
          }
        }
      },
      "fixtures": {
        "type": "boolean",
        "description": "Generate API mock fixtures from captured responses (default: false)"
      },
      "url_filter": {
        "type": "string",
        "description": "Only include actions/network on pages matching this URL substring"
      }
    }
  }
}
```

---

## Generated Test Structure

### Full Example

```javascript
// Generated by Gasoline from captured session
// Captured: 2025-01-20T14:30:00Z
// Duration: 12.5s (8 actions, 5 API calls, 0 errors)
// URL: http://localhost:3000/login → /dashboard

import { test, expect } from '@playwright/test';

test('login and view dashboard', async ({ page }) => {
  // Track console errors throughout the test
  const consoleErrors = [];
  page.on('console', msg => {
    if (msg.type() === 'error') consoleErrors.push(msg.text());
  });

  // Step 1: Navigate to login page
  await page.goto('http://localhost:3000/login');
  await expect(page.getByRole('heading', { name: 'Sign In' })).toBeVisible();

  // Step 2: Fill email
  await page.getByTestId('email-input').fill('user@example.com');

  // Step 3: Fill password
  await page.getByTestId('password-input').fill('[user-provided]');

  // Step 4: Click login (triggers POST /api/auth/login)
  const loginResponse = page.waitForResponse(
    resp => resp.url().includes('/api/auth/login') && resp.request().method() === 'POST'
  );
  await page.getByRole('button', { name: 'Log in' }).click();

  // Assert: login API responded correctly
  const loginResp = await loginResponse;
  expect(loginResp.status()).toBe(200);
  const loginBody = await loginResp.json();
  expect(loginBody).toHaveProperty('token');
  expect(loginBody).toHaveProperty('user');
  expect(loginBody.user).toHaveProperty('id');
  expect(loginBody.user).toHaveProperty('email');

  // Step 5: Navigation to dashboard
  await expect(page).toHaveURL(/\/dashboard/);

  // Assert: dashboard page rendered expected content
  await expect(page.getByRole('heading', { name: 'Dashboard' })).toBeVisible();
  await expect(page.getByTestId('user-greeting')).toContainText('Welcome');

  // Assert: GET /api/dashboard/stats responded correctly
  const statsResp = await page.waitForResponse(
    resp => resp.url().includes('/api/dashboard/stats')
  );
  expect(statsResp.status()).toBe(200);
  const statsBody = await statsResp.json();
  expect(statsBody).toHaveProperty('totalUsers');
  expect(statsBody).toHaveProperty('activeToday');

  // Final assertion: no console errors during the entire flow
  expect(consoleErrors).toHaveLength(0);
});
```

### With Fixtures

When `fixtures: true`, a companion file is generated:

```javascript
// fixtures/login-and-view-dashboard.fixtures.js
// Generated by Gasoline — captured API responses for mocking

export const fixtures = {
  'POST /api/auth/login': {
    status: 200,
    contentType: 'application/json',
    body: {
      token: 'mock-token-value',
      user: { id: 1, email: 'user@example.com', name: 'Test User' }
    }
  },
  'GET /api/dashboard/stats': {
    status: 200,
    contentType: 'application/json',
    body: {
      totalUsers: 150,
      activeToday: 23,
      revenue: { amount: 4500, currency: 'USD' }
    }
  }
};
```

And the test includes a route-mocking variant:

```javascript
test('login and view dashboard (mocked)', async ({ page }) => {
  const { fixtures } = await import('./fixtures/login-and-view-dashboard.fixtures.js');

  // Mock API responses
  await page.route('**/api/auth/login', route => {
    route.fulfill({
      status: fixtures['POST /api/auth/login'].status,
      contentType: fixtures['POST /api/auth/login'].contentType,
      body: JSON.stringify(fixtures['POST /api/auth/login'].body)
    });
  });
  await page.route('**/api/dashboard/stats', route => {
    route.fulfill({
      status: fixtures['GET /api/dashboard/stats'].status,
      contentType: fixtures['GET /api/dashboard/stats'].contentType,
      body: JSON.stringify(fixtures['GET /api/dashboard/stats'].body)
    });
  });

  // ... same action steps ...
});
```

---

## Feature Details

### 1. DOM State Assertions

**Problem:** The current `generate_test` only asserts network responses. A page could return 200 but render nothing — or render the wrong thing.

**Solution:** After navigation actions and after clicks that trigger visible changes, query the live DOM (via existing `query_dom` tool) to capture what's visible, then emit assertions.

**When to capture DOM state:**
- After `page.goto()` — assert the page's primary heading or landmark
- After navigation actions — assert the new page rendered
- After clicks that trigger API calls — assert the response rendered in the DOM

**What to capture:**
- Visible headings (`h1`, `h2`) — `toBeVisible()`
- Elements with test IDs that contain text — `toContainText()`
- Role landmarks — `toBeVisible()`

**How it works in the pipeline:**

```
1. Timeline is constructed (existing)
2. For each action that triggers navigation or an API call:
   a. Query the DOM at the page URL that follows
   b. Find the first visible heading
   c. Find elements with data-testid that have text content
   d. Emit assertions for up to 3 DOM elements per step
```

**Implementation approach:** The DOM capture happens at session-capture time via the existing `query_dom` mechanism. The extension already tracks what's on the page. The server correlates DOM snapshots with timeline entries.

**New data needed from extension:**

```javascript
// After each navigation or significant action, capture:
{
  type: 'DOM_SNAPSHOT',
  timestamp: Date.now(),
  url: location.href,
  elements: [
    { selector: 'h1', text: 'Dashboard', role: 'heading', level: 1 },
    { selector: '[data-testid="user-greeting"]', text: 'Welcome back, Alice' },
    { selector: '[role="navigation"]', visible: true }
  ]
}
```

**Limit:** Max 5 DOM elements per snapshot. Max 20 snapshots per session.

---

### 2. API Fixture Generation

**Problem:** Tests that hit real APIs are slow, flaky, and require backend setup. Mocked tests run in milliseconds and are deterministic.

**Solution:** Generate fixture files from captured response bodies.

**What's captured:**
- Full response body (already in `networkBodies` buffer, up to 16KB per response)
- Status code, content type, method, URL

**Fixture format:**

```javascript
export const fixtures = {
  'METHOD /path': {
    status: number,
    contentType: string,
    body: object | string
  }
};
```

**Deduplication:** If the same endpoint was called multiple times, keep the last response (most likely to be the "settled" state).

**Sensitive data:** Same redaction as test bodies — passwords are `[user-provided]`, auth tokens are `mock-token-value`.

---

### 3. Visual Snapshot Hooks

**Problem:** DOM text assertions don't catch layout regressions, styling bugs, or broken images.

**Solution:** Insert `toHaveScreenshot()` calls at key steps. Playwright handles the actual screenshot comparison.

```javascript
// After navigation:
await expect(page).toHaveScreenshot('dashboard-loaded.png');

// After significant UI change:
await expect(page).toHaveScreenshot('modal-opened.png');
```

**When to insert:**
- After every `page.goto()` + page load
- After clicks that trigger navigation

**Naming convention:** `{step-number}-{action-description}.png`

**Not default:** Visual snapshots require baseline images and add test maintenance burden. Default is `false`.

---

### 4. Response Contract Assertions (Deep)

**Current behavior:** `assert_response_shape` generates flat `toHaveProperty('key')` checks.

**Enhanced behavior:** Generate deep structural assertions that catch when APIs change shape:

```javascript
// Current (shallow):
expect(body).toHaveProperty('user');

// Enhanced (deep):
expect(body.user).toEqual(expect.objectContaining({
  id: expect.any(Number),
  email: expect.any(String),
  name: expect.any(String),
}));
```

**Rules:**
- Primitives: `expect.any(String)`, `expect.any(Number)`, `expect.any(Boolean)`
- Objects: `expect.objectContaining({...})` recursively
- Arrays: `expect.arrayContaining([expect.objectContaining({...})])` for first element shape
- Depth limit: 3 levels (same as current shape extraction)
- Only for JSON responses with `content-type: application/json`

---

### 5. Wait Strategies

**Problem:** Current tests use `waitForResponse` for network, but have no strategy for DOM settling.

**Solution:** Insert appropriate wait strategies based on what was observed:

| Observed Pattern | Generated Wait |
|-----------------|---------------|
| Navigation after click | `await expect(page).toHaveURL(...)` |
| API call after click | `page.waitForResponse(...)` before click |
| DOM content after API | `await expect(element).toBeVisible()` |
| Long gap (>2s) between actions | `await page.waitForLoadState('networkidle')` |

---

### 6. Assertion Confidence Levels

Not all assertions are equally reliable. The generated test includes comments indicating confidence:

```javascript
// High confidence: status code from captured response
expect(loginResp.status()).toBe(200);

// Medium confidence: response shape (may vary with data)
expect(loginBody).toHaveProperty('token');

// Low confidence: DOM text (may change with content updates)
await expect(page.getByRole('heading')).toContainText('Dashboard');
```

The AI assistant can use these confidence annotations to decide which assertions to keep or customize.

---

## Data Flow

```
Extension (already captures)          Server (generate_test v2)
─────────────────────────────         ─────────────────────────

Enhanced Actions (50 buffer)  ──┐
                                ├──→  GetSessionTimeline()
Network Bodies (100 buffer)   ──┤         │
                                │         ▼
Browser Logs (1000 entries)   ──┘    Correlated Timeline
                                         │
DOM Snapshots (new, 20 max)   ──────────→│
                                         ▼
                                  generateTestScript()
                                         │
                                         ├──→ Test file (.spec.js)
                                         └──→ Fixtures file (optional)
```

---

## Extension Changes: DOM Snapshots

The extension needs one new capability: capturing a DOM snapshot after navigations.

### New Message Type

```javascript
// Sent from inject.js to content.js after navigation settles
{
  type: 'GASOLINE_DOM_SNAPSHOT',
  payload: {
    timestamp: Date.now(),
    url: location.href,
    title: document.title,
    elements: [
      {
        role: 'heading',
        level: 1,
        text: 'Dashboard',
        testId: null,
        visible: true
      },
      {
        role: null,
        level: null,
        text: 'Welcome back, Alice',
        testId: 'user-greeting',
        visible: true
      }
    ]
  }
}
```

### Capture Strategy

```javascript
// In inject.js, after navigation detection (existing popstate/pushstate hooks):
function captureDOMSnapshot() {
  const elements = [];

  // 1. Find visible headings
  document.querySelectorAll('h1, h2').forEach(el => {
    if (el.offsetParent !== null && el.textContent.trim()) {
      elements.push({
        role: 'heading',
        level: parseInt(el.tagName[1]),
        text: el.textContent.trim().slice(0, 100),
        testId: el.dataset.testid || el.dataset.testId || null,
        visible: true
      });
    }
  });

  // 2. Find elements with test IDs that have text
  document.querySelectorAll('[data-testid], [data-test-id]').forEach(el => {
    if (el.offsetParent !== null && el.textContent.trim() && elements.length < 5) {
      const testId = el.dataset.testid || el.dataset.testId;
      if (!elements.some(e => e.testId === testId)) {
        elements.push({
          role: el.getAttribute('role') || null,
          level: null,
          text: el.textContent.trim().slice(0, 100),
          testId: testId,
          visible: true
        });
      }
    }
  });

  return elements.slice(0, 5);
}
```

### Trigger Points

| Event | Action |
|-------|--------|
| `popstate` / `pushState` / `replaceState` | Capture after 500ms settle delay |
| `load` event | Capture after 200ms |
| After recorded click that triggers navigation | Captured via navigate action handler |

### Performance Budget

- Snapshot capture: < 2ms (DOM query only, no serialization of large trees)
- Max 5 elements per snapshot
- Max 20 snapshots buffered
- Debounce: 500ms between snapshots

---

## Server Changes

### New Types

```go
// DOMSnapshot represents visible DOM state at a point in time
type DOMSnapshot struct {
    Timestamp int64          `json:"ts"`
    URL       string         `json:"url"`
    Title     string         `json:"title"`
    Elements  []DOMElement   `json:"elements"`
}

type DOMElement struct {
    Role    string `json:"role,omitempty"`
    Level   int    `json:"level,omitempty"`
    Text    string `json:"text"`
    TestID  string `json:"testId,omitempty"`
    Visible bool   `json:"visible"`
}

// TestOutput contains the generated test and optional fixtures
type TestOutput struct {
    TestScript   string `json:"test_script"`
    FixtureFile  string `json:"fixture_file,omitempty"`
    TestName     string `json:"test_name"`
    ActionCount  int    `json:"action_count"`
    AssertCount  int    `json:"assertion_count"`
}
```

### Enhanced TestGenerationOptions

```go
type TestGenerationOptions struct {
    TestName    string
    LastNActions int
    BaseURL     string
    URLFilter   string
    Assertions  AssertionOptions
    Fixtures    bool
}

type AssertionOptions struct {
    Network       bool // Assert API status codes (default: true)
    ResponseShape bool // Assert response body structure (default: true)
    NoErrors      bool // Assert no console errors (default: true)
    DOMState      bool // Assert visible DOM elements (default: true)
    Visual        bool // Insert toHaveScreenshot() hooks (default: false)
}
```

### Enhanced Timeline Entry

```go
type TimelineEntry struct {
    // ... existing fields ...

    // DOM state (populated for navigation/post-click entries)
    DOMElements []DOMElement `json:"domElements,omitempty"`
    PageTitle   string       `json:"pageTitle,omitempty"`
}
```

### Buffer Management

```go
const (
    maxDOMSnapshots     = 20
    maxElementsPerSnap  = 5
    domSnapshotDebounce = 500 * time.Millisecond
)
```

---

## Assertion Generation Algorithm

```
For each action in timeline:
  1. BEFORE the action:
     - If network requests follow this action, setup waitForResponse() promises

  2. EMIT the action:
     - click → page.getByX().click()
     - fill → page.getByX().fill(value)
     - navigate → expect(page).toHaveURL()
     - etc.

  3. AFTER the action:
     - If network responses were captured:
       a. Await the response promise
       b. Assert status code
       c. If response_shape: assert body structure
     - If DOM snapshot exists for the resulting URL:
       a. Assert visible headings
       b. Assert testId elements contain expected text
     - If visual: insert toHaveScreenshot()
     - If the NEXT action is >2s away: insert waitForLoadState('networkidle')

At test end:
  - If no_errors: assert consoleErrors.length === 0
  - If errors WERE present in capture: comment them as known issues
```

---

## Output Limits

| Constraint | Limit | Reason |
|-----------|-------|--------|
| Test script size | 100KB | Cap MCP response |
| Fixture file size | 50KB | Cap response body data |
| DOM snapshots | 20 per session | Memory bound |
| Elements per snapshot | 5 | Keep assertions focused |
| Response shape depth | 3 levels | Avoid assertion bloat |
| Actions processed | 50 max | Buffer limit |
| Network bodies included | 20 max | Fixture size cap |
| Text content in assertions | 100 chars | Stability |

---

## Response Format

The MCP tool returns:

```json
{
  "test_script": "import { test, expect } from '@playwright/test';\n\ntest('login flow', ...",
  "fixture_file": "export const fixtures = { ... }",
  "test_name": "login-flow",
  "action_count": 8,
  "assertion_count": 14
}
```

The AI assistant receives this and can write the files to disk, customize assertions, or ask the user to review.

---

## Comparison: Before and After

### Before (current `generate_test`)

```javascript
test('user session', async ({ page }) => {
  const consoleErrors = [];
  page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });

  await page.goto('http://localhost:3000/login');
  await page.getByTestId('email-input').fill('user@example.com');
  await page.getByTestId('password-input').fill('[user-provided]');

  const resp0 = page.waitForResponse(r => r.url().includes('/api/auth/login'));
  await page.getByRole('button', { name: 'Log in' }).click();
  expect((await resp0).status()).toBe(200);

  await expect(page).toHaveURL(/\/dashboard/);
  expect(consoleErrors).toHaveLength(0);
});
```

**What this misses:**
- Did the dashboard actually render?
- What shape was the login response?
- Are the mock-able fixtures available for CI?

### After (v2 `generate_test`)

```javascript
test('login and view dashboard', async ({ page }) => {
  const consoleErrors = [];
  page.on('console', msg => { if (msg.type() === 'error') consoleErrors.push(msg.text()); });

  // Step 1: Navigate to login
  await page.goto('http://localhost:3000/login');
  await expect(page.getByRole('heading', { name: 'Sign In' })).toBeVisible();

  // Step 2-3: Fill credentials
  await page.getByTestId('email-input').fill('user@example.com');
  await page.getByTestId('password-input').fill('[user-provided]');

  // Step 4: Submit login
  const loginResponse = page.waitForResponse(
    r => r.url().includes('/api/auth/login') && r.request().method() === 'POST'
  );
  await page.getByRole('button', { name: 'Log in' }).click();

  // Assert: login API contract
  const loginResp = await loginResponse;
  expect(loginResp.status()).toBe(200);
  const loginBody = await loginResp.json();
  expect(loginBody).toEqual(expect.objectContaining({
    token: expect.any(String),
    user: expect.objectContaining({
      id: expect.any(Number),
      email: expect.any(String),
    })
  }));

  // Step 5: Dashboard loaded
  await expect(page).toHaveURL(/\/dashboard/);
  await expect(page.getByRole('heading', { name: 'Dashboard' })).toBeVisible();
  await expect(page.getByTestId('user-greeting')).toContainText('Welcome');

  // Assert: dashboard API contract
  const statsResp = await page.waitForResponse(r => r.url().includes('/api/dashboard/stats'));
  expect(statsResp.status()).toBe(200);
  const statsBody = await statsResp.json();
  expect(statsBody).toEqual(expect.objectContaining({
    totalUsers: expect.any(Number),
    activeToday: expect.any(Number),
  }));

  // Final: no errors during entire flow
  expect(consoleErrors).toHaveLength(0);
});
```

**What this catches that v1 doesn't:**
- Dashboard heading missing → test fails
- User greeting not rendered → test fails
- Login API response shape changed (removed `user.email`) → test fails
- Stats API response shape changed → test fails
- Any console error during the flow → test fails

---

## Testing Requirements

### New Unit Tests

| Test | What it verifies |
|------|-----------------|
| `TestDOMSnapshotBuffer` | Snapshots buffer correctly, respect max limit |
| `TestDOMSnapshotInTimeline` | Snapshots correlate with correct timeline entries |
| `TestDOMAssertionGeneration` | Heading assertions, testId assertions, text content |
| `TestDeepResponseShapeAssertion` | `expect.objectContaining` pattern for nested objects |
| `TestFixtureGeneration` | Fixture file format, deduplication, sensitive data |
| `TestFixtureRedaction` | Auth tokens replaced, passwords removed |
| `TestVisualSnapshotHooks` | `toHaveScreenshot()` inserted at correct points |
| `TestAssertionOptionsDefaults` | Default options produce expected output |
| `TestAssertionOptionsDisabled` | Each option independently disables its assertions |
| `TestWaitStrategySelection` | Correct waits chosen based on timeline patterns |
| `TestLargeSessionTruncation` | 50+ actions handled within output limits |
| `TestEmptySession` | Graceful handling of no actions, no network, no DOM |

### New Extension Tests

| Test | What it verifies |
|------|-----------------|
| `TestDOMSnapshotCapture` | Elements captured correctly on navigation |
| `TestDOMSnapshotDebounce` | Rapid navigations don't flood snapshots |
| `TestDOMSnapshotMaxElements` | Capped at 5 elements |
| `TestDOMSnapshotMaxBuffer` | Capped at 20 snapshots |
| `TestDOMSnapshotPerformance` | < 2ms capture time |

### E2E Tests

| Test | What it verifies |
|------|-----------------|
| `TestGenerateTestE2E` | Full pipeline: capture session → generate test → assertions present |
| `TestGenerateTestWithFixtures` | Fixture file generated alongside test |
| `TestGeneratedTestRuns` | Generated test actually passes when executed against the same app |

---

## Performance Budget

| Operation | Budget | Notes |
|-----------|--------|-------|
| DOM snapshot capture | < 2ms | Only queries visible h1/h2 + [data-testid] |
| Snapshot buffer insertion | < 0.1ms | Append to slice |
| Timeline with DOM correlation | < 15ms | Merge-sort + DOM matching |
| Deep shape assertion generation | < 5ms | Recursive template expansion |
| Fixture file generation | < 10ms | JSON marshal of captured bodies |
| Total MCP tool call | < 200ms | Budget for full v2 output |

---

## Implementation Order

1. **DOM snapshot capture** (extension) — new message type, buffer management
2. **DOM snapshot ingestion** (server) — new HTTP endpoint, buffer storage
3. **Enhanced assertion generation** (server) — deep shape, DOM assertions
4. **Fixture generation** (server) — companion fixture file output
5. **Visual hooks** (server) — toHaveScreenshot() insertion
6. **Wait strategy selection** (server) — intelligent wait patterns
7. **MCP tool update** (server) — new input schema, TestOutput response

---

## Files to Change

| File | Changes |
|------|---------|
| `extension/inject.js` | Add `captureDOMSnapshot()`, navigation hooks, new message type |
| `extension/background.js` | Forward `GASOLINE_DOM_SNAPSHOT` to server |
| `extension/content.js` | Bridge new message type |
| `cmd/dev-console/v4.go` | New types, enhanced `generateTestScript()`, fixture generation |
| `cmd/dev-console/v4_test.go` | New unit tests |
| `cmd/dev-console/main.go` | New `/dom-snapshots` endpoint |
| `extension-tests/dom-snapshot.test.js` | Extension unit tests |
| `e2e-tests/generate-test.spec.js` | E2E tests |

---

## Backward Compatibility

- The existing `generate_test` tool gets enhanced inputs (new `assertions` object, `fixtures` field)
- Old-style calls (`assert_network: true`, `assert_no_errors: true`) continue to work — they map to the new `assertions` sub-object
- `get_reproduction_script` is unchanged
- `get_session_timeline` gains optional `domElements` in entries but is otherwise unchanged
- DOM snapshot capture is opt-in (only captured when enhanced actions are enabled)
