#!/usr/bin/env node

const { execFileSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const os = require('os');

// Import lib modules
const config = require('../lib/config');
const output = require('../lib/output');
const install = require('../lib/install');
const doctor = require('../lib/doctor');
const uninstall = require('../lib/uninstall');
const {
  EnvWithoutInstallError,
  ForAllWithoutInstallError,
  InvalidEnvFormatError,
} = require('../lib/errors');

function getPlatformPackage() {
  const platform = os.platform();
  const arch = os.arch();

  const platformMap = {
    'darwin-arm64': '@brennhill/gasoline-darwin-arm64',
    'darwin-x64': '@brennhill/gasoline-darwin-x64',
    'linux-arm64': '@brennhill/gasoline-linux-arm64',
    'linux-x64': '@brennhill/gasoline-linux-x64',
    'win32-x64': '@brennhill/gasoline-win32-x64',
  };

  const key = `${platform}-${arch}`;
  const pkg = platformMap[key];

  if (!pkg) {
    console.error(`Unsupported platform: ${platform}-${arch}`);
    console.error(`Supported platforms: ${Object.keys(platformMap).join(', ')}`);
    process.exit(1);
  }

  return pkg;
}

function findBinary() {
  const pkg = getPlatformPackage();
  const binaryName = os.platform() === 'win32' ? 'gasoline.exe' : 'gasoline';

  // Try to resolve from node_modules
  const candidates = [
    // Installed as dependency
    path.join(__dirname, '..', 'node_modules', pkg, 'bin', binaryName),
    // Hoisted in monorepo
    path.join(__dirname, '..', '..', pkg, 'bin', binaryName),
    // npm global install
    path.join(__dirname, '..', '..', '..', pkg, 'bin', binaryName),
  ];

  for (const candidate of candidates) {
    if (fs.existsSync(candidate)) {
      return candidate;
    }
  }

  // Try require.resolve as fallback
  try {
    const pkgPath = require.resolve(`${pkg}/package.json`);
    const binPath = path.join(path.dirname(pkgPath), 'bin', binaryName);
    if (fs.existsSync(binPath)) {
      return binPath;
    }
  } catch (e) {
    // Package not found
  }

  console.error(`Could not find gasoline binary for your platform.`);
  console.error(`Expected package: ${pkg}`);
  console.error(`\nTry reinstalling: npx gasoline-mcp@latest`);
  console.error(`Or build from source: go build ./cmd/dev-console`);
  process.exit(1);
}

function showConfigCommand() {
  const mcp = install.generateDefaultConfig();
  console.log('üìã Gasoline MCP Configuration\n');
  console.log('Add this to your Claude settings file:\n');
  console.log(JSON.stringify(mcp, null, 2));
  console.log('\nüìç Configuration Locations:');
  console.log('');
  console.log('Claude Code (VSCode):');
  console.log('  ~/.vscode/claude.mcp.json');
  console.log('');
  console.log('Claude Desktop App:');
  console.log(`  ${os.platform() === 'win32' ? '%APPDATA%' : '~'}/.claude/claude.mcp.json`);
  console.log('');
  console.log('Cursor:');
  console.log('  ~/.cursor/mcp.json');
  console.log('');
  console.log('Codeium:');
  console.log('  ~/.codeium/mcp.json');
  process.exit(0);
}

function installCommand(options) {
  try {
    const result = install.executeInstall(options);

    if (result.success) {
      if (options.dryRun) {
        console.log(`‚ÑπÔ∏è  Dry run: No files will be written\n`);
      }
      console.log(
        output.installResult({
          updated: result.updated,
          total: result.total,
          errors: result.errors,
          notFound: result.updated.length > 0
            ? []
            : config.getConfigCandidates().map(config.getToolNameFromPath),
        })
      );
      if (!options.dryRun) {
        console.log('‚ú® Gasoline MCP is ready to use!');
      }
      process.exit(0);
    } else {
      console.error(output.error('Installation failed'));
      result.errors.forEach(err => {
        console.error(`  ${err.name}: ${err.message}`);
        if (err.recovery) {
          console.error(`  Recovery: ${err.recovery}`);
        }
      });
      process.exit(1);
    }
  } catch (err) {
    console.error(err.format ? err.format() : `Error: ${err.message}`);
    process.exit(1);
  }
}

function doctorCommand(verbose) {
  try {
    const report = doctor.runDiagnostics(verbose);
    console.log(output.diagnosticReport(report));
    process.exit(0);
  } catch (err) {
    console.error(err.format ? err.format() : `Error: ${err.message}`);
    process.exit(1);
  }
}

function uninstallCommand(dryRun, verbose) {
  try {
    const result = uninstall.executeUninstall({ dryRun, verbose });

    if (dryRun) {
      console.log(`‚ÑπÔ∏è  Dry run: No files will be modified\n`);
    }
    console.log(output.uninstallResult(result));
    process.exit(0);
  } catch (err) {
    console.error(err.format ? err.format() : `Error: ${err.message}`);
    process.exit(1);
  }
}

function showHelp() {
  console.log('Gasoline MCP Server\n');
  console.log('Usage: gasoline-mcp [command] [options]\n');
  console.log('Commands:');
  console.log('  --config, -c          Show MCP configuration and where to put it');
  console.log('  --install, -i         Auto-install to your AI assistant config');
  console.log('  --doctor              Run diagnostics on installed configs');
  console.log('  --uninstall           Remove Gasoline from configs');
  console.log('  --help, -h            Show this help message\n');
  console.log('Options (with --install):');
  console.log('  --dry-run             Preview changes without writing files');
  console.log('  --for-all             Install to all 4 tools (Claude, VSCode, Cursor, Codeium)');
  console.log('  --env KEY=VALUE       Add environment variables to config (multiple allowed)');
  console.log('  --verbose             Show detailed operation logs\n');
  console.log('Options (with --uninstall):');
  console.log('  --dry-run             Preview changes without writing files');
  console.log('  --verbose             Show detailed operation logs\n');
  console.log('Examples:');
  console.log('  gasoline-mcp --install                # Install to first matching tool');
  console.log('  gasoline-mcp --install --for-all      # Install to all 4 tools');
  console.log('  gasoline-mcp --install --dry-run      # Preview without changes');
  console.log('  gasoline-mcp --install --env DEBUG=1  # Install with env vars');
  console.log('  gasoline-mcp --doctor                 # Check config health');
  console.log('  gasoline-mcp --uninstall              # Remove from all tools\n');
  process.exit(0);
}

// Parse CLI arguments
const args = process.argv.slice(2);
const verbose = args.includes('--verbose');
const dryRun = args.includes('--dry-run');

// Config command
if (args.includes('--config') || args.includes('-c')) {
  showConfigCommand();
}

// Install command
if (args.includes('--install') || args.includes('-i')) {
  // Validate flags
  if (args.includes('--env') && !(args.includes('--install') || args.includes('-i'))) {
    console.error(output.error('--env only works with --install', 'Usage: gasoline-mcp --install --env KEY=VALUE'));
    process.exit(1);
  }
  if (args.includes('--for-all') && !(args.includes('--install') || args.includes('-i'))) {
    console.error(output.error('--for-all only works with --install', 'Usage: gasoline-mcp --install --for-all'));
    process.exit(1);
  }

  // Parse env vars
  const envVars = {};
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--env' && i + 1 < args.length) {
      try {
        const parsed = config.parseEnvVar(args[i + 1]);
        envVars[parsed.key] = parsed.value;
      } catch (err) {
        console.error(output.error(err.message, err.recovery));
        process.exit(1);
      }
    }
  }

  const options = {
    dryRun,
    forAll: args.includes('--for-all'),
    envVars,
    verbose,
  };
  installCommand(options);
}

// Doctor command
if (args.includes('--doctor')) {
  doctorCommand(verbose);
}

// Uninstall command
if (args.includes('--uninstall')) {
  uninstallCommand(dryRun, verbose);
}

// Help command
if (args.includes('--help') || args.includes('-h')) {
  showHelp();
}

// No config command, run the binary

// Kill any existing gasoline servers on port 7890 before starting
// This ensures npx always uses the newly installed version
try {
  const { execSync } = require('child_process');
  const port = args.includes('--port') ? args[args.indexOf('--port') + 1] : '7890';

  // Find PIDs on the port
  try {
    const pids = execSync(`lsof -ti :${port}`, { encoding: 'utf8' }).trim();
    if (pids) {
      // Kill all processes on that port
      execSync(`kill ${pids}`, { stdio: 'ignore' });
      // Wait for port to be free
      setTimeout(() => {}, 500);
    }
  } catch (e) {
    // No process on port, or lsof failed - that's fine
  }
} catch (e) {
  // Kill failed - continue anyway
}

const binary = findBinary();

try {
  const result = execFileSync(binary, args, {
    stdio: 'inherit',
    env: process.env,
  });
} catch (e) {
  if (e.status !== null) {
    process.exit(e.status);
  }
  throw e;
}
